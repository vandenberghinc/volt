/*
 * Author: Daan van den Bergh
 * Copyright: © 2022 - 2023 Daan van den Bergh.
 */

// ---------------------------------------------------------
// Libraries.

const https = require("https");
const http = require("http");
const libcrypto = require("crypto");
const libnodemailer = require('nodemailer');

// ---------------------------------------------------------
// Imports.

const {vlib, vhighlight} = require("./vinc.js");
const Status = require("./status.js");
const Mutex = require("./mutex.js");
const Endpoint = require("./endpoint.js");
const Response = require("./response.js");
const Request = require("./request.js");
const FileWatcher = require("./file_watcher.js");

// ---------------------------------------------------------
// The server object.

class StripeError extends Error {
    constructor(message) {
        super(message);
    }
}

/*  @docs: {
 *  @chapter: Backend
 *  @title: Server
 *  @description: 
 *      The backend server class.
 *      When the https parameters `certificate` and `private_key` are defined, the server will run automatically on http and https.
 *  @parameter: {
 *      @name: production
 *      @description: Whether the server is in production more, or in development mode.
 *      @type: boolean
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: ip
 *      @description: The ip where the server will run on.
 *      @type: string
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: port
 *      @description: The port where the server will run on. Leave the port `null` to run on port `80` for http and on port `443` for https.
 *      @type: number
 *  }
 *  @parameter: {
 *      @name: certificate
 *      @description: The path to the certificate.
 *      @type: string
 *  }
 *  @parameter: {
 *      @name: private_key
 *      @description: The path to the private key file.
 *      @type: string
 *  }
 *  @parameter: {
 *      @name: passphrase
 *      @description: The passphrase of the private key.
 *      @type: string
 *  }
 *  @parameter: {
 *      @name: domain
 *      @description: The full domain url without `http://` or `https://`.
 *      @type: string
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: statics
 *      @description: Array with path's to static directories.
 *      @type: array[string]
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: database
 *      @description: The path to the database directory.
 *      @type: string
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: default_headers
 *      @description: Used to override the default headers generated by vweb. Leave parameter `default_headers` as `null` to let vweb automatically generate the default headers.
 *      @type: object
 *  }
 *  @parameter: {
 *      @name: favicon
 *      @description: The path to the favicon.
 *      @type: string
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: token_expiration
 *      @description: The token a sign in token will be valid in seconds.
 *      @type: number
 *  }
 *  @parameter: {
 *      @name: enable_2fa
 *      @description: Enable 2fa for user authentication.
 *      @type: boolean
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: enable_account_activation
 *      @description: Enable account activation by email after a user signs up.
 *      @type: boolean
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: smtp_sender
 *      @description:
 *          The smtp sender address may either be a string with the email address, e.g. `your@email.com`.
 *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
 *      @type: string, array
 *  }
 *  @parameter: {
 *      @name: smtp
 *      @description:
 *          The smpt arguments object.
 *          More information about the arguments can be found at the nodemailer <Link https://nodemailer.com/smtp/>documentation</Link>.
 *      @type: object
 *  }
 *  @parameter: {
 *      @name: mail_body_2fa
 *      @description: The default 2fa mail body.
 *      @type: string
 *      @required: true
 *  }
 *  @parameter:
 *      @name: stripe_secret_key
 *      @type: string
 *      @description: The stripe secret key. Required to accept payments.
 *  @parameter:
 *      @name: payment_products
 *      @type: object
 *      @description: 
 *          The payment products or subscriptions.
 *
 *          When the payment products has a value defined for attribute `recurring` it will become a subscription instead of a one-time payment.
 *
 *          Warning: The stripe products that do not match any of the payment products' id's will be deactivated and all subscriptions cancelled.
 *
 *          Warning: The payment product objects are accessable by anyone through the backend rest api so they should not contain any sensitive data.
 *
 *          Warning: Automatic tax must be enabled at https://dashboard.stripe.com/settings/tax. Afterwards registrations must be set up at https://stripe.com/docs/tax/registering otherwise payments may be refused.
 *          
 *          A one-time payment product object looks like:
 *          ```js
 *          {
 *              id: "prod_premium",                 // an unique id across your entire stripe account. Warning: this id can never be changed. Or the old product will be deactivated from your stripe account.
 *              name: "Premium",                    // the name of the subscription.
 *              description: "...",                 // the description of the subscription.
 *              price: 9.99,                        // price in decimals.
 *              currency: "eur",                    // ISO currency code (lowercase)
 *              statement_descriptor: undefined,    // (optional) An arbitrary string to be displayed on your customer’s credit card or bank statement, max 22 chars long.
 *              icon: undefined,                    // (optional) the absolute url or the endpoint url (string that starts with a `/`) to the product's icon.
 *              tax_behavior: undefined,            // (optional) tax behavior, "inclusive" or "exclusive".
 *              tax_code: undefined,                // (optional) the product's tax code, more info can be found at https://stripe.com/docs/tax/tax-codes?type=digital.
 *          }```
 *
 *          A subscription product looks like:
 *          ```js
 *          {
 *              plans: [{
 *                  id: "prod_premium",              // an unique id across your entire stripe account. Warning: this id can never be changed. Or the old product will be deactivated from your stripe account.
 *                  name: "Premium",                // the name of the subscription.
 *                  description: "...",             // the description of the subscription.
 *                  price: 9.99,                    // price in decimals.
 *              }],
 *              currency: "eur",                    // ISO currency code (lowercase)
 *              interval: "month",                  // the recurring interval format, the following values are supported `["day", "week", "month", "year"]`.
 *              interval_count: 1,                  // (optional) the recurring interval count, by default `1`.
 *              statement_descriptor: undefined,    // (optional) An arbitrary string to be displayed on your customer’s credit card or bank statement, max 22 chars long.
 *              icon: undefined,                    // (optional) the absolute url or the endpoint url (string that starts with a `/`) to the product's icon.
 *              tax_behavior: undefined,            // (optional) tax behavior, "inclusive" or "exclusive".
 *              tax_code: undefined,                // (optional) the product's tax code, more info can be found at https://stripe.com/docs/tax/tax-codes?type=digital.
 *          }```
 *
 *          The following attributes may be defined in the subscription object and will be used for all the plan objects when the plan object's attribute is not defined.
 *          Or they may be defined for each plan to specify a unique value per plan.
 *              - name
 *              - description
 *              - currency
 *              - interval
 *              - interval_count
 *              - statement_descriptor
 *              - icon
 *              - tax_behavior
 *              - tax_code
 *
 *          When the user purchases a subscription for one of the plans, the other active plans from that subscription will automatically be cancelled.
 *
 *          Warning: 
 *              - The stripe settings should be configured to cancel subscriptions when all payment attempts on a subscription renewal have failed.
 *                It should be configured by default but it can be configered under "Manage failed payments" at https://dashboard.stripe.com/settings/billing/automatic.
 *  @parameter:
 *      @name: payment_return_url
 *      @type: string
 *      @description: The absolute url or the endpoint url (string that starts with a `/`) where the user will be redirected to after a payment (e.g. https://mydomain.com/payments/redirect).
 *  @parameter:
 *      @name: automatic_tax
 *      @type: boolean
 *      @description: Enable automatic tax for payments.
 *  @parameter: {
 *      @name: file_watcher
 *      @description: The file watcher arguments, define to enable file watching. The parameter may either be an FileWatcher object, an object with arguments or a string for the `source` argument.
 *      @type: FileWatcher, object, string.
 *  }
 *  @parameter:
 *      @name: on_refund
 *      @type: function
 *      @description: 
 *          The event that will be triggerred when a refund has been processed successfully.
 *
 *          The callback can also be assigned later to the server object under the same attribute name as the parameter's name.
 *
 *          By default vweb sends an email to the user informing them of the event. However when the callback returns an object with `send_mail: false` assigned, vweb will not email the user.
 *
 *          The callback may accept the following paramters:
 *          ```js
 *          ({
 *              uid: <number>,          // the user id that requested the refund.
 *              cid: <string>,          // the stripe customer id of the user that requested the refund.
 *              invoice: <string>,      // the id of the invoice of the requested refund.
 *              invoice_item: <string>, // the id of the invoice item of the requested refund.
 *              refund: <object>,       // the refund object.
 *          });
 *          ```
 *  @parameter:
 *      @name: on_refund_request
 *      @type: function
 *      @description: 
 *          The event that will be triggerred when a refund request has been made with `auto_advance` disabled.
 *
 *          The callback can also be assigned later to the server object under the same attribute name as the parameter's name.
 *
 *          In this callback you can send an email to your customer with refund instructions.
 *          When the user has fulfilled all refund requirements, the refund request can be retrieved with `Server.get_open_refund(refund.id)` using the `id` attribute of the refund object.
 *          Then the refund can be confirmed with `Server.create_refund({payment: refund.payment, auto_advance: true})` using the `payment` attribute of the refund object.
 *
 *          The callback may accept the following paramters:
 *          ```js
 *          ({
 *              uid: <number>,          // the user id that requested the refund.
 *              cid: <string>,          // the stripe customer id of the user that requested the refund.
 *              payment: <object>,      // the payment object from `Server.get_payments()`.
 *              invoice: <string>,      // the id of the invoice of the requested refund.
 *              invoice_item: <string>, // the id of the invoice item of the requested refund.
 *              refund: <object>,       // the refund object.
 *          });
 *          ```
 *  @parameter:
 *      @name: on_refund_failed
 *      @type: function
 *      @description: 
 *          The event that will be triggerred when a refund has been processed successfully.
 *
 *          The callback can also be assigned later to the server object under the same attribute name as the parameter's name.
 *
 *          By default vweb sends an email to the user informing them of the event. However when the callback returns an object with `send_mail: false` assigned, vweb will not email the user.
 *
 *          The callback may accept the following paramters:
 *          ```js
 *          ({
 *              uid: <number>,              // the user id that requested the refund.
 *              cid: <string>,              // the stripe customer id of the user that requested the refund.
 *              reason: <string>,           // the failure reason string.
 *              description: <string>,      // the failure reason description.
 *              requires_action: <boolean>, // a boolean indicating whether the refund failed because it required user action.
 *              invoice: <string>,          // the id of the invoice of the requested refund.
 *              invoice_item: <string>, // the id of the invoice item of the requested refund.
 *              refund: <object>,           // the stripe refund object.  
 *          });
 *          ```
 *  @parameter:
 *      @name: on_payment_requires_action
 *      @type: function
 *      @description: 
 *          The event that will be triggerred when a refund has been processed successfully.
 *
 *          The callback can also be assigned later to the server object under the same attribute name as the parameter's name.
 *
 *          The callback may accept the following paramters:
 *          ```js
 *          ({
 *              uid: <number>,      // the user id of the user that made the payment.
 *              cid: <string>,      // the stripe customer id of the user that made the payment.
 *              invoice: <object>,  // the stripe invoice object of the payment.
 *          })
 *          ```
 *  @parameter:
 *      @name: on_payment_failed
 *      @type: function
 *      @description: 
 *          The event that will be triggerred when a refund has been processed successfully.
 *
 *          The callback can also be assigned later to the server object under the same attribute name as the parameter's name.
 *
 *          The callback may accept the following paramters:
 *          ```js
 *          ({
 *              uid: <number>,      // the user id of the user that made the payment.
 *              cid: <string>,      // the stripe customer id of the user that made the payment.
 *              invoice: <object>,  // the stripe invoice object of the payment.
 *          })
 *          ```
 *  @parameter:
 *      @name: on_payment
 *      @type: function
 *      @description: 
 *          The event that will be triggerred when a refund has been processed successfully.
 *
 *          The callback can also be assigned later to the server object under the same attribute name as the parameter's name.
 *
 *          By default vweb sends an email to the user informing them of the event. However when the callback returns an object with `send_mail: false` assigned, vweb will not email the user.
 *
 *          The callback may accept the following paramters:
 *          ```js
 *          ({
 *              uid: <number>,              // the user id of the user that made the payment.      
 *              cid: <string>,              // the stripe customer id of the user that made the payment.
 *              product: <object>,          // the user defined product that was purchased.
 *              quantity: <number>,         // the quantity of the product that was purchased.
 *              address: <object>,          // the address information of the purchase.
 *              invoice_item: <object>,     // the stripe invoice item object.
 *              invoice: <object>,          // the stripe invoice object.
 *          });
 *          ```
 *  @parameter:
 *      @name: on_susbcription
 *      @type: function
 *      @description: 
 *          The event that will be triggerred when a refund has been processed successfully.
 *
 *          The callback can also be assigned later to the server object under the same attribute name as the parameter's name.
 *
 *          By default vweb sends an email to the user informing them of the event. However when the callback returns an object with `send_mail: false` assigned, vweb will not email the user.
 *
 *          The callback may accept the following paramters:
 *          ```js
 *          ({
 *              uid: <number>,                  // the user id of the user that made the payment.      
 *              cid: <string>,                  // the stripe customer id of the user that made the payment.
 *              product: <object>,              // the user defined product that was purchased.
 *              quantity: <number>,             // the quantity of the product that was purchased.
 *              subscription_item: <object>,    // the stripe subscription item object.
 *              subscription: <object>,         // the stripe subscription object.
 *          });
 *          ```
 *  @parameter:
 *      @name: on_susbcription_cancelled
 *      @type: function
 *      @description: 
 *          The event that will be triggerred when a refund has been processed successfully.
 *
 *          The callback can also be assigned later to the server object under the same attribute name as the parameter's name.
 *
 *          By default vweb sends an email to the user informing them of the event. However when the callback returns an object with `send_mail: false` assigned, vweb will not email the user.
 *
 *          The callback may accept the following paramters:
 *          ```js
 *          ({
 *              uid: <number>,                  // the user id of the user that made the cancellation.      
 *              cid: <string>,                  // the stripe customer id of the user that made the cancellation.
 *              product: <object>,              // the user defined product that was cancelled.
 *              subscription_item: <object>,    // the stripe subscription item object.
 *              subscription: <object>,         // the stripe subscription object.
 *          })
 *          ```
 } */

// @tdo implement 3D secure "requires_action" status for a refund and payment intent.
// https://stripe.com/docs/payments/3d-secure

class Server {

    // Mimes for content type detection.
    // Must be defined before creating static endpoints.
    static content_type_mimes = [
        [".html", "text/html"],
        [".htm", "text/html"],
        [".shtml", "text/html"],
        [".css", "text/css"],
        [".xml", "application/xml"],
        [".gif", "image/gif"],
        [".jpeg", "image/jpeg"],
        [".jpg", "image/jpeg"],
        [".js", "application/javascript"],
        [".atom", "application/atom+xml"],
        [".rss", "application/rss+xml"],
        [".mml", "text/mathml"],
        [".txt", "text/plain"],
        [".jad", "text/vnd.sun.j2me.app-descriptor"],
        [".wml", "text/vnd.wap.wml"],
        [".htc", "text/x-component"],
        [".png", "image/png"],
        [".tif", "image/tiff"],
        [".tiff", "image/tiff"],
        [".wbmp", "image/vnd.wap.wbmp"],
        [".ico", "image/x-icon"],
        [".jng", "image/x-jng"],
        [".bmp", "image/x-ms-bmp"],
        [".svg", "image/svg+xml"],
        [".svgz", "image/svg+xml"],
        [".webp", "image/webp"],
        [".woff", "font/woff"],
        [".woff2", "font/woff2"],
        [".jar", "application/java-archive"],
        [".war", "application/java-archive"],
        [".ear", "application/java-archive"],
        [".json", "application/json"],
        [".hqx", "application/mac-binhex40"],
        [".doc", "application/msword"],
        [".pdf", "application/pdf"],
        [".ps", "application/postscript"],
        [".eps", "application/postscript"],
        [".ai", "application/postscript"],
        [".rtf", "application/rtf"],
        [".m3u8", "application/vnd.apple.mpegurl"],
        [".xls", "application/vnd.ms-excel"],
        [".eot", "application/vnd.ms-fontobject"],
        [".ppt", "application/vnd.ms-powerpoint"],
        [".wmlc", "application/vnd.wap.wmlc"],
        [".kml", "application/vnd.google-earth.kml+xml"],
        [".kmz", "application/vnd.google-earth.kmz"],
        [".7z", "application/x-7z-compressed"],
        [".cco", "application/x-cocoa"],
        [".jardiff", "application/x-java-archive-diff"],
        [".jnlp", "application/x-java-jnlp-file"],
        [".run", "application/x-makeself"],
        [".pl", "application/x-perl"],
        [".pm", "application/x-perl"],
        [".prc", "application/x-pilot"],
        [".pdb", "application/x-pilot"],
        [".rar", "application/x-rar-compressed"],
        [".rpm", "application/x-redhat-package-manager"],
        [".sea", "application/x-sea"],
        [".swf", "application/x-shockwave-flash"],
        [".sit", "application/x-stuffit"],
        [".tcl", "application/x-tcl"],
        [".tk", "application/x-tcl"],
        [".der", "application/x-x509-ca-cert"],
        [".pem", "application/x-x509-ca-cert"],
        [".crt", "application/x-x509-ca-cert"],
        [".xpi", "application/x-xpinstall"],
        [".xhtml", "application/xhtml+xml"],
        [".xspf", "application/xspf+xml"],
        [".zip", "application/zip"],
        [".bin", "application/octet-stream"],
        [".exe", "application/octet-stream"],
        [".dll", "application/octet-stream"],
        [".deb", "application/octet-stream"],
        [".dmg", "application/octet-stream"],
        [".iso", "application/octet-stream"],
        [".img", "application/octet-stream"],
        [".msi", "application/octet-stream"],
        [".msp", "application/octet-stream"],
        [".msm", "application/octet-stream"],
        [".docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
        [".xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
        [".pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
        [".mid", "audio/midi"],
        [".midi", "audio/midi"],
        [".kar", "audio/midi"],
        [".mp3", "audio/mpeg"],
        [".ogg", "audio/ogg"],
        [".m4a", "audio/x-m4a"],
        [".ra", "audio/x-realaudio"],
        [".3gpp", "video/3gpp"],
        [".3gp", "video/3gpp"],
        [".ts", "video/mp2t"],
        [".mp4", "video/mp4"],
        [".mpeg", "video/mpeg"],
        [".mpg", "video/mpeg"],
        [".mov", "video/quicktime"],
        [".webm", "video/webm"],
        [".flv", "video/x-flv"],
        [".m4v", "video/x-m4v"],
        [".mng", "video/x-mng"],
        [".asx", "video/x-ms-asf"],
        [".asf", "video/x-ms-asf"],
        [".wmv", "video/x-ms-wmv"],
        [".avi", "video/x-msvideo"],
    ]

    // Constructor.
    constructor({
        production = false,
        ip = "127.0.0.1",
        port = 8000,
        certificate = null,
        private_key = null,
        passphrase = null,
        domain = null,
        statics = [],
        database = null,
        default_headers = null,
        favicon = null,
        token_expiration = 86400,
        enable_2fa = false,
        enable_account_activation = true,
        smtp_sender = null,
        smtp = null,
        mail_body_2fa = "<p>Your 2FA code is: {{2FA}}.</p>",
        stripe_secret_key = null,
        stripe_webhook_key = null,
        payment_products = [],
        payment_return_url = null,
        automatic_tax = true,
        file_watcher = null,
        on_refund = null,
        on_refund_request = null,
        on_refund_failed = null,
        on_payment_requires_action = null,
        on_payment_failed = null,
        on_payment = null,
        on_susbcription = null,
        on_susbcription_cancelled = null,
    }) {

        // Check args.
        if (typeof ip !== "string") {
            throw Error(`Parameter "ip" should be a defined value of type "string".`);
        }
        // if (typeof port !== "number") {
        //     throw Error(`Parameter "port" should be a defined value of type "number".`);
        // }
        // if (typeof certificate !== "string") {
        //     throw Error(`Parameter "certificate" should be a defined value of type "string".`);
        // }
        // if (typeof private_key !== "string") {
        //     throw Error(`Parameter "private_key" should be a defined value of type "string".`);
        // }
        if (typeof domain !== "string") {
            throw Error(`Parameter "domain" should be a defined value of type "string".`);
        }
        if (typeof database !== "string") {
            throw Error(`Parameter "database" should be a defined value of type "string".`);
        }
        if (typeof favicon !== "string") {
            throw Error(`Parameter "favicon" should be a defined value of type "string".`);
        }
        // if (typeof smtp_sender !== "string" && !Array.isArray(smtp_sender)) {
        //     throw Error(`Parameter "smtp_sender" should database a defined value of type "string" or "array".`);
        // }
        // if (typeof smtp !== "object") {
        //     throw Error(`Parameter "smtp" should database a defined value of type "object".`);
        // }

        // Attributes.
        this.port = port;
        this.ip = ip;
        if (certificate != null) {
            this.certificate = new vlib.Path(certificate).load_sync('utf8');
        }
        if (private_key != null) {
            this.private_key = new vlib.Path(private_key).load_sync('utf8');
        }
        this.domain = domain;
        this.statics = statics.map((path) => new vlib.Path(path));
        this.database = new vlib.Path(database).abs();
        this.favicon = favicon;
        this.enable_2fa = enable_2fa;
        this.enable_account_activation = enable_account_activation;
        this.production = production;
        this.token_expiration = token_expiration;
        this.mail_body_2fa = mail_body_2fa;
        this.stripe_enabled = stripe_secret_key != null;
        if (stripe_secret_key != null) {
            this.stripe = require("stripe")(stripe_secret_key);
            if (typeof payment_return_url !== "string") {
                throw Error("Define parameter \"payment_return_url\" to define an absolute url where the user should be redirected to after a payment.");
            }
            if (payment_return_url.charAt(0) === "/") {
                payment_return_url = `http${private_key === null ? "" : "s"}://${domain}${payment_return_url}`;
            }
        }
        this.stripe_webhook_key = stripe_webhook_key;
        this.payment_products = payment_products;
        this.payment_return_url = payment_return_url;
        this.automatic_tax = automatic_tax;
        this.on_refund = on_refund;
        this.on_refund_request = on_refund_request;
        this.on_refund_failed = on_refund_failed;
        this.on_payment_requires_action = on_payment_requires_action;
        this.on_payment_failed = on_payment_failed;
        this.on_payment = on_payment;
        this.on_susbcription = on_susbcription;
        this.on_susbcription_cancelled = on_susbcription_cancelled;

        this.stripe = new Stripe({
            full_domain: `http${private_key == null ? "" : "s"}://`,
            database: this.database,
            payment_products: this.payment_products,
        })

        // Default headers.
        if (default_headers === null) {
            this.default_headers = {
                "Vary": "Origin",
                "Referrer-Policy": "same-origin",
                "Access-Control-Allow-Methods": "GET, POST, PUT, PATCH, DELETE, OPTIONS",
                "X-XSS-Protection": "1; mode=block",
                "X-Content-Type-Options": "frame-ancestors 'none'; nosniff;",
                "X-Frame-Options": "DENY",
                "Strict-Transport-Security": "max-age=31536000",
                "Content-Security-Policy": 
                    "default-src 'self' js.stripe.com *.google-analytics.com https://my.spline.design; " +
                    `img-src 'self' http://${this.domain} https://${this.domain} *.google-analytics.com; ` +
                    "script-src 'self' 'unsafe-inline' js.stripe.com ajax.googleapis.com www.googletagmanager.com googletagmanager.com *.google-analytics.com code.jquery.com; " +
                    "style-src 'self' 'unsafe-inline'; " +
                    "upgrade-insecure-requests; " +
                    "block-all-mixed-content;",
            }
        } else {
            this.default_headers = default_headers;
        }

        // Define your list of endpoints
        this.endpoints = [];

        // File watcher.
        if (file_watcher != null && process.env.VWEB_FILE_WATCHER != '1') {

            // Create default endpoints.
            let additional_paths = this._create_default_endpoints();

            // Create static endpoints.
            this.statics.iterate((path) => {
                additional_paths = additional_paths.concat(this._create_static_endpoints(path.base(), path));
            });

            // Add the vweb backend source files to the additional files.
            additional_paths.push(__dirname);

            // Initialize file watcher.
            if (typeof file_watcher === "string" || file_watcher instanceof vlib.Path) {
                this.file_watcher = new FileWatcher({source: file_watcher});
            }
            else if (file_watcher instanceof FileWatcher) {
                this.file_watcher = file_watcher;
            } else {
                this.file_watcher = new FileWatcher(file_watcher);
            }
            this.file_watcher.excluded.push(this.database.str());

            // Add default and static endpoints.
            this.file_watcher.additional_paths = additional_paths;
            
            // Start.
            this.file_watcher.start();
            return null;
        }

        // The smtp instance.
        this.smtp_enabled = smtp_sender !== null && typeof smtp === "object";
        if (this.smtp_enabled) {
            this.smtp_sender = smtp_sender;
            this.smtp = libnodemailer.createTransport(smtp);
        }
        
        // Create an HTTPS server
        if (this.private_key != null && this.certificate != null) {
            this.https = https.createServer({key: this.private_key, cert: this.certificate, passphrase: passphrase}, (request, response) => this._serve(request, response));
        }
        this.http = http.createServer((request, response) => this._serve(request, response));

        // Max uid.
        this.max_uid = null;
        this.edit_max_uid_mutex = new Mutex();

        // The master sha256 hash key.
        this.hash_key = null;
    }

    // ---------------------------------------------------------
    // Utils (private).

    // Iterate a subpath directory in the database.
    async _iter_db_dir(subpath, callback) {
        return this.database.join(subpath).paths_sync().iterate_async_await((path) => {
            if (path.name() !== ".DS_Store") {
                return callback(path);
            }
        });
    }

    // Check of the uid is within the max uid range.
    _check_uid_within_range(uid) {
        if (uid == null || uid < 0 || uid == "") {
            throw Error("Undefined user id.");
        }
        else if (uid > this.max_uid) {
            throw Error(`User id "${uid}" does not exist.`);
        }
    }

    // Get a content type from an extension.
    _sys_get_content_type(extension) {
        let content_type = Server.content_type_mimes.iterate((item) => {
            if (item[0] == extension) {
                return item[1];
            }
        })
        if (content_type == null) {
            content_type = "application/octet-stream";
        }
        return content_type;
    }

    // Generate a key.
    _sys_generate_key(path) {
        const length = 32;
        const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        let key = "";
        for (let i = 0; i < length; i++) {
            key += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        return key;
    }

    // Generate a crypto key.
    _sys_generate_crypto_key(length = 32) {
        return libcrypto.randomBytes(length).toString('hex');
    }

    // Generate a 2fa code.
    _sys_generate_2fa(path) {
        const length = 6;
        const charset = "0123456789";
        let key = "";
        for (let i = 0; i < length; i++) {
            key += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        return key;
    }

    // Load data into an object formatted line by line.
    // All data will be loaded as a string.
    // When the path does not exists the input object will be returned.
    _sys_load_data_into_obj(path, obj = {}, keys = []) {
        if (!path.exists()) {
            return obj;
        }
        const data = path.load_sync();
        let key = 0;
        const info = {line: "", line_number: 0}
        for (let i = 0; i < data.length; i++) {
            const c = data.charAt(i);
            if (c == '\n') {
                if (obj[keys[key]] == null) {
                    obj[keys[key]] = "";
                }
                ++key;
            } else {
                if (obj[keys[key]] == null) {
                    obj[keys[key]] = "";
                }
                obj[keys[key]] += c;
            }
        }
        // for (let i = key; i < keys.length; i++) {
        //     obj[keys[i]] = "";
        // }
        return obj;
    }

    // Save an object to data formatted line by line.
    _sys_save_data_into_obj(path, obj, keys) {
        let data = "";
        for (let i = 0; i < keys.length; i++) {
            if (typeof obj[keys[i]] === "string") {
                data += obj[keys[i]];
            } else {
                data += obj[keys[i]].toString();
            }
            data += "\n";
        }
        path.save_sync(data);
    }

    // Save or delete uid by username,
    _sys_save_uid_by_username(uid, username) {
        this.database.join(`.sys/usernames/${username}`, false).save_sync(uid.toString());
    }
    _sys_delete_uid_by_username(username) {
        this.database.join(`.sys/usernames/${username}`, false).del_sync();
    }

    // Save or delete uid by email,
    _sys_save_uid_by_email(uid, email) {
        this.database.join(`.sys/emails/${email}`, false).save_sync(uid.toString());
    }
    _sys_delete_uid_by_email(email) {
        this.database.join(`.sys/emails/${email}`, false).del_sync();
    }

    /*  Save, load or delete a system user object.
        An object has the following keys if the user is not deleted: 
        {
            first_name: string,
            last_name: string,
            username: string,
            email: string,
            password: string,
            api_key: string,
        }
     */
    _sys_load_user(uid) {
        return this._sys_load_data_into_obj(this.database.join(`.sys/users/${uid}`, false), {uid: uid}, [
            "first_name",
            "last_name",
            "username",
            "email",
            "password",
            "api_key",
        ]);
    }
    _sys_save_user(uid, user) {
        return this._sys_save_data_into_obj(
            this.database.join(`.sys/users/${uid}`, false), 
            user, 
            [
                "first_name",
                "last_name",
                "username",
                "email",
                "password",
                "api_key",
            ],
        );
    }

    // @todo the parameter requires the full sys user object.
    _sys_delete_user(user) {
        throw Error("@todo the parameter requires the full sys user object.");
        this.database.join(`.sys/users/${user.uid}`, false).del_sync();
        this._sys_delete_uid_by_username(user.username);
        this._sys_delete_uid_by_email(user.email);
    }

    /*  Save, load or delete a system user token object used for signin in.
        An object has the following keys if the token exists:
        {
            expiration: number,
            token: string,
        }
     */
    _sys_load_user_token(uid) {
        const obj = this._sys_load_data_into_obj(this.database.join(`.sys/tokens/${uid}`, false), {expiration: 0}, [
            "expiration",
            "token",
        ]);
        if (typeof obj.expiration === "string") {
            obj.expiration = parseInt(obj.expiration);
        }
        return obj;
    }
    _sys_save_user_token(uid, token) {
        return this._sys_save_data_into_obj(
            this.database.join(`.sys/tokens/${uid}`, false), 
            token,
            [
               "expiration",
                "token",
            ],
        );
    }
    _sys_delete_user_token(uid) {
        this.database.join(`.sys/tokens/${uid}`, false).del_sync();
    }

    /*  Save, load or delete a system user 2fa object used for two factor authentication.
        An object has the following keys if the token exists:
        {
            expiration: number,
            code: string,
        }
     */
    _sys_load_user_2fa(uid) {
        const obj = this._sys_load_data_into_obj(this.database.join(`.sys/2fa/${uid}`, false), {expiration: 0}, [
            "expiration",
            "code",
        ]);
        if (typeof obj.expiration === "string") {
            obj.expiration = parseInt(obj.expiration);
        }
        return obj;
    }
    _sys_save_user_2fa(uid, token) {
        return this._sys_save_data_into_obj(
            this.database.join(`.sys/2fa/${uid}`, false), 
            token,
            [
                "expiration",
                "code",
            ]
        );
    }
    _sys_delete_user_2fa(uid) {
        this.database.join(`.sys/2fa/${uid}`, false).del_sync();
    }

    // Load user data helper.
    // Use async to keep it persistent with other functions.
    _sys_load_user_data(uid, subpath, def, privacy) {
        // Check uid.
        this._check_uid_within_range(uid);

        // Check path.
        if (subpath.indexOf("..") !== -1) {
            throw Error(`Permission denied (path-injection).`);
        }
        const path = this.database.join(`users/${uid}/${privacy}/${subpath}`, false).abs();
        if (path.str().eq_first(`${this.database}/users/${uid}/${privacy}/`) === false) {
            throw Error(`Permission denied (path-injection).`);
        }

        // Does not exist.
        if (!path.exists()) {
            if (def !== null) {
                return def;
            }
        }

        // Load data.
        let data = path.load_sync();

        // Cast data.
        if (def == null || typeof def === "string") {
            return data;
        } else if (typeof def === "boolean") {
            return data === "true" || data === "1" || data === "True" || data === "TRUE";
        } else if (typeof def === "number") {
            return parseFloat(data);
        } else if (Array.isArray(def)) {
            return JSON.parse(data);
        } else if (typeof def === "object") {
            data = JSON.parse(data);
            Object.keys(def).iterate((key) => {
                if (data[key] === undefined) {
                    data[key] = def[key];
                }
            })
            return data;
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["string", "array", "object"].`);
        }
    }

    // Save user data helper.
    // Use async to keep it persistent with other functions.
    _sys_save_user_data(uid, subpath, privacy) {

        // Check uid.
        this._check_uid_within_range(uid);

        // Check path.
        if (subpath.indexOf("..") !== -1) {
            throw Error(`Permission denied (path-injection).`);
        }
        const path = this.database.join(`users/${uid}/${privacy}/${subpath}`, false).abs();
        if (path.str().eq_first(`${this.database}/users/${uid}/${privacy}/`) === false) {
            throw Error(`Permission denied (path-injection).`);
        }
        return path;
    }

    // Create a sha hmac with the master key.
    _hmac(data) {
        const hmac = libcrypto.createHmac("sha256", this.hash_key);
        hmac.update(data);
        return hmac.digest("hex");
    }

    // ---------------------------------------------------------
    // Authentication (private).

    // Generate a token by uid.
    _generate_token(uid) {
        this._check_uid_within_range(uid);
        const token = `1${uid}:${this._sys_generate_key()}`;
        this._sys_save_user_token(uid, {
            expiration: Date.now() + this.token_expiration * 1000,
            token: this._hmac(token),
        });
        return token;
    }

    // Perform authentication on a request.
    // When the authentication has failed an args object for response.send will be returned.
    // On a successfull authentication `null` will be returned.
    async _authenticate(request) {

        // // Get api key key from bearer.
        const authorization = request.headers["authorization"];
        if (authorization !== undefined) {
            if (typeof authorization !== "string") {
                return {
                    status: 400, 
                    data: "Bad Request: Invalid authorization header.",
                };
            }
            if (!authorization.eq_first("Bearer ")) {
                return {
                    status: 400, 
                    data: "Bad Request: Invalid authorization scheme, the authorization scheme must be \"Bearer\".",
                };
            }
            let api_key = "";
            for (let i = 7; i < authorization.length; i++) {
                const c = authorization[i];
                if (c == " ") {
                    continue;
                }
                api_key += c;
            }
            const uid = await this.get_uid_by_api_key(api_key);
            if (await this.verify_api_key_by_uid(uid, api_key) !== true) {
                return {
                    status: Status.unauthorized, 
                    data: "Unauthorized.",
                };

            }
            request.uid = uid;
            return null;
        }

        // Get token from cookies.
        else {
            if (request.cookies.T == null || request.cookies.T.value == null) {
                return {
                    status: 302, 
                    headers: {"Location": `/signin?next=${request.url}`},
                    data: "Permission denied.",
                };
            }
            const token = request.cookies.T.value;
            const uid = await this.get_uid_by_api_key(token);
            if (await this.verify_token_by_uid(uid, token) !== true) {
                return {
                    status: 302, 
                    headers: {"Location": `/signin?next=${request.url}`},
                    data: "Permission denied.",
                };

            }
            request.uid = uid;
            return null;
        }

        // Authentication failed.
        return {
            status: 302, 
            headers: {"Location": `/signin?next=${request.url}`},
            data: "Permission denied.",
        };
    }

    // Sign a user in and return a response.
    async _sign_in_response(response, uid) {

        // Generate token.
        const token = this._generate_token(uid);
        
        // Create headers.
        this._create_token_cookie(response, token);
        await this._create_user_cookie(response, uid);
        await this._create_detailed_user_cookie(response, uid);
            
        // Response.
        response.send({
            status: 200,
            data: {message: "Successfully signed in."}
        });
    }

    // ---------------------------------------------------------
    // Headers (private).

    // Add header defaults.
    _set_header_defaults(response) {
        response.set_headers(this.default_headers);
        // if (this.domain != null) {
        //     response.set_header("Origin", this.domain);
        //     response.set_header("Access-Control-Allow-Origin", this.domain);
        // }
    }
    
    // Create token headers.
    //  - Should be called when generating a token.
    _create_token_cookie(response, token) {
        response.set_header("Cache-Control", "max-age=0, no-cache, no-store, must-revalidate, proxy-revalidate");
        response.set_header("Access-Control-Allow-Credentials", "true");
        let expires = new Date(new Date().getTime() + this.token_expiration * 1000);
        if (typeof token === "object") {
            token = token.token;
        }
        response.set_cookie(`T=${token}; Max-Age=86400; Path=/; Expires=${expires.toUTCString()}; SameSite=Strict; Secure; HttpOnly;`);
    }
    
    // Create user headers.
    //  - Should be called when a user is authenticated.
    async _create_user_cookie(response, uid) {
        if (uid != null && uid >= 0 && uid <= this.max_uid) {
            response.set_cookie(`UserID=${uid}; Path=/; SameSite=Strict; Secure;`);
            const is_activated = this.enable_account_activation ? await this.is_activated(uid) : true;
            response.set_cookie(`UserActivated=${is_activated}; Path=/; SameSite=Strict; Secure;`);
        } else {
            response.set_cookie(`UserID=-1; Path=/; SameSite=Strict; Secure;`);
            const is_activated = this.enable_account_activation ? false : true;
            response.set_cookie(`UserActivated=${is_activated}; Path=/; SameSite=Strict; Secure;`);
        }
    }
    
    // Create user headers.
    //  - Should be called when a user has just signed in, signed up or changed their account.
    async _create_detailed_user_cookie(response, uid) {
        const user = await this.get_user(uid);
        response.set_cookie(`UserName=${user.username}; Path=/; SameSite=Strict; Secure;`);
        response.set_cookie(`UserFirstName=${user.first_name} Path=/; SameSite=Strict; Secure;`);
        response.set_cookie(`UserLastName=${user.last_name}; Path=/; SameSite=Strict; Secure;`);
        response.set_cookie(`UserEmail=${user.email}; Path=/; SameSite=Strict; Secure;`);
    }
    
    // Reset all default cookies.
    // - Should be called when a user signs out.
    _reset_cookies(response) {
        response.set_cookie("T=; Path=/; SameSite=Strict; Secure; HttpOnly;");
        response.set_cookie("UserID=-1; Path=/; SameSite=Strict; Secure;");
        response.set_cookie("UserActivated=false; Path=/; SameSite=Strict; Secure;");
        // response.set_cookie("2FAUserID=-1; Path=/; SameSite=Strict; Secure;");
        response.set_cookie("UserName=; Path=/; SameSite=Strict; Secure;");
        response.set_cookie("UserFirstName=; Path=/; SameSite=Strict; Secure;");
        response.set_cookie("UserLastName=; Path=/; SameSite=Strict; Secure;");
        response.set_cookie("UserEmail=; Path=/; SameSite=Strict; Secure;");
    }

    // ---------------------------------------------------------
    // Endpoints (private).

    // Find endpoint.
    _find_endpoint(endpoint, method = null) {
        return this.endpoints.iterate((end) => {
            if (end.endpoint == endpoint && (method == null || method == end.method)) {
                return endpoint;
            }
        })
    }

    // Create static endpoints.
    _create_static_endpoints(base, dir) {
        const exclude = [".DS_Store"]
        let paths = [];
        dir.paths_sync().iterate((path) => {

            // Excluded.
            if (exclude.includes(path.name())) {
                return null;
            }

            // Add to paths.
            paths.push(path.str());

            // Read dir recursively.
            if (path.is_dir()) {
                paths = paths.concat(this._create_static_endpoints(base, path));
            }

            // Add file.
            else {
                let subpath = path.str().substr(base.length)
                if (subpath.charAt(0) != "/") {
                    subpath = "/" + subpath;
                }
                let data;
                if (path.extension() === ".js") {
                    data = path.load_sync();
                    const compiler = new vhighlight.JSCompiler({
                        line_breaks: true,
                        double_line_breaks: false,
                        comments: false,
                        white_space: false,
                    })
                    data = compiler.compile_code(data, path.str());
                } else {
                    data = path.load_sync({type: null});
                }
                this.endpoint(new Endpoint({
                    method: "GET",
                    endpoint: subpath,
                    data: data,
                    content_type: this._sys_get_content_type(path.extension())
                }))
            }
        })
        return paths;
    }

    // Create default endpoints.
    _create_default_endpoints() {

        // Vars.
        const additional_file_watcher_paths = [];

        // Add favicon.
        const favicon = new vlib.Path(this.favicon);
        this.endpoint(new Endpoint({
            method: "GET",
            endpoint: "/favicon.ico",
            data: favicon.load_sync({type: null}),
            content_type: this._sys_get_content_type(favicon.extension()),
        }))
        additional_file_watcher_paths.push(favicon.str());

        // Default static endpoints.
        const defaults = [
            {
                method: "GET",
                endpoint: "/vweb/vweb.css",
                content_type: "text/css",
                path: new vlib.Path(`${__dirname}/../frontend/css/vweb.css`),
            },
            {
                method: "GET",
                endpoint: "/vweb/vweb.js",
                content_type: "application/javascript",
                path: new vlib.Path(`${__dirname}/../frontend/min/vweb.js`),
            },
            {
                method: "GET",
                endpoint: "/vhighlight/vhighlight.css",
                content_type: "text/css",
                path: new vlib.Path(vhighlight.web_exports.css),
            },
            {
                method: "GET",
                endpoint: "/vhighlight/vhighlight.js",
                content_type: "application/javascript",
                path: new vlib.Path(vhighlight.web_exports.js),
            },
        ]
        defaults.iterate((item) => {
            this.endpoint(new Endpoint({
                method: item.method,
                endpoint: item.endpoint,
                data: item.path.load_sync(),
                content_type: item.content_type,
                compress: item.compress,
            }))
            additional_file_watcher_paths.push(item.path.str());
        })


        // ---------------------------------------------------------
        // Default auth endpoints.
        
        this.endpoint(
            
            // Send 2fa.
            {
                method: "GET",
                endpoint: "/vweb/auth/2fa",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    
                    // Get params.
                    let email;
                    try {
                        email = request.param("email")
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Get uid.
                    let uid;
                    if ((uid = await this.get_uid_by_email(email)) == null) {
                        return response.success({
                            data: {message: "A 2FA code was sent if the specified email exists."},
                        });
                    }
                    
                    // Send.
                    await this.send_2fa({uid:uid, request:request});
                    return response.success({
                        data: {message: "A 2FA code was sent if the specified email exists."},
                    });
                    
                }
            },
        
            // Sign in.
            {
                method: "POST",
                endpoint: "/vweb/auth/signin",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {

                    // Get params.
                    let email, email_err, username, username_err, password, uid, code;
                    try {
                        email = request.param("email")
                    } catch (err) {
                        email_err = err;
                    }
                    try {
                        username = request.param("username")
                    } catch (err) {
                        username_err = err;
                    }
                    if (email_err && username_err) {
                        return response.error({status: Status.bad_request, data: {error: email_err.message}});
                    }
                    try {
                        password = request.param("password")
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Get uid.
                    if (email) {
                        if ((uid = await this.get_uid_by_email(email)) == null) {
                            return response.error({
                                status: Status.unauthorized,
                                data: {error: "Unauthorized."}
                            });
                        }
                    } else {
                        if ((uid = await this.get_uid(username)) == null) {
                            return response.error({
                                status: Status.unauthorized,
                                data: {error: "Unauthorized."}
                            });
                        }
                    }
                    
                    // Verify password.
                    if (await this.verify_password(uid, password)) {
                        
                        // Verify 2fa.
                        if (this.enable_2fa) {

                            // Get 2FA.
                            try {
                                code = request.param("2fa")
                            } catch (err) {
                                await this.send_2fa({uid:uid, request:request});
                                return response.send({
                                    status: Status.two_factor_auth_required,
                                    data: {error: "2FA required."}
                                });
                            }

                            // Verify 2FA.
                            if (await this.verify_2fa(uid, code) !== true) {
                                return response.send({
                                    status: Status.unauthorized,
                                    data: {error: "Invalid 2FA code."}
                                });
                            }
                        }
                        
                        // Sign in.
                        return await this._sign_in_response(response, uid);
                    }

                    // Unauthorized.
                    return response.send({
                        status: Status.unauthorized,
                        data: {error: "Unauthorized."}
                    });
                }
            },
        
            // Sign out.
            {
                method: "POST",
                endpoint: "/vweb/auth/signout",
                content_type: "application/json",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    
                    // Delete token.
                    this._sys_delete_user_token(request.uid);
                    
                    // Create headers.
                    this._reset_cookies(response);
                    
                    // Response.
                    return response.success({
                        data: {message: "Successfully signed out."},
                    })
                }
            },
        
            // Sign up.
            {
                method: "POST",
                endpoint: "/vweb/auth/signup",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    
                    // Get params.
                    let first_name, last_name, username, email, pass, verify_pass;
                    try {
                        username = request.param("username");
                        first_name = request.param("first_name");
                        last_name = request.param("last_name");
                        email = request.param("email");
                        pass = request.param("password");
                        verify_pass = request.param("verify_password");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Verify password.
                    if (pass != verify_pass) {
                        return response.error({
                            status: Status.bad_request,
                            data: {error: "Passwords do not match."}
                        });
                    }
                    
                    // Create.
                    let uid;
                    try {
                        uid = await this.create_user({
                            first_name: first_name,
                            last_name: last_name,
                            username: username,
                            email: email,
                            password: pass
                        });
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Send 2fa code for activation.
                    if (this.enable_account_activation) {
                        await this.send_2fa({uid:uid, request:request});
                    }
                    
                    // Sign in.
                    return await this._sign_in_response(response, uid);
                    
                }
            },
        
            // Activate account.
            {
                method: "POST",
                endpoint: "/vweb/auth/activate",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    
                    // Vars.
                    let uid = request.uid;
                    
                    // Get uid by cookie.
                    if (uid == null) {
                        const value = request.cookies["UserID"].value;
                        if (value != null && value != "-1") {
                            uid = parseInt(value);
                            if (isNaN(uid)) {
                                uid = null;
                            }
                        }
                    }
                    
                    // Check uid.
                    if (uid == null) {
                        return response.error({status: Status.forbidden, data: {error: "Permission denied."}});
                    }
                    
                    // Get param.
                    let code;
                    try {
                        code = request.param("2fa");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }

                    // Verify.
                    if (await this.verify_2fa(uid, code)) {
                        
                        // Set activated.
                        await this.set_activated(uid, true);
                        
                        // Response.
                        await this._create_user_cookie(response, uid);
                        return response.success({data: {message: "Successfully verified the 2FA code."}});
                    }
                    
                    // Invalid code.
                    else {
                        return response.error({status: Status.forbidden, data: {error: "Permission denied."}});
                    }
                }
            },
        
            // Forgot password.
            {
                method: "POST",
                endpoint: "/vweb/auth/forgot_password",
                content_type: "application/json",
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    
                    // Get params.
                    let email, code, pass, verify_pass;
                    try {
                        email = request.param("email");
                        code = request.param("2fa");
                        pass = request.param("password");
                        verify_pass = request.param("verify_password");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Verify password.
                    if (pass != verify_pass) {
                        return response.error({status: Status.bad_request, data: {error: "Passwords do not match."}});
                    }
                    
                    // Get uid.
                    let uid;
                    if ((uid = await this.get_uid_by_email(email)) == null) {
                        return response.error({status: Status.forbidden, data: {error: "Permission denied."},});
                    }
                    
                    // Verify 2fa.
                    if (await this.verify_2fa(uid, code) !== true) {
                        return response.error({status: Status.forbidden, data: {error: "Invalid 2FA code."},});
                    }
                    
                    // Set password.
                    await this.set_password(uid, pass);
                    
                    // Sign in.
                    return await this._sign_in_response(response, uid);
                }
            },
        )
        
        // ---------------------------------------------------------
        // Default user endpoints.

        this.endpoint(
        
            // Get user.
            {
                method: "GET",
                endpoint: "/vweb/user",
                content_type: "application/json",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    const user = await this.get_user(request.uid);
                    return response.success({data: user});
                }
            },

            // Set user.
            {
                method: "POST",
                endpoint: "/vweb/user",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    await this.set_user(request.uid, request.params);
                    await this._create_detailed_user_cookie(response, request.uid);
                    return response.success({data: {message: "Successfully updated your account."}});
                }
            },
        
            // Change password.
            {
                method: "POST",
                endpoint: "/vweb/user/change_password",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    
                    // Get params.
                    let current_pass, pass, verify_pass;
                    try {
                        current_pass = request.param("current_password");
                        pass = request.param("password");
                        verify_pass = request.param("verify_password");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Verify old password.
                    if (await this.verify_password(request.uid, current_pass) !== true) {
                        return response.error({
                            status: Status.unauthorized,
                            data: {error: "Incorrect password."},
                        });
                    }
                    
                    // Verify new password.
                    if (pass != verify_pass) {
                        return response.error({
                            status: Status.bad_request,
                            data: {error: "Passwords do not match."},
                        });
                    }
                    
                    // Set password.
                    await this.set_password(request.uid, pass);
                    
                    // Success.
                    return response.success({
                        status: Status.success,
                        data: {message: "Successfully updated your password."},
                    });
                }
            },
        
            // Generate api key.
            {
                method: "POST",
                endpoint: "/vweb/user/api_key",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    return response.success({
                        data: {
                            "message": "Successfully generated an API key.",
                            "api_key": await this.generate_api_key(request.uid),
                        }
                    });
                }
            },
        
            // Revoke api key.
            {
                method: "DELETE",
                endpoint: "/vweb/user/api_key",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    await this.revoke_api_key(request.uid);
                    return response.send({
                        status: Status.success,
                        data: {message: "Successfully revoked your API key."},
                    });
                }
            },
            
            // Load data.
            {
                method: "GET",
                endpoint: "/vweb/user/data",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    let path, def;
                    try {
                        path = request.param("path");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    try {
                        def = request.param("default");
                    } catch (err) {
                        def = null;
                    }
                    try {
                        return response.send({
                            status: Status.success,
                            data: await this.load_user_data(request.uid, path, def)
                        });
                    } catch (err) {
                        return response.error({status: Status.internal_server_error, data: {error: err.message}});
                    }
                }
            },
        
            // Save data.
            {
                method: "POST",
                endpoint: "/vweb/user/data",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    let path, data;
                    try {
                        path = request.param("path");
                        data = request.param("data");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    try {
                        await this.save_user_data(request.uid, path, data);
                    } catch (err) {
                        return response.error({status: Status.internal_server_error, data: {error: err.message}});
                    }
                    return response.send({
                        status: Status.success,
                        data: {message: "Successfully saved."},
                    });
                }
            },

            // Load proteced data.
            {
                method: "GET",
                endpoint: "/vweb/user/data/protected",
                authenticated: true,
                rate_limit: 100,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    let path, def;
                    try {
                        path = request.param("path");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    try {
                        def = request.param("default");
                    } catch (err) {
                        def = null;
                    }
                    try {
                        return response.send({
                            status: Status.success,
                            data: await this.load_protected_user_data(request.uid, path, def)
                        });
                    } catch (err) {
                        return response.error({status: Status.internal_server_error, data: {error: err.message}});
                    }
                }
            },
        )

        // ---------------------------------------------------------
        // Payments endpoints.
        if (this.stripe_enabled) {
            this.endpoint(
            
                // Get products.
                {
                    method: "GET",
                    endpoint: "/vweb/payments/products",
                    content_type: "application/json",
                    rate_limit: 100,
                    rate_limit_duration: 60,
                    callback: (request, response) => {
                        return response.success({data: this.payment_products});
                    }
                },

                // Get made payments.
                {
                    method: "GET",
                    endpoint: "/vweb/payments/payments",
                    content_type: "application/json",
                    authenticated: true,
                    rate_limit: 100,
                    rate_limit_duration: 60,
                    callback: async (request, response) => {
                        let status, days, limit;
                        try {
                            status = request.param("status", null, "paid");
                            days = request.param("days", "number", 30);
                            limit = request.param("limit", "number", null);
                            refunded = request.param("refunded", "boolean", null);
                        } catch (error) {
                            return response.error({status: Status.bad_request, data: {error: error.message}});
                        }
                        let payments;
                        try {
                            payments = await this.get_payments({
                                uid: request.uid,  
                                status: status,
                                days: days,
                                limit: limit,
                                refunded: refunded,
                            });
                        } catch (error) {
                            return response.error({data: {error: error.message}});
                        }
                        return response.success({data: payments});
                    }
                },

                // Get subscriptions.
                {
                    method: "GET",
                    endpoint: "/vweb/payments/subscriptions",
                    content_type: "application/json",
                    authenticated: true,
                    rate_limit: 100,
                    rate_limit_duration: 60,
                    callback: async (request, response) => {
                        let subscriptions;
                        try {
                            subscriptions = await this.get_subscriptions(request.uid);
                        } catch (error) {
                            return response.error({data: {error: error.message}});
                        }
                        return response.success({data: subscriptions});
                    }
                },

                // Is subscribed.
                {
                    method: "POST",
                    endpoint: "/vweb/payments/subscribed",
                    content_type: "application/json",
                    authenticated: true,
                    rate_limit: 100,
                    rate_limit_duration: 60,
                    callback: async (request, response) => {
                        let product;
                        try {
                            product = request.param("product");
                        } catch (error) {
                            return response.error({status: Status.bad_request, data: {error: error.message}});
                        }
                        let subscribed;
                        try {
                            subscribed = await this.is_subscribed(request.uid, product);
                        } catch (error) {
                            return response.error({data: {error: error.message}});
                        }
                        return response.success({data: {subscribed: subscribed}});
                    }
                },

                // Cancel subscription.
                {
                    method: "DELETE",
                    endpoint: "/vweb/payments/subscription",
                    content_type: "application/json",
                    authenticated: true,
                    rate_limit: 100,
                    rate_limit_duration: 60,
                    callback: async (request, response) => {
                        let product;
                        try {
                            product = request.param("product");
                        } catch (error) {
                            return response.error({status: Status.bad_request, data: {error: error.message}});
                        }
                        try {
                            await this.cancel_subscription(request.uid, product)
                        } catch (error) {
                            return response.error({data: {error: error.message}});
                        }
                        return response.success({data: {message: "Successfully cancelled your subscription."}});
                    }
                },

                // Get refundable payments.
                {
                    method: "GET",
                    endpoint: "/vweb/payments/refundable",
                    content_type: "application/json",
                    authenticated: true,
                    rate_limit: 100,
                    rate_limit_duration: 60,
                    callback: async (request, response) => {
                        let days, limit, refunded;
                        try {
                            days = request.param("days", "number", 14);
                            limit = request.param("limit", "number", null);
                            refunded = request.param("refunded", "boolean", null);
                        } catch (err) {
                            return response.error({status: Status.bad_request, data: {error: err.message}});
                        }
                        let payments;
                        try {
                            payments = await this.get_refundable_payments({uid: request.uid, days: days, refunded: refunded, limit: limit});
                        } catch (error) {
                            return response.error({data: {error: error.message}});
                        }
                        return response.success({
                            data: payments,
                        });
                    }
                },

                // Request a refund.
                {
                    method: "POST",
                    endpoint: "/vweb/payments/refund",
                    content_type: "application/json",
                    authenticated: true,
                    rate_limit: 100,
                    rate_limit_duration: 60,
                    callback: async (request, response) => {
                        let payment, auto_advance;
                        try {
                            payment = request.param("payment", "object");
                            auto_advance = request.param("auto_advance", "boolean");
                        } catch (err) {
                            return response.error({status: Status.bad_request, data: {error: err.message}});
                        }
                        let refund;
                        try {
                            refund = await this.create_refund({payment: payment, auto_advance: auto_advance});
                        } catch (error) {
                            return response.error({data: {error: error.message}});
                        }
                        return response.success({data: refund});
                    }
                },

                // Charge a shopping cart.
                {
                    method: "POST",
                    endpoint: "/vweb/payments/charge",
                    content_type: "application/json",
                    rate_limit: 100,
                    rate_limit_duration: 60,
                    callback: async (request, response) => {

                        // Get shopping cart.
                        let cart, address;
                        try {
                            cart = request.param("cart", "array");
                            address = request.param("address", "object")
                            // name = request.param("name")
                            // phone = request.param("phone")
                        } catch (err) {
                            return response.error({status: Status.bad_request, data: {error: err.message}});
                        }

                        // Create a customer or retrieve the customer id from the signed in user.
                        let cid, email, first_name, last_name;
                        if (request.uid != null) {
                            this._check_uid_within_range(request.uid);
                            cid = await this._stripe_get_cid(request.uid)
                        } else {
                            try {
                                email = request.param("email");
                                first_name = request.param("first_name");
                                last_name = request.param("last_name");
                            } catch (err) {
                                return response.error({status: Status.bad_request, data: {error: err.message}});
                            }
                            cid = await this._stripe_create_customer(email, `${first_name} ${last_name}`).id;
                        }

                        // Create a payment.
                        let client_secret;
                        try {
                            const res = await this.create_payment({uid: request.uid, cid: cid, email: email, cart: cart, address: address});
                            client_secret = res.client_secret;
                        } catch (error) {
                            return response.error({data: {error: error.message}});
                        }

                        // Response.
                        return response.success({
                            data: {
                                return_url: this.payment_return_url,
                                client_secret: client_secret,
                            }
                        })

                        /* V1 Using subscriptions and invoices.

                        // Check the shopping cart.
                        let is_subscription = null;
                        const products = [];
                        cart.iterate((item) => {
                            if (is_subscription === null) {
                                is_subscription = item.product.is_subscription;
                            }
                            else if (is_subscription != item.product.is_subscription) {
                                return response.error({
                                    status: Status.bad_request,
                                    error: "Subscription and one-time payment products can not be charged in one request.",
                                })
                            }
                            for (let i = 0; i < item.quantity; i++) {
                                products.push(item.product);
                            }
                        })

                        // Charge the shopping cart.
                        let result;
                        if (is_subscription) {
                            if (products.length > 1) {
                                throw Error("Only one subscription can be charged at the time.");
                            }
                            result = await this.create_subscription({
                                uid: request.uid,
                                cid: cid,
                                product: cart[0].product,
                            })
                        } else {
                            result = await this.create_payment({
                                uid: request.uid,
                                cid: cid,
                                products: products,
                                email: email,
                            })
                        }

                        // Handle the result.
                        if (result.error) {
                            return response.error({
                                status: Status.bad_request,
                                data: result,
                            })
                        } else {
                            return response.success({
                                data: {
                                    return_url: this.payment_return_url,
                                    ...result,
                                }
                            })
                        }

                        */
                    }
                },

                // Stripe Webhook.
                // Can be tested with cli command `stripe listen --events refund.updated,invoice.payment_action_required,invoice.payment_failed,invoice.payment_succeeded,customer.subscription.created,customer.subscription.deleted --skip-verify --forward-to localhost:8000/vweb/payments/webhook`
                {
                    method: "POST",
                    endpoint: "/vweb/payments/webhook",
                    content_type: "application/json",
                    rate_limit: 10000,
                    rate_limit_duration: 60,
                    callback: async (request, response) => {

                        // Get the event.
                        let event;
                        try {
                            event = await this.stripe.webhooks.constructEvent(
                                request.body,
                                request.headers['stripe-signature'],
                                this.stripe_webhook_key,
                            );
                        } catch (err) {
                            console.error(`Error: Webhook signature verification failed: ${err.message}`);
                            return response.error({status: Status.unauthorized, data: {error: "Webhook signature verification failed."}});
                        }

                        // Extract the object from the event.
                        const obj = event.data.object;

                        // Get the uid of the customer.
                        let uid, cid;
                        if (obj.customer) {
                            uid = this._sys_load_uid_by_stripe_cid(obj.customer);
                            cid = obj.customer;
                        }

                        console.log(event);

                        // Save the users payment method.
                        // Already handled in `create_subscription()`.
                        // if (obj['billing_reason'] === 'subscription_create') {
                        //     const payment_intent = await this.stripe.paymentIntents.retrieve(obj['payment_intent']);
                        //     await this.stripe.subscriptions.update(obj['subscription'], {default_payment_method: payment_intent.payment_method});
                        //     await this.stripe.customers.update(payment_intent.customer, {invoice_settings: {default_payment_method: payment_intent.payment_method}});
                        // };

                        // Switch the status.
                        // All event types are documented at https://stripe.com/docs/api/events/types.
                        switch (event.type) {

                            // Type: refund.updated
                            // Occurs whenever a refund from a customer’s cash balance is updated.
                            // data.object is a refund
                            case "refund.updated": {

                                // Set the status description.
                                this._stripe_parse_refund(obj)

                                // Update the invoice's line item to set the refund status for `get_products()`.
                                const metadata = {};
                                metadata[obj.metadata.invoice_item] = `${obj.id} ${obj.status} ${obj.status_description}`;
                                await this.stripe.invoices.update(obj.metadata.invoice, {
                                    metadata: metadata,
                                });

                                // Successful refund.
                                if (obj.status === "succeeded") {

                                    // Check if a mail should be sent.
                                    // When the user returns an object with {send_mail: false} then no mail will be sent.
                                    let send_mail = true;

                                    // Callback.
                                    if (this.on_refund != null) {
                                        const result = this.on_refund({
                                            uid: uid,
                                            cid: cid,
                                            invoice: obj.metadata.invoice,
                                            invoice_item: obj.metadata.invoice_item,
                                            refund: obj,
                                        });
                                        if (result instanceof Promise) {
                                            result = await result;
                                        }
                                        if (send_mail && result != null && typeof result === "object" && result.send_mail === false) {
                                            send_mail = false;
                                        }
                                    }

                                    // Send an email to the user of a successfull refund.
                                    // @todo.

                                }

                                // Failed refund.
                                else if (obj.status === "failed" || obj.status === "requires_action") {

                                    // Check if a mail should be sent.
                                    // When the user returns an object with {send_mail: false} then no mail will be sent.
                                    let send_mail = true;
                                    
                                    // Set failure reason and description.
                                    if (obj.status === "requires_action") {
                                        obj.failure_reason = "requires_action";
                                        obj.failure_description = "The refund requires user action.";
                                    }

                                    // Callback.
                                    if (this.on_refund_failed != null) {
                                        const result = this.on_refund_failed({
                                            uid: uid,
                                            cid: cid,
                                            reason: obj.failure_reason,
                                            description: obj.failure_description,
                                            requires_action: obj.status === "requires_action",
                                            invoice: obj.metadata.invoice,
                                            invoice_item: obj.metadata.invoice_item,
                                            refund: obj,
                                        });
                                        if (result instanceof Promise) {
                                            result = await result;
                                        }
                                        if (send_mail && result != null && typeof result === "object" && result.send_mail === false) {
                                            send_mail = false;
                                        }
                                    }

                                    // Send an email to the user of a failed refund telling them to contact the website.
                                    // @todo.

                                }

                                // Break.
                                break; 
                            }                           
                            

                            // Type: invoice.payment_action_required
                            // Occurs whenever an invoice payment attempt requires further user action to complete.
                            // data.object is an invoice
                            case "invoice.payment_action_required": {
                                if (this.on_payment_requires_action != null) {
                                    this.on_payment_requires_action({
                                        uid: uid,
                                        cid: cid,
                                        invoice: obj,
                                    })
                                }
                                break;
                            }

                            // Type: invoice.payment_failed
                            // Occurs whenever an invoice payment attempt fails, due either to a declined payment or to the lack of a stored payment method.
                            // data.object is an invoice
                            case "invoice.payment_failed": {
                                if (this.on_payment_failed != null) {
                                    this.on_payment_failed({
                                        uid: uid,
                                        cid: cid,
                                        invoice: obj,
                                    })
                                }
                                break;
                            }

                            // Type: invoice.payment_succeeded
                            // Occurs whenever an invoice payment attempt succeeds.
                            // data.object is an invoice
                            case "invoice.payment_succeeded": {

                                // Only the non subscription line items of the invoice need to be handled.
                                // Subscription events are catched by "customer.subscription.created".
                                
                                // Check if a mail should be sent.
                                // When the user returns an object with {send_mail: false} then no mail will be sent.
                                let send_mail = true;

                                // Iterate the line items.
                                const data = this._stripe_parse_as_list(obj.lines.data);
                                for (let i = 0; i < data.length; i++) {
                                    const item = data[i];

                                    // Skip recurring.
                                    if (item.price.type === "recurring") {
                                        continue;
                                    }

                                    // Callback.
                                    if (this.on_payment != null) {
                                        const result = this.on_payment({
                                            uid: uid,
                                            cid: cid,
                                            product: await this.get_product(item.price.product),
                                            quantity: item.quantity,
                                            address: obj.customer_address,
                                            invoice_item: item,
                                            invoice: obj,
                                        });
                                        if (result instanceof Promise) {
                                            result = await result;
                                        }
                                        if (send_mail && result != null && typeof result === "object" && result.send_mail === false) {
                                            send_mail = false;
                                        }
                                    }
                                }

                                // Send an email of the invoice pdf.
                                // @todo.

                                // Break.
                                break;
                            }

                            // Type: customer.subscription.created
                            // Occurs whenever a customer is signed up for a new plan.
                            // data.object is a subscription
                            case "customer.subscription.created": {

                                // Check if a mail should be sent.
                                // When the user returns an object with {send_mail: false} then no mail will be sent.
                                let send_mail = true;

                                // Get the line items of the subscription.
                                const data = this._stripe_parse_as_list(obj.items.data);
                                for (let i = 0; i < data.length; i++) {
                                    const item = data[i];

                                    // Skip non recurring.
                                    if (item.price.type !== "recurring") {
                                        continue;
                                    }

                                    // Get the product.
                                    const product = await this.get_product(item.price.product, true);

                                    // Active the user's subscription in the database.
                                    this._sys_add_subscription(uid, product.id, item.subscription); // the item's sub id is the same as the main object's sub id.

                                    // Cancel the other subscriptions plans that are part of this product.
                                    // The `create_payment()` function makes sure there are not multiple subscription plans of the same subscription product charged in a single request.
                                    const parent_product = await this.get_product(product.parent_id, true);
                                    for (let p = 0; p < parent_product.plans.length; p++) {
                                        const plan = parent_product.plans[p];
                                        if (plan.id != product.id) {
                                            const {exists, sub_id} = this._sys_check_subscription(uid, plan.id);
                                            if (exists) {
                                                await this._stripe_cancel_subscription(sub_id);
                                                this._sys_remove_subscription(uid, plan.id);
                                            }
                                        }
                                    }

                                    // Callback.
                                    if (this.on_susbcription_cancelled != null) {
                                        const result = this.on_susbcription({
                                            uid: uid,
                                            cid: cid,
                                            product: product,
                                            quantity: item.quantity,
                                            subscription_item: item,
                                            subscription: obj,
                                        });
                                        if (result instanceof Promise) {
                                            result = await result;
                                        }
                                        if (send_mail && result != null && typeof result === "object" && result.send_mail === false) {
                                            send_mail = false;
                                        }
                                    }
                                    
                                }

                                // Send mail of subscription confirmation.
                                // @todo

                                // Break.
                                break;
                            }

                            // Type: customer.subscription.deleted
                            // Occurs whenever a customer’s subscription ends.
                            // data.object is a subscription.
                            case "customer.subscription.deleted": {

                                // Check uid.
                                this._check_uid_within_range(uid);

                                // Check if a mail should be sent.
                                // When the user returns an object with {send_mail: false} then no mail will be sent.
                                let send_mail = true;

                                // Get the line items of the subscription.
                                const data = this._stripe_parse_as_list(obj.items.data);
                                for (let i = 0; i < data.length; i++) {
                                    const item = data[i];

                                    // Skip non recurring.
                                    if (item.price.type !== "recurring") {
                                        continue;
                                    }

                                    // Get the product.
                                    const product = await this.get_product(item.price.product, true);

                                    // Deactivate the user's subscription in the database.
                                    this._sys_remove_subscription(uid, product.id);

                                    // Callback.
                                    if (this.on_susbcription_cancelled != null) {
                                        const result = this.on_susbcription_cancelled({
                                            uid: uid,
                                            cid: cid,
                                            product: product,
                                            subscription_item: item,
                                            subscription: obj,
                                        });
                                        if (result instanceof Promise) {
                                            result = await result;
                                        }
                                        if (send_mail && result != null && typeof result === "object" && result.send_mail === false) {
                                            send_mail = false;
                                        }
                                    }
                                    
                                }

                                // Send an email of cancelled subscription.
                                // @todo.

                                // Break.
                                break;
                            }

                            // Default.
                            default: break;

                        }

                        // Send response to avoid unfinished response.
                        return response.success();
                    }
                },

            );
        }

        // Handler.
        return additional_file_watcher_paths;
    }

    // Create the sitemap endpoint.
    _create_sitemap() {
        let sitemap = "";
        sitemap += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        sitemap += "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n";
        this.endpoints.iterate((endpoint) => {
            if (
                endpoint.data == null &&
                endpoint.callback == null &&
                endpoint.endpoint != "robots.txt" &&
                !endpoint.authenticated
            ) {
                sitemap += `<url>\n   <loc>${endpoint.endpoint}</loc>\n</url>\n`;
            }
        })
        sitemap += "</urlset>\n";
        this.endpoint(new Endpoint({
            method: "GET",
            endpoint: "/sitemap.xml",
            data: sitemap,
            content_type: "application/xml",
            compress: false,
        }))
    }

    // Create the robots.txt endpoint.
    _create_robots_txt() {
        this.endpoint(new Endpoint({
            method: "GET",
            endpoint: "/robots.txt",
            content_type: "text/plain",
            data: `User-agent: *\nDisallow: \n\nSitemap: /sitemap.xml`,
            compress: false,
        }))
    }

    // ---------------------------------------------------------
    // Stripe (private).
    /* 
        Sources: 
            * https://stripe.com/docs/api/prices?lang=node
            * https://stripe.com/docs/api/subscriptions/create?lang=node
            * https://stripe.com/docs/payments/accept-a-payment?platform=web&ui=elements&client=html
            * https://stripe.com/docs/billing/subscriptions/build-subscriptions?ui=elements
     
    */

    // Parse the `data` attribute of a stripe response as a list.
    _stripe_parse_as_list(data) {
        if (Array.isArray(data) === false) {
            if (data != null && typeof data === "object") {
                data = [data];
            } else {
                data = [];
            }
        }
        return data;
    }

    // Parse the a refund object.
    _stripe_parse_refund(refund) {

        // Failure description.
        if (refund.status === "failed") {
            switch (failure_reason) {
                case "charge_for_pending_refund_disputed": 
                    refund.failure_description = "A customer disputed the charge while the refund is pending. In this case, we recommend accepting or challenging the dispute instead of refunding to avoid duplicate reimbursements to the customer.";
                    break;
                case "declined": 
                    refund.failure_description = "Refund declined by our financial partners.";
                    break;
                case "expired_or_canceled_card": 
                    refund.failure_description = "Payment method is canceled by a customer or expired by the partner.";
                    break;
                case "insufficient_funds": 
                    refund.failure_description = "Refund is pending due to insufficient funds and has crossed the pending refund expiry window.";
                    break;
                case "lost_or_stolen_card": 
                    refund.failure_description = "Refund has failed due to loss or theft of the original card.";
                    break;
                case "merchant_request": 
                    refund.failure_description = "Refund failed upon the business’s request.";
                    break;
                case "unknown": 
                default:
                    refund.failure_description = "Refund has failed due to an unknown reason.";
                    break;
            }
        }

        // Status description.
        switch (refund.status) {
            case "pending": 
                refund.status_description = "The refund request is being processed.";
                break;
            case "succeeded": 
                refund.status_description = "The payment has successfully been refunded.";
                break;
            case "failed": 
                refund.status_description = refund.failure_description;
                break;
            case "requires_action": 
                refund.status_description = "The refund request requires action.";
                break;
            case "canceled": 
                refund.status_description = "The refund request has been cancelled.";
                break;
            case "unknown": 
            default:
                refund.status_description = "Unknown status.";
                break;
        }
    }

    // Check if a uid has a stripe customer id.
    _sys_has_stripe_cid(uid) {
        return this.database.join(`.sys/stripe_uids/${uid}`, false).exists();
    }

    // Load, save or delete stripe customer id by uid.
    _sys_load_stripe_cid(uid) {
        return this.database.join(`.sys/stripe_uids/${uid}`, false).load_sync();
    }
    _sys_load_uid_by_stripe_cid(cid) {
        return this.database.join(`.sys/stripe_cids/${cid}`, false).load_sync();
    }
    _sys_save_stripe_cid(uid, cid) {
        this.database.join(`.sys/stripe_uids/${uid}`, false).save_sync(cid);
        this.database.join(`.sys/stripe_cids/${cid}`, false).save_sync(uid.toString());
    }
    _sys_delete_stripe_cid(uid, cid) {
        this.database.join(`.sys/stripe_uids/${uid}`, false).del_sync();
        this.database.join(`.sys/stripe_cids/${cid}`, false).del_sync();
    }

    // Add or remove a subscription to the user's active subscriptions.
    _sys_add_subscription(uid, prod_id, sub_id) {
        const dir = this.database.join(`.sys/stripe_subs/${uid}`, false);
        if (dir.exists() === false) {
            dir.mkdir_sync();
        }
        const path = dir.join(prod_id, false);
        path.save_sync(sub_id);
    }
    _sys_remove_subscription(uid, prod_id) {
        const dir = this.database.join(`.sys/stripe_subs/${uid}`, false);
        if (dir.exists() === false) {
            return null;
        }
        const path = dir.join(prod_id, false);
        if (path.exists() === false) {
            return null;
        }
        path.del_sync();
    }
    _sys_check_subscription(uid, prod_id, load_sub_id = true) {
        const dir = this.database.join(`.sys/stripe_subs/${uid}`, false);
        if (dir.exists() === false) {
            dir.mkdir_sync();
        }
        const path = dir.join(prod_id, false);
        let exists = true, sub_id;
        if (path.exists() === false)  {
            exists = false;
            return {exists, sub_id};
        }
        if (load_sub_id) {
            sub_id = path.load_sync();
        }
        return {exists, sub_id};
    }
    _sys_get_subscriptions(uid) {
        const dir = this.database.join(`.sys/stripe_subs/${uid}`, false);
        if (dir.exists() === false) {
            dir.mkdir_sync();
        }
        const products = [];
        dir.paths_sync((path) => {
            products.push(path.name());
        })
        return products;
    }

    // Add an open refund request to the database.
    _sys_add_open_refund(uid, id, payment) {
        const dir = this.database.join(`.sys/stripe_refunds/${uid}`, false);
        if (dir.exists() === false) {
            dir.mkdir_sync();
        }
        dir.join(id, false).save_sync(JSON.stringify(payment));
    }
    _sys_remove_open_refund(uid, id) {
        const dir = this.database.join(`.sys/stripe_refunds/${uid}`, false);
        if (dir.exists() === false) {
            return ;
        }
        const path = dir.join(id, false);
        if (path.exists()) {
            path.del_sync();
        }
    }
    _sys_get_open_refund(uid, id) {
        const dir = this.database.join(`.sys/stripe_refunds/${uid}`, false);
        if (dir.exists() === false) {
            throw Error(`User "${uid}" does not have an open refund "${id}".`)
        }
        const path = dir.join(id, false);
        if (path.exists() === false) {
            throw Error(`User "${uid}" does not have an open refund "${id}".`)
        }
        return path.load_sync({type: "object"});
    }
    _sys_get_open_refunds(uid = null) {
        const refunds = [];
        const base = this.database.join(`.sys/stripe_refunds/`, false);
        if (base.exists() === false) {
            return refunds;
        }
        if (uid == null) {
            base.paths_sync().iterate((uid_refunds) => {
                uid_refunds.paths_sync().iterate((refund) => {
                    refunds.push(refund.load_sync({type: "object"}));
                })    
            })
        } else {
            const uid_refunds = base.join(uid, false);
            if (base.exists() === false) {
                return refunds;
            }
            uid_refunds.paths_sync().iterate((refund) => {
                refunds.push(refund.load_sync({type: "object"}));
            })    
        }
        return refunds;
    }

    // Get the stripe customer id of a uid, or a create a stripe customer when the uid does not yet have a stripe customer id.
    async _stripe_get_cid(uid) {
        if (this._sys_has_stripe_cid(uid)) {
            return this._sys_load_stripe_cid(uid);
        }
        const user = await this.get_user(uid);
        const customer = await this._stripe_create_customer(user.email, `${user.first_name} ${user.last_name}`);
        this._sys_save_stripe_cid(uid, customer.id);
        return customer.id;
    }

    // Create a stripe customer without any user attached.
    async _stripe_create_customer(email, full_name) {
        try {
            return await this.stripe.customers.create({
                email: email,
                name: full_name,
            });
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Delete a stripe customer.
    async _stripe_delete_customer(uid) {
        if (this._sys_has_stripe_cid(uid)) {
            let result;
            const cid = this._sys_load_stripe_cid(uid);
            try {
                result = await this.stripe.customers.del(cid);
            } catch (error) {
                throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
            }
            if (result.deleted !== true) {
                throw Error(`Failed to delete the stripe customer object for user "${uid}".`);
            }
            this._sys_delete_stripe_cid(uid, cid);
        }
    }

    // Update the name and email address of a stripe customer.
    async _stripe_update_customer(uid, user) {
        if (this._sys_has_stripe_cid(uid)) {
            const cid = this._sys_load_stripe_cid(uid);
            try {
                await this.stripe.customers.update(
                    cid, 
                    {
                        email: user.email,
                        name: `${user.first_name} ${user.last_name}`,
                    }
                );
            } catch (error) {
                throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
            }
        }
    }

    // Get a price.
    async _stripe_get_price(price_id) {
        try {
            return await this.stripe.prices.retrieve(price_id);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Deactivate a price.
    // Prices cant be correctly updated with recurring or prices so when a product price has been edited a new price object should be created.
    // @note: When a price is deactivated all subscriptions linked to this price will automatically be cancelled.
    async _stripe_deactivate_price(price_id) {
        await this._stripe_cancel_all_subscriptions(price_id)
        try {
            return await this.stripe.prices.update(price_id, {
                active: false,
            });
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Create a price for a product.
    async _stripe_create_price(product) {
        try {
            const result = await this.stripe.prices.create({
                currency: product.currency,
                unit_amount_decimal: parseInt(product.price * 100),
                tax_behavior: product.tax_behavior,
                recurring: product.is_subscription ? {
                    interval: product.interval,
                    interval_count: product.interval_count,
                } : undefined,
                product: product.id,
            });
            product.price_id = result.id;
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Get a product by stripe subscription id.
    async _stripe_get_product(product_id) {
        try {
            return await this.stripe.products.retrieve(product_id);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Get all products.
    async _stripe_get_products() {
        try {
            const result = await this.stripe.products.list();
            return this._stripe_parse_as_list(result.data);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Create a product.
    async _stripe_create_product(product) {
        try {
            const result = await this.stripe.products.create({
                id: product.id,
                name: product.name,
                description: product.description,
                statement_descriptor: product.statement_descriptor,
                tax_code: product.tax_code,
                default_price_data: {
                    currency: product.currency,
                    unit_amount_decimal: parseInt(product.price * 100),
                    tax_behavior: product.tax_behavior,
                    recurring: product.is_subscription ? {
                        interval: product.interval,
                        interval_count: product.interval_count,
                    } : undefined,
                },
            });
            product.price_id = result.default_price;
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Update a product.
    // @warning: When the second argument "stripe_product" is undefined, then this function will assume the stripe product does not exist and a new product will be created.
    async _stripe_update_product(product, stripe_product) {

        // When the stripe product does not yet exist.
        if (stripe_product == null) {
            await this._stripe_create_product(product);
        }

        // When the stripe product already exists.
        else {

            // Vars.
            let stripe_price;
            const has_no_price = stripe_product.default_price == null;
            let update_price = false;

            // Check if the price object should be updated.
            if (has_no_price === false) {
                update_price = await (async () => {

                    // Fetch the price object.
                    stripe_price = await this._stripe_get_price(stripe_product.default_price);

                    // Not active.
                    if (stripe_price.active !== true)  {
                        return true;
                    }

                    // Changed price.
                    if (parseFloat(stripe_price.unit_amount_decimal) / 100 !== product.price) {
                        return true;
                    }

                    // Changed currency.
                    if (stripe_price.currency !== product.currency) {
                        return true;
                    }

                    // Changed recurring status.
                    if (
                        (stripe_price.type === "recurring" && !product.is_subscription) ||
                        (stripe_price.type !== "recurring" && product.is_subscription)
                    ) {
                        return true;
                    }

                    // Changed tax behavior.
                    if (stripe_price.tax_behavior !== product.tax_behavior) {
                        return true;
                    }

                    // Changed recurring interval.
                    if (product.is_subscription && (product.interval_count !== stripe_price.recurring.interval_count || product.interval !== stripe_price.recurring.interval)) {
                        return true;
                    }

                    // Should not be updated.
                    return false;

                })();

            }

            // Create a price object.
            if (has_no_price) {
                await this._stripe_create_price(product); // automatically assigns the price id.
            }

            // Update the price object.
            else if (update_price) {
                try {
                    await this.stripe.products.update(product.id, {
                        default_price: null,
                    });
                } catch (error) {
                    throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
                }
                await this._stripe_deactivate_price(stripe_price.id);
                await this._stripe_create_price(product); // automatically assigns the price id.
            }

            // Set price id.
            else {
                product.price_id = stripe_price.id;
            }

            // Check if the name or description has changed.
            if (
                has_no_price ||
                update_price ||
                (stripe_product.name !== product.name) ||
                (stripe_product.description !== product.description) ||
                (product.statement_descriptor != null && stripe_product.statement_descriptor !== product.statement_descriptor) ||
                (product.icon != null && (stripe_product.images.length === 0 || stripe_product.images[0] !== product.icon)) ||
                (product.tax_code != stripe_product.tax_code)
            ) {
                try {
                    await this.stripe.products.update(product.id, {
                        // id: product.id,
                        name: product.name,
                        description: product.description,
                        statement_descriptor: product.statement_descriptor,
                        default_price: product.price_id,
                        tax_code: product.tax_code,
                        images: [product.icon],
                        active: true, // to prevent nasty bug then the user had it disabled.
                    });
                } catch (error) {
                    throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
                }
            }

        }
    }

    // Deactivate a product.
    // When the product is a subscription all active subscriptions will be cancelled.
    async _stripe_deactivate_product(stripe_product) {

        // Deactivate the price object.
        // Also cancels all the active subscriptions.
        if (stripe_product.default_price != null) {
            try {
                await this.stripe.products.update(stripe_product.id, {
                    default_price: null,
                });
            } catch (error) {
                throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
            }
            await this._stripe_deactivate_price(stripe_product.default_price);
        }

        // Delete the product.
        try {
            await this.stripe.products.update(stripe_product.id, {
                active: false,
            });
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Get a subscription by stripe subscription id.
    async _stripe_get_subscription(sub_id) {
        try {
            return await this.stripe.products.retrieve(sub_id);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Cancel all subscriptions for a price id.
    async _stripe_cancel_subscription(sub_id) {
        try {
            await this.stripe.subscriptions.cancel(sub_id);
        } catch (error) {
            console.error(new StripeError(error.message))
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Cancel all subscriptions for a price id.
    async _stripe_cancel_all_subscriptions(price_id) {
        const price = await this._stripe_get_price(price_id);
        // console.error("Cancel subscriptions:", price_id, price);
        if (price.type === "recurring") {
            let data;
            try {
                const result = await this.stripe.subscriptions.list({
                    price: price_id,
                })
                data = this._stripe_parse_as_list(result.data);
            } catch (error) {
                throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
            }
            await data.iterate_async_await(async (subscription) => {
                const items = subscription.items;
                if (subscription.status === "active" || subscription.status === "trialing") {
                    await this.stripe.subscriptions.cancel(subscription.id);
                }
            })
        }
    }

    // Initialize the payment products.
    async _initialize_products() {

        // Fetch all current stripe products.
        const stripe_products = await this._stripe_get_products();

        // Check a payment product / plan product.
        const product_ids = [];
        let product_index = 0;
        const check_product = (product) => {
            ++product_index;

            // Check if the product has an id.
            if (product.id == null || product.id === "") {
                throw Error(`Product ${product_index} does not have an assigned "id" attribute (string).`);
            }
            else if (product_ids.includes(product.id)) {
                throw Error(`Product ${product_index} has a non unique id "${product.id}".`);
            }
            for (let i = 0; i < product.id.length; i++) {
                if ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_".indexOf(product.id.charAt(i)) === -1) {
                    throw Error(`Invalid product id "${product.id}", product id's may only contain lowercase characters, uppercase characters, digits and an underscore character ("_").`);
                }
            }
            product_ids.push(product.id);

            // Set the icon absolute url.
            if (typeof product.icon === "string" && product.icon.charAt(0) === "/") {
                product.icon = `http${this.https === undefined ? "" : "s"}://${this.domain}${product.icon}`;
            }

            // Check attributes.
            if (typeof product.name !== "string" || product.name === "") {
                throw Error(`Product "${product.id}" does not have an assigned "name" attribute (string).`);
            }
            if (typeof product.description !== "string" || product.description === "") {
                throw Error(`Product "${product.id}" does not have an assigned "description" attribute (string).`);
            }
            if (typeof product.currency !== "string" || product.currency === "") {
                throw Error(`Product "${product.id}" does not have an assigned "currency" attribute (string).`);
            }
            if (typeof product.price !== "number") {
                throw Error(`Product "${product.id}" does not have an assigned "price" attribute (number).`);
            }
            if (product.is_subscription && product.interval == null) {
                throw Error(`Product "${product.id}" does not have an assigned "interval" attribute (string).`);   
            }
            if (product.is_subscription && product.interval_count == null) {
                product.interval_count = 1;
            }
            if (product.interval_count != null && typeof product.interval_count !== "number") {
                throw Error(`Product "${product.id}" has an incorrect value type for attribute "interval_count", the valid type is "number".`);
            }
            if (product.interval != null && product.interval !== "day" && product.interval !== "week" && product.interval !== "month" && product.interval !== "year") {
                throw Error(`Product "${product.id}" has an incorrect "interval" attribute, the interval string should be "day", "week", "month" or "year" not "${product.interval}".`);
            }
            if (product.statement_descriptor != null && typeof product.statement_descriptor !== "string") {
                throw Error(`Product "${product.id}" has an incorrect value type for attribute "statement_descriptor", the valid type is "string" (max 22 characters).`);
            }
            if (product.statement_descriptor != null && product.statement_descriptor.length > 22) {
                throw Error(`Product "${product.id}" has a too long string value for attribute "statement_descriptor" (max 22 characters).`);
            }
        }

        // Expand the payment products.
        let sub_products = 0;
        this.payment_products.iterate((product) => {
            if (product.plans != null) {

                // Check plans.
                if (product.plans != null && Array.isArray(product.plans) === false) {
                    throw Error(`Product "${product_index}" has an incorrect value type for attribute "plans", the valid type is "array".`);
                }

                // Generate sub id.
                product.id = `sub_${sub_products}`
                if (product_ids.includes(product.id)) {
                    throw Error(`Another product has a reserved id "${product.id}".`);
                }
                product_ids.push(product.id);
                ++sub_products;

                // Attributes.
                product.is_subscription = true;

                // Expand plan attributes.
                product.plans.iterate((plan) => {
                    plan.is_subscription = true;
                    plan.parent_id = product.id;
                    if (plan.name == null ) { plan.name = product.name; }
                    if (plan.description == null ) { plan.description = product.description; }
                    if (plan.currency == null ) { plan.currency = product.currency; }
                    if (plan.interval == null ) { plan.interval = product.interval; }
                    if (plan.interval_count == null ) { plan.interval_count = product.interval_count; }
                    if (plan.statement_descriptor == null ) { plan.statement_descriptor = product.statement_descriptor; }
                    if (plan.icon == null ) { plan.icon = product.icon; }
                    if (plan.tax_behavior == null ) { plan.tax_behavior = product.tax_behavior; }
                    if (plan.tax_code == null ) { plan.tax_code = product.tax_code; }
                    check_product(plan);
                })
            } else {
                product.is_subscription = false;
                check_product(product);
            }
        })

        // When the products are the same only retrieve the price id's of the products.
        // Since deactivating the old prices may take some time which is not good for the filewatcher.
        const last_checked_products = this.database.join(".sys/.last_checked_products", false);
        let null_default_price = false;
        if (last_checked_products.exists() && last_checked_products.load_sync() === JSON.stringify(this.payment_products)) {
            await this.payment_products.iterate_async_await(async (product) => {
                const set_price_id = (product) => {
                    const found = stripe_products.iterate((item) => {
                        if (item.id == product.id && item.active) {
                            product.price_id = item.default_price;
                            if (null_default_price === false && product.price_id == null) {
                                null_default_price = true;
                            }
                            return true;
                        }
                    })
                    if (found !== true) {
                        null_default_price = true;
                    }
                }
                if (product.is_subscription) {
                    product.plans.iterate(set_price_id);
                } else {
                    set_price_id(product);
                }
            });
            if (null_default_price === false) {
                return null;
            }
        }

        // Copy last checked products without the price id's.
        const copy = (value) => {
            if (Array.isArray(value)) {
                let copied = [];
                value.iterate((v) => {
                    copied.push(copy(v));
                })
                return copied;
            } else if (value != null && typeof value === "object") {
                let copied = {};
                Object.keys(value).iterate((k) => {
                    if (k !== "price_id") {
                        copied[k] = copy(value[k]);
                    }
                })
                return copied;
            } else {
                return value;
            }
        }
        const last_checked = copy(this.payment_products);

        // Delete all stripe products that are not part of the payment products.
        await stripe_products.iterate_async_await((stripe_product) => {
            const found = this.payment_products.iterate((product) => {
                if (product.is_subscription) {
                    return product.plans.iterate((plan) => {
                        if (plan.id === stripe_product.id) {
                            return true;  
                        }
                    })
                } else if (product.id === stripe_product.id) {
                    return true;
                }
            })
            if (found !== true) {
                return this._stripe_deactivate_product(stripe_product);
            }
        })

        // Iterate the payment products.
        await this.payment_products.iterate_async_await(async (product) => {
            const check_product = async (product) => {

                // Check if the stripe product exists.
                let stripe_product;
                stripe_products.iterate((x) => {
                    if (x.id === product.id) {
                        stripe_product = x;
                        return false;
                    }
                })

                // Update the stripe product when required.
                await this._stripe_update_product(product, stripe_product);
            }

            // Check plans or one-time product.
            if (product.is_subscription) {
                await product.plans.iterate_async_await(check_product);
            } else {
                await check_product(product);
            }
        })

        // Save last checked products.
        last_checked_products.save_sync(JSON.stringify(last_checked));
    }

    // ---------------------------------------------------------
    // Server (private).

    // Initialize.
    async _initialize() {

        // Check & create database.
        if (this.database.exists()) {
            this.database.mkdir_sync();
        }
        [
            ".sys",
            ".sys/users",
            ".sys/tokens",
            ".sys/usernames",
            ".sys/emails",
            ".sys/keys",
            ".sys/unactivated",
            ".sys/2fa",
            ".sys/stripe_uids",
            ".sys/stripe_cids",
            ".sys/stripe_subs",
            ".sys/stripe_refunds",
            "users",
        ].iterate((subpath) => {
            this.database.join(subpath).mkdir_sync();
        })
        
        // Load keys.
        const path = this.database.join(".sys/keys/keys");
        if (!path.exists()) {
            this.hash_key = this._sys_generate_crypto_key(32);
            path.save_sync(JSON.stringify({
                sha256: this.hash_key,
            }));
        } else {
            const data = JSON.parse(path.load_sync());
            this.hash_key = data["sha256"];
            if (this.hash_key === undefined) {
                this.hash_key = this._sys_generate_crypto_key(32);
                data["sha256"] = this.hash_key;
                path.save_sync(JSON.stringify(data));
            }
        }
        
        // Get max user id.
        this.max_uid = 0;
        await this._iter_db_dir(".sys/users", (path) => {
            const uid = parseInt(path.name());
            if (uid > this.max_uid) {
                this.max_uid = uid;
            }
        });

        // Create default endpoints.
        this._create_default_endpoints();

        // Create static endpoints.
        this.statics.iterate((path) => {
            this._create_static_endpoints(path.base(), path);
        });
        
        // Create sitemap when it does not exist.
        if (this._find_endpoint("sitemap.xml") == null) {
            this._create_sitemap();
        }
        
        // Create robots.txt when it does not exist.
        if (this._find_endpoint("robots.txt") == null) {
            this._create_robots_txt();
        }

        // Set the caching of all endpoints.
        this.endpoints.iterate((endpoint) => {
            if (endpoint.callback === null) {
                if (this.production && endpoint.cache == null) {
                    endpoint.cache = 3600 * 24;
                } else if (!this.production) {
                    endpoint.cache = null;
                }
            }
        })
        
        // Stripe.
        if (this.stripe_enabled) {

            // Initialize products.
            await this._initialize_products()

            // Create the webohok.
            const url = `https://${this.domain}/vweb/payments/webhook`;
            const enabled_events = [
                "refund.updated",
                "invoice.payment_action_required",
                "invoice.payment_failed",
                "invoice.payment_succeeded",
                "customer.subscription.created",
                "customer.subscription.deleted",
            ];
            const result = await this.stripe.webhookEndpoints.list();
            const webhooks = this._stripe_parse_as_list(result.data);
            let secret = await webhooks.iterate_async_await(async (webhook) => {
                if (webhook.url === url) {
                    if (enabled_events.eq(webhook.enabled_events)) {
                        return this.database.join(".sys/keys/stripe_webhook_key", false).load_sync();
                    } else {
                        await this.stripe.webhookEndpoints.update(
                            webhook.id, 
                            {enabled_events: enabled_events}
                        );
                        return this.database.join(".sys/keys/stripe_webhook_key", false).load_sync();
                    }
                }
            })
            if (secret === null) {
                const result = await this.stripe.webhookEndpoints.create({
                    url: url,
                    enabled_events: enabled_events,
                });
                secret = result.secret;
                this.database.join(".sys/keys/stripe_webhook_key", false).save_sync(secret);
            }
            if (this.stripe_webhook_key == null) {
                this.stripe_webhook_key = secret;
            }
        }
    }

    // Serve a client.
    // @todo implement rate limiting.
    async _serve(request, response) {
        return new Promise(async (resolve) => {

            // Log endpoint result.
            const log_endpoint_result = (message = null, status = null) => {
                // console.log(`${Date.now()} ${method} ${endpoint_url}: ${message === null ? response.status_message : message} [${status === null ? response.status_code : status}].`);
            }

            // Initialize the request and wait till all the data has come in.
            request = new Request(request);
            await request.promise;

            // Parse the request parameters.
            try {
                request._parse_params();
            } catch (err) {
                response.send({
                    status: 400, 
                    headers: {"Content-Type": "text/plain"},
                    data: `Bad Request - ${err}`,
                });
                log_endpoint_result();
                return resolve();
            }

            // Initialize the response.
            response = new Response(response);

            // Set default headers.
            this._set_header_defaults(response);

            // Check if the request matches any of the defined endpoints
            const method = request.method;
            const endpoint_url = request.endpoint;
            const endpoint = this.endpoints.find((endpoint) => {
                return endpoint.method === method && endpoint.endpoint === endpoint_url;
            });

            // No endpoint found.
            if (!endpoint) {
                response.send({
                    status: 404, 
                    headers: {"Content-Type": "text/plain"},
                    data: "Not Found",
                });
                log_endpoint_result();
                return resolve();
            }

            // Check rate limiting.
            // @todo.

            // Always perform authentication so the request.uid will also be assigned even when the endpoint is not authenticated.
            const auth_result = await this._authenticate(request);

            // Reset cookies when authentication has failed, so the UserID cookies etc will be reset.
            if (auth_result !== null) {
                this._reset_cookies(response);
            }

            // When the endpoint is authenticated and the authentication has failed then send the error response.
            if (auth_result !== null && endpoint.authenticated) {
                response.send(auth_result);
                log_endpoint_result();
                return resolve();
            }

            // Serve endpoint.
            try {
                await endpoint._serve(request, response);
            } catch (err) {
                console.error(err);
                response.send({
                    status: 500, 
                    headers: {"Content-Type": "text/plain"},
                    data: "Internal Server Error",
                });
                log_endpoint_result();
                return resolve();
            }

            // Check if the response has been sent.
            if (!response.finished) {
                console.error(`${Date.now()} ${method} ${endpoint_url}: Unfinished response.`);
                response.send({
                    status: 500, 
                    headers: {"Content-Type": "text/plain"},
                    data: "Internal Server Error",
                });
                log_endpoint_result();
                return resolve();
            }

            // Log.
            log_endpoint_result();
            return resolve();
        })
    }

    // ---------------------------------------------------------
    // Server.

    // Start the server.
	/*  @docs {
     *  @title: Start
     *  @description:
     *      Start the server.
     *  @usage:
     *      ...
     *      server.start();
     } */
    async start() {

        // Inside file watcher process.
        if (this.https === undefined && this.http === undefined) {
            return null;
        }

        // Initialize.
        await this._initialize();

        // Set default port.
        let http_port, https_port
        if (this.port == null) {
            http_port = 80;
            https_port = 443;
        } else {
            http_port = this.port;
            https_port = this.port + 1;
        }

        // Callbacks.
        let is_running = false;
        const on_running = () => {
            if (!is_running) {
                is_running = true;
                if (this.https !== undefined) {
                    console.log(`Running on http://${this.ip}:${http_port} and https://${this.ip}:${https_port}.`); // @warning if you change this running on text you should update vide::BuildSystem since that depends on this log line.
                } else {
                    console.log(`Running on http://${this.ip}:${http_port}.`); // @warning if you change this running on text you should update vide::BuildSystem since that depends on this log line.
                }
            }
        }
        const on_error = (error) => {
            if (error.syscall !== 'listen') {
                throw error; // This is a system error, not related to server listening
            }
            switch (error.code) {
                case 'EACCES':
                    console.error(`Error: Address ${this.ip}:${this.port} requires elevated privileges.`);
                    process.exit(1);
                    break;
                case 'EADDRINUSE':
                    console.error(`Error: Address ${this.ip}:${this.port} is already in use.`);
                    process.exit(1);
                    break;
                default:
                    throw error;
            }
        }

        // Listen.
        this.http.listen(http_port, this.ip, on_running);
        this.http.on("error", on_error);
        if (this.https !== undefined) {
            this.https.listen(https_port, this.ip, on_running);
            this.https.on("error", on_error);
        }

        // Set signals.
        process.on('SIGTERM', () => process.exit(0)); // the "this.https.close()" handler does not always get executed when run from vide build system, so use "process.exit()" instead.
        process.on('SIGINT', () => process.exit(0));
    }

    // Stop the server and exit the program.
	/*  @docs {
     *  @title: Stop
     *  @description:
     *      Stop the server and exit the program by default.
     *  @parameter: {
     *      @name: exit
     *      @description: A boolean indicating whether the program should exit after stopping the server.
     *      @type: boolean
     *  }
     *  @usage:
     *      ...
     *      server.stop();
     } */
    stop(exit = true) {
        if (this.https === undefined && this.http === undefined) {
            return null; // inside file watcher process.
        }
        if (this.https !== undefined) {
            this.https.close((code) => { 
				if (exit) {
                	process.exit(0);
				}
            });
        }
        this.http.close((code) => { 
			if (exit) {
            	process.exit(0);
			}
        });
    }

    // ---------------------------------------------------------
    // Endpoints.

    // Add one or multiple endpoints.
    /*  @docs: {
        @title: Add endpoint(s)
        @description: Add one or multiple endpoints.
        @parameter: {
            @name: ...endpoints
            @description:
                The endpoint parameters.

                An endpoint parameter can either be a `Endpoint` class or an `object` with the `Endpoint` arguments.
            @type: Endpoint, object
        }
        } */
    endpoint(...endpoints) {
        for (let i = 0; i < endpoints.length; i++) {
            const endpoint = endpoints[i];
            if (endpoint instanceof Endpoint) {
                this.endpoints.push(endpoint);
            } else {
                this.endpoints.push(new Endpoint(endpoint));
            }
        }
        return this;
    }

    // ---------------------------------------------------------
    // Users.
    
    // Check if a username exists.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Username Exists
     *  @description: Check if a username exists.
	 *  @type: boolean
     *  @return: Returns a boolean indicating whether the username exists or not.
     *  @parameter: {
     *      @name: username
     *      @description: The username to check.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const exists = await server.username_exists("someusername");
     } */
    async username_exists(username) {
        return this.database.join(`.sys/usernames/${username}`, false).exists();
    }
    
    // Check if an email exists.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Email Exists
     *  @description: Check if a email exists.
	 *  @type: boolean
     *  @return: Returns a boolean indicating whether the email exists or not.
     *  @parameter: {
     *      @name: email
     *      @description: The email to check.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const exists = await server.email_exists("some\@email.com");
     } */
    async email_exists(email) {
        return this.database.join(`.sys/emails/${email}`, false).exists();
    }
    
    // Check if a user account is activated.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Is Activated
     *  @description: Check if a user account is activated.
     *  @return: Returns a boolean indicating whether the account is activated or not.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to check.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      const activated = await server.is_activated(0);
     } */
    async is_activated(uid) {
        return !this.database.join(`.sys/unactivated/${uid}`, false).exists();
    }
    
    // Set the activated status of a user account is activated.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Set Activated
     *  @description: Set the activated status of a user account is activated.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: activated
     *      @description: The boolean with the new activated status.
     *      @type: boolean
     *  }
     *  @usage:
     *      ...
     *      await server.set_activated(0, true);
     } */
    async set_activated(uid, activated) {
        const path = this.database.join(`.sys/unactivated/${uid}`, false);
        if (activated == true) {
            path.del_sync();
        } else {
            path.save_sync("");
        }
    }
    
    // Create user.
    /*  @docs {
     *  @title: Create User
     *  @description: Create a user account.
     *  @return: Returns the uid of the newly created user.
     *  @parameter: {
     *      @name: first_name
     *      @description: The user's first name.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: last_name
     *      @description: The user's last name.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: username
     *      @description: The username of the new account.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: email
     *      @description: The email of the new account.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: password
     *      @description: The password of the new account.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const uid = await server.create_user({
     *          first_name: "John", 
     *          last_name: "Doe", 
     *          username: "johndoe", 
     *          email: "johndoe\@email.com",
     *          password: "HelloWorld!"
     *      });
     } */
    async create_user({
        first_name,
        last_name,
        username,
        email,
        password
    }) {
        
        // Check if username & email already exist.
        if (await this.username_exists(username)) {
            throw Error(`Username "${username}" already exists.`);
        }
        if (await this.email_exists(email)) {
            throw Error(`Email "${email}" already exists.`);
        }
        
        // Get new uid.
        // @todo check for deleted uids.
        await this.edit_max_uid_mutex.lock();
        ++this.max_uid;
        const uid = this.max_uid;
        this.edit_max_uid_mutex.unlock();
        
        // Save sys data.
        this._sys_save_user(uid, {
            first_name: first_name,
            last_name: last_name,
            username: username,
            email: email,
            password: this._hmac(password),
            api_key: "",
        });
        this._sys_save_uid_by_username(uid, username);
        this._sys_save_uid_by_email(uid, email);
        if (this.enable_account_activation) {
            await this.set_activated(uid, false);
        }
        
        // Create user dir.
        this.database.join(`/users/${uid}/`).mkdir_sync();
        this.database.join(`/users/${uid}/private`).mkdir_sync();
        this.database.join(`/users/${uid}/protected`).mkdir_sync();
        this.database.join(`/users/${uid}/public`).mkdir_sync();
        
        // Return uid.
        return uid;
    }
    
    // Delete user.
    // The file paths should never be deleted.
    /*  @docs {
     *  @title: Delete User
     *  @description: Delete a user account.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id of the account to delete.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      await server.delete_user(0);
     } */
    async delete_user(uid) {
        this._check_uid_within_range(uid);
        this._sys_delete_user(uid);
        await this._stripe_delete_customer();
        this.database.join(`users/${uid}`, false).del_sync();
    }
    
    // Set a user's first name.
    /*  @docs {
     *  @title: Set First Name
     *  @description:
     *      Set a user's first name
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: first_name
     *      @description: The new first name.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      await server.set_first_name(0, "John");
     } */
    async set_first_name(uid, first_name) {
        const user = await this.get_user(uid);
        user.first_name = first_name;
        this._sys_save_user(uid, user);
        await this._stripe_update_customer(uid, user);
    }
    
    // Set a user's last name.
    /*  @docs {
     *  @title: Set Last Name
     *  @description:
     *      Set a user's last name
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: last_name
     *      @description: The new last name.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      await server.set_last_name(0, "Doe");
     } */
    async set_last_name(uid, last_name) {
        const user = await this.get_user(uid);
        user.last_name = last_name;
        this._sys_save_user(uid, user);
        await this._stripe_update_customer(uid, user);
    }
    
    // Set a user's username.
    /*  @docs {
     *  @title: Set Username
     *  @description:
     *      Set a user's username
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: username
     *      @description: The new username.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      await server.set_username(0, "newusername");
     } */
    async set_username(uid, username) {
        if (await this.username_exists(username)) {
            throw Error(`Username "${username}" already exists.`);
        }
        const user = await this.get_user(uid);
        user.username = username;
        this._sys_save_user(uid, user);
        this._sys_save_uid_by_username(uid, username);
    }
    
    // Set a user's email.
    /*  @docs {
     *  @title: Set Email
     *  @description:
     *      Set a user's email
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: email
     *      @description: The new email.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      await server.set_email(0, "new\@email.com");
     } */
    async set_email(uid, email) {
        if (await this.email_exists(email)) {
            throw Error(`Email "${email}" already exists.`);
        }
        const user = await this.get_user(uid);
        user.email = email;
        this._sys_save_user(uid, user);
        this._sys_save_uid_by_email(uid, email);
        await this._stripe_update_customer(uid, user);
    }
    
    // Set a user's password.
    /*  @docs {
     *  @title: Set Password
     *  @description:
     *      Set a user's password
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: password
     *      @description: The new password.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      await server.set_password(0, "XXXXXX");
     } */
    async set_password(uid, password) {
        const user = await this.get_user(uid);
        user.password = this._hmac(password);
        this._sys_save_user(uid, user);
    }
    
    // Set a user's data.
    /*  @docs {
     *  @title: Set user
     *  @description:
     *      Set a user's data
     *
     *      When a key does not exist in the new user object it will not be set.
     *
     *      Does not update the user's id, key and password data.
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: user
     *      @description: The new user object.
     *      @type: object
     *  }
     *  @usage:
     *      ...
     *      await server.set_user(0, {first_name: "John", last_name: "Doe"});
     } */
    async set_user(uid, user) {
        const current_user = await this.get_user(uid);
        let old_username = null, old_email = null;
        let stripe_update_required = false;
        
        // First name.
        if (user.first_name != null && user.first_name != current_user.first_name) {
            current_user.first_name = user.first_name;
            stripe_update_required = true;
        }
        
        // Last name.
        if (user.last_name != null && user.last_name != current_user.last_name) {
            current_user.last_name = user.last_name;
            stripe_update_required = true;
        }
        
        // Username.
        if (user.username != null && user.username != current_user.username) {
            if (await this.username_exists(user.username)) {
                throw Error(`Username "${user.username}" already exists.`);
            }
            old_username = current_user.username;
            current_user.username = user.username;
        }
        
        // Email.
        if (user.email != null && user.email != current_user.email) {
            if (await this.email_exists(user.email)) {
                throw Error(`Email "${user.email}" already exists.`);
            }
            old_email = current_user.email;
            current_user.email = user.email;
            stripe_update_required = true;
        }
        
        // Save.
        this._sys_save_user(uid, current_user);
        if (old_username !== null) {
            this._sys_save_uid_by_username(uid, current_user.username);
            this._sys_delete_uid_by_username(uid, old_username);
        }
        if (old_email !== null) {
            this._sys_save_uid_by_email(uid, current_user.email);
            this._sys_delete_uid_by_email(uid, old_email);
        }

        // Update stripe customer.
        if (stripe_update_required) {
            await this._stripe_update_customer(uid, user);
        }
        
    }
    
    // Get uid by username.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Get UID
     *  @description: Get a uid by username.
     *  @return:
     *      Returns the uid of the username.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: username
     *      @description: The username of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = await server.get_uid("myusername")) !== null) { ... }
     } */
    async get_uid(username) {
        if (username == null || username === "") {
            return null;
        }
        const path = this.database.join(`.sys/usernames/${username}`, false);
        if (path.exists()) {
            const uid = parseInt(path.load_sync());
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by email.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Get UID By Email
     *  @description: Get a uid by email.
     *  @return:
     *      Returns the uid of the email.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: email
     *      @description: The email of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = await server.get_uid_by_email("my\@email.com")) !== null) { ... }
     } */
    async get_uid_by_email(email) {
        if (email == null || email === "") {
            return null;
        }
        const path = this.database.join(`.sys/emails/${email}`, false);
        if (path.exists()) {
            const uid = parseInt(path.load_sync());
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by api key.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Get UID By API Key
     *  @description: Get a uid by API key.
     *  @return:
     *      Returns the uid of the api key.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: api_key
     *      @description: The API key of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = await server.get_uid_by_api_key("XXXXXXXXXX")) !== null) { ... }
     } */
    async get_uid_by_api_key(api_key) {
        let pos;
        if ((pos = api_key.indexOf(':')) != -1) {
            const uid = parseInt(api_key.substr(1, pos - 1));
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by token.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Get UID By Token
     *  @description: Get a uid by token.
     *  @return:
     *      Returns the uid of the token.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: token
     *      @description: The token of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = await server.get_uid_by_token("XXXXXXXXXX")) !== null) { ... }
     } */
    async get_uid_by_token(token) {
        return await this.get_uid_by_api_key(token);
    }
    
    // Get user info by uid.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Get User
     *  @description:
     *      Get a user by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user to fetch.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      const user = await server.get_user(0);
     } */
    async get_user(uid) {
        this._check_uid_within_range(uid);
        return this._sys_load_user(uid);
    }
    
    // Get user info by username.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Get User By Username
     *  @description:
     *      Get a user by username.
     *
     *      If the username does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: username
     *      @description: The username of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = await server.get_user_by_username("myusername");
     } */
    async get_user_by_username(username) {
        const uid = await this.get_uid(username);
        if (uid === null) {
            throw Error(`No user with username "${username}" exists.`);
        }
        return await this.get_user(uid);
    }
    
    // Get user info by email.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Get User By Email
     *  @description:
     *      Get a user by email.
     *
     *      If the email does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: email
     *      @description: The email of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = await server.get_user_by_email("my\@email.com");
     } */
    async get_user_by_email(email) {
        const uid = await this.get_uid_by_email(email);
        if (uid === null) {
            throw Error(`No user with email "${email}" exists.`);
        }
        return await this.get_user(uid);
    }
    
    // Get user info by api key.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Get User By API Key
     *  @description:
     *      Get a user by API key.
     *
     *      If the API key does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: api_key
     *      @description: The API key of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = await server.get_user_by_api_key("XXXXXX");
     } */
    async get_user_by_api_key(api_key) {
        const uid = await this.get_uid_by_api_key(api_key);
        if (uid === null) {
            throw Error(`No user with api key "${api_key}" exists.`);
        }
        return await this.get_user(uid);
    }
    
    // Get user info by token.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Get User By Token
     *  @description:
     *      Get a user by token.
     *
     *      If the token does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: token
     *      @description: The token of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = await server.get_user_by_token("XXXXXX");
     } */
    async get_user_by_token(token) {
        const uid = await this.get_uid_by_token(token);
        if (uid === null) {
            throw Error(`No user with token "${token}" exists.`);
        }
        return await this.get_user(uid);
    }
    
    // Load user data.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Load Public User Data
     *  @description:
     *      Load public user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read and write access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns an empty type object when the data does not exist.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: def
     *      @description: The default data to be returned when the data does not exist. When the data does exist the data will parsed into the type of the `def` parameter.
     *      @type: boolean, number, string, array, object.
     *  }
     *  @usage:
     *      ...
     *      const data = await server.load_user_data(0, "mydata", "object");
     } */
    async load_user_data(uid, subpath, def = null) {
        return this._sys_load_user_data(uid, subpath, def, "public");
    }
    
    // Save user data.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Load Public User Data
     *  @description:
     *      Save user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read and write access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  }
     *  @usage:
     *      ...
     *      await server.save_user_data(0, "mydata", {"Hello": "World!"});
     *      await server.save_user_data(0, "mystring", "Hello World!");
     } */
    async save_user_data(uid, subpath, data) {

        // Initialize path.
        const path = this._sys_save_user_data(uid, subpath, "public");

        // Save casted data.
        if (data == null || typeof data === "string") {
            path.save_sync(data);
        } else if (typeof data === "boolean" || typeof data === "number") {
            path.save_sync(data.toString());
        } else if (Array.isArray(data) || typeof data === "object") {
            path.save_sync(JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["boolean", "number", "string", "array", "object"].`);
        }
    }

    // Load user data.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Load Protected User
     *  @description:
     *      Load protected user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns an empty type object when the data does not exist.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: def
     *      @description: The default data to be returned when the data does not exist. When the data does exist the data will parsed into the type of the `def` parameter.
     *      @type: boolean, number, string, array, object.
     *  }
     *  @usage:
     *      ...
     *      const data = await server.load_protected_user_data(0, "mydata", "object");
     } */
    async load_protected_user_data(uid, subpath, def = null) {
        return this._sys_load_user_data(uid, subpath, def, "protected");
    }
    
    // Save user data.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Save Proteced User Data
     *  @description:
     *      Save protected user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  }
     *  @usage:
     *      ...
     *      await server.save_protected_user_data(0, "mydata", {"Hello": "World!"});
     *      await server.save_protected_user_data(0, "mystring", "Hello World!");
     } */
    async save_protected_user_data(uid, subpath, data) {

        // Initialize path.
        const path = this._sys_save_user_data(uid, subpath, "protected");

        // Save casted data.
        if (data == null || typeof data === "string") {
            path.save_sync(data);
        } else if (typeof data === "boolean" || typeof data === "number") {
            path.save_sync(data.toString());
        } else if (Array.isArray(data) || typeof data === "object") {
            path.save_sync(JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["boolean", "number", "string", "array", "object"].`);
        }
    }

    // Load user data.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Load Private User Data
     *  @description:
     *      Load private user data by subpath.
     *
     *      The subpath resides in the user's private data directory.
     *
     *      The user has no read or write access to the private directory.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns an empty type object when the data does not exist.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: def
     *      @description: The default data to be returned when the data does not exist. When the data does exist the data will parsed into the type of the `def` parameter.
     *      @type: boolean, number, string, array, object.
     *  }
     *  @usage:
     *      ...
     *      const data = await server.load_private_user_data(0, "mydata", "object");
     } */
    async load_private_user_data(uid, subpath, def = null) {
        return this._sys_load_user_data(uid, subpath, def, "private");
    }
    
    // Save user data.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Save Private User Data
     *  @description:
     *      Save private user data by subpath.
     *
     *      The subpath resides in the user's private data directory.
     *
     *      The user has no read or write access to the private directory.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  }
     *  @usage:
     *      ...
     *      await server.save_private_user_data(0, "mydata", {"Hello": "World!"});
     *      await server.save_private_user_data(0, "mystring", "Hello World!");
     } */
    async save_private_user_data(uid, subpath, data) {

        // Initialize path.
        const path = this._sys_save_user_data(uid, subpath, "private");

        // Save casted data.
        if (data == null || typeof data === "string") {
            path.save_sync(data);
        } else if (typeof data === "boolean" || typeof data === "number") {
            path.save_sync(data.toString());
        } else if (Array.isArray(data) || typeof data === "object") {
            path.save_sync(JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["boolean", "number", "string", "array", "object"].`);
        }
    }
    
    // Generate an api key by uid.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Generate API Key
     *  @description:
     *      Generate an API key for a user.
     *
     *      Generating an API key overwrites all existing API keys.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns the API key string.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to generate an API key for.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      const api_key = await server.generate_api_key(0);
     } */
    async generate_api_key(uid) {
        this._check_uid_within_range(uid);
        const api_key = `0${uid}:${this._sys_generate_key()}`;
        const user = this._sys_load_user(uid);
        user.api_key = this._hmac(api_key);
        this._sys_save_user(uid, user);
        return api_key;
    }
    
    // Revoke the API key of a user.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Revoke API Key
     *  @description:
     *      Revoke the API key of a user.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to revoke the API key for.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      await server.revoke_api_key(0);
     } */
    async revoke_api_key(uid) {
        this._check_uid_within_range(uid);
        const user = this._sys_load_user(uid);
        user.api_key = "";
        this._sys_save_user(uid, user);
    }
    
    // Verify a plaintext password.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Verify Password
     *  @description:
     *      Verify a plaintext password.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to verify.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: password
     *      @description: The plaintext password.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = await server.verify_password(0, "XXXXXX");
     } */
    async verify_password(uid, password) {
        if (uid === null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const user = this._sys_load_user(uid);
        return user.uid !== null && user.password === this._hmac(password);
    }
    
    // Verify a plaintext api key.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Verify API Key
     *  @description:
     *      Verify an plaintext API key.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: api_key
     *      @description: The api key to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = await server.verify_api_key("XXXXXX");
     } */
    async verify_api_key(api_key) {
        return await this.verify_api_key_by_uid(await this.get_uid_by_api_key(api_key), api_key);
    }

    // Verify a plaintext api key by uid.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Verify API Key By UID
     *  @description:
     *      Verify an plaintext API key by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the api key to verify.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: api_key
     *      @description: The api key to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = await server.verify_api_key_by_uid(0, "XXXXXX");
     } */
    async verify_api_key_by_uid(uid, api_key) {
        if (uid == null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const user = this._sys_load_user(uid);
        return user.uid !== null && user.api_key.length > 0 && user.api_key == this._hmac(api_key);
    }
    
    // Verify a token.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Verify Token
     *  @description:
     *      Verify an plaintext token.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: api_key
     *      @description: The token to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = await server.verify_token("XXXXXX");
     } */
    async verify_token(token) {
        return await this.verify_token_by_uid(await this.get_uid_by_api_key(token), token);
    }

    // Verify a token by uid.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Verify Token By UID.
     *  @description:
     *      Verify an plaintext token by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the token to verify.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: api_key
     *      @description: The token to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = await server.verify_token_by_uid(0, "XXXXXX");
     } */
    async verify_token_by_uid(uid, token) {
        if (uid == null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const correct_token = this._sys_load_user_token(uid);
        return correct_token.token != null && Date.now() < correct_token.expiration && correct_token.token == this._hmac(token);
    }

    // Verify a 2fa code.
    // Use async to keep it persistent with other functions.
    /*  @docs {
     *  @title: Verify 2FA Code
     *  @description:
     *      Verify a 2FA code by user id.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: code
     *      @description: The 2FA code.
     *      @type: string
     *  }
     *  @return: Returns a boolean indicating whether the verification was successful or not.
     *  @usage:
     *      ...
     *      await server.verify_2fa(0, "123456");
     } */
    async verify_2fa(uid, code) {
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const auth = this._sys_load_user_2fa(uid);
        const now = Date.now();
        const status = auth.code != null && now < auth.expiration && auth.code == code;
        if (status || now > auth.expiration) {
            this._sys_delete_user_2fa(uid);
        }
        return status;
    }
    
    // Send a mail.
    /*  @docs {
     *  @title: Send Mail
     *  @description:
     *      Send one or multiple mails.
     *
     *      Make sure the domain's DNS records SPF and DKIM are properly configured when sending attachments.
     *
     *      See `vlib::smtp::Client` and `vlib::smtp::Mail` for more info.
     *  @return:
     *      Returns a promise that will be resolved or rejected when the mail has been sent.
     *  @parameter: {
     *      @name: sender
     *      @description:
     *          The sender address.
     *          A sender address may either be a string with the email address, e.g. `your@email.com`.
     *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
     *      @type: string, array
     *  }
     *  @parameter: {
     *      @name: recipients
     *      @description:
     *          The recipient addresses.
     *          A reciepient address may either be a string with the email address, e.g. `your@email.com`.
     *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
     *      @type: array[string, array]
     *  }
     *  @parameter: {
     *      @name: subject
     *      @description: The subject text.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: body
     *      @description: The body text.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: attachments
     *      @description: An array with absolute file paths for attachments.
     *      @type: array[string]
     *  }
     *  @usage:
     *      ...
     *      await server.send_mail({
     *          sender: ["Sender Name", "sender\@email.com"],
     *          recipients: [
     *              ["Recipient Name", "recipient1\@email.com"],
     *              "recipient2\@email.com",
     *          },
     *          subject: "Example Mail",
     *          body: "Hello World!",
     *          attachments: ["/path/to/image.png"]
     *      });
     } */
    async send_mail({
        sender = null,
        recipients = [],
        subject = null,
        body = "",
        attachments = [],
    }) {
        return new Promise((resolve, reject) => {

            // Not enabled.
            if (this.smtp_enabled === false) {
                return reject(new Error("SMTP is not enabled, define the required server argument on initialization to enable smtp."));
            }

            // Check args.
            if (sender === null) {
                sender = this.smtp_sender;
                // return reject(new Error(`Parameter "sender" should be a defined value of type "string" or "array".`));
            }
            if (recipients.length === 0) {
                return reject(new Error(`The mail has no recipients.`));
            }
            if (sender === null) {
                return reject(new Error(`Parameter "sender" should be a defined value of type "string" or "array".`));
            }

            // Format address wrapper.
            const format_address = (address) => {
                if (Array.isArray(address)) {
                    return `${address[0]} <${address[1]}>`;
                }
                return address;
            }

            // Create to array.
            const to = [];
            recipients.iterate((address) => to.push(format_address(address)));

            // Create attachments array.
            const attached_files = [];
            attachments.iterate((path) => {
                attached_files.push({
                    filename: new vlib.Path(path).name(),
                    path: path,
                })
            })

            // Send mail.
            this.smtp.sendMail(
                {
                    from: format_address(sender),
                    to: to,
                    subject: subject,
                    html: body,
                    attachments: attachments,
                },
                (error, info) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(info);
                    }
                }
            )

        })
    }
    
    // Send a 2fa code.
    /*  @docs {
     *  @title: Send 2FA Code
     *  @description:
     *      Send a 2FA code to a user by user id.
     *
     *      By default the 2FA code will be valid for 5 minutes.
     *  @return:
     *      Returns a promise that will be resolved or rejected when the 2fa mail has been sent.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: request
     *      @description: The request object from the client request.
     *      @type: object
     *  }
     *  @parameter: {
     *      @name: mail_body
     *      @description: 
     *          The mail body in HTML. 
     *          When this parameter is undefined, the server attribute `mail_body_2fa` will be used as the body.
     *          It should contain the string "{{2FA}}", which will be replaced with the generated 2FA code.
     *          Other optional replaced keys are: 
     *              - `{{USERNAME}}`
     *              - `{{DATE}}`
     *              - `{{IP}}`
     *              - `{{DEVICE}}`
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: expiration
     *      @description: The amount of seconds in which the code will expire.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      await server.send_2fa({uid: 0, request: request});
     } */
    async send_2fa({
        uid, 
        request,
        mail_body = null,
        expiration = 300,
        _device = null,
    }) {
        this._check_uid_within_range(uid);
        
        // Generate 2fa.
        const auth = {
            expiration: Date.now() + expiration * 1000,
            code: this._sys_generate_2fa(),
        };
        this._sys_save_user_2fa(uid, auth);
        
        // Get user email.
        const user = await this.get_user(uid);
        
        // Get device.
        let device;
        if (_device === null) {
            device = request.headers["user-agent"];
        }
        
        // Replace body.
        let body;
        if (mail_body == null) {
            body = this.mail_body_2fa
                .replaceAll("{{2FA}}", auth.code)
                .replaceAll("{{USERNAME}}", user.username)
                .replaceAll("{{DATE}}", (new Date()).toUTCString())
                .replaceAll("{{IP}}", request.ip)
                .replaceAll("{{DEVICE}}", device ? device : "Unknown");    
        } else {
            body = mail_body
                .replaceAll("{{2FA}}", auth.code)
                .replaceAll("{{USERNAME}}", user.username)
                .replaceAll("{{DATE}}", (new Date()).toUTCString())
                .replaceAll("{{IP}}", request.ip)
                .replaceAll("{{DEVICE}}", device ? device : "Unknown");
        }
        
        // Send mail.
        return await this.send_mail({
            sender: this.smtp_sender,
            recipients: [user.email],
            subject: "Two Factor Authentication Code",
            body: body,
        });   
    }

    // Get a product by id.
    // Use async to keep it persistent with other functions.
    /*  @docs
     *  @title: Get Product
     *  @description:
     *      Get a product by id.
     *  @parameter:
     *      @name: id
     *      @description: The id of the product to retrieve. The id may either be the id of a product or a the id from a plan of a subscription product.
     *      @type: string
     *  @parameter:
     *      @name: throw_err
     *      @type: boolean
     *      @description: Throw an error when the product was not found.
     *  @type: object.
     *  @return: Returns the product object.
     *  @usage:
     *      ...
     *      const product = server.get_product("prod_basic");
     */
    async get_product(id, throw_err = false) {
        const product = this.payment_products.iterate((p) => {
            if (p.is_subscription) {
                if (p.id === id) {
                    return p;
                }
                return p.plans.iterate((plan) => {
                    if (plan.id === id) {
                        return plan;
                    }
                })
            }
            else if (p.id === id) {
                return p;
            }
        })
        if (product == null) {
            throw Error(`Unable to find product "${id}".`);
        }
        return product;
    }

    // Create a payment
    // @todo when the user has a saved payment method and purchases eg an subscription then the invoice will automatically be charged without requiring the confirmPaymentIntent in the frontend, which is a problem.
    /*  @docs
     *  @title: Create Payment.
     *  @description:
     *      Create a payment for multiple products.
     *  @parameter:
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  @parameter:
     *      @name: cart
     *      @type: array[object]
     *      @description: 
     *          The shopping cart to charge, each cart item looks like `{id: <plan or product id>, quantity: <number>}`.
     *
     *          When attribute `quantity` is undefined value `1` will be used as quantity.
     *          Optionally the `product` attribute can be assigned with the user defined product object.
     *  @parameter:
     *      @name: address
     *      @type: object
     *      @description: 
     *          The billing address of the customer, only required when `automatic_tax` is enabled.
     *
     *          An address objects has the following attributes:
     *          ```js
     *          {
     *              line1: "",
     *              line2: null,
     *              city: "",
     *              state: "",
     *              country: 'US',
     *              postal_code: ""
     *          }```
     *  @type: object.
     *  @return: Returns an object with the client secret that should be passed to the frontend.
     *  @usage:
     *      ...
     *      await server.create_payment({uid: 0, cart: [{id: "prod_basic", quantity: 1}]});
     */
    async create_payment({uid, cart = [], address = null, cid = null, email = null}) {

        // Check uid.
        this._check_uid_within_range(uid);

        // Vars.
        let line_items = [];

        // Check args.
        if (Array.isArray(cart) === false) {
            throw Error(`Parameter "cart" has an invalid value type "${typeof cart}", the valid value type is "array".`);
        } else if (cart.length === 0) {
            throw Error(`No product cart was specified.`);
        }
        if (this.automatic_tax && typeof address !== "object") {
            throw Error(`Parameter "address" has an invalid value type "${typeof address}", the valid value type is "object".`);
        }

        // Check products.
        const plan_count_per_product = {};
        await cart.iterate_async_await(async (i) => {

            // Get product.
            let product = i.product;
            if (product == null) {
                product = await this.get_product(i.id);
                if (product == null) {
                    throw Error(`Unknown product id "${i.id}".`);
                }
                if (product.is_subscription && i.quantity > 0) {
                    throw Error(`A subscription product ("${i.id}") can not have a quantity of more than 1.`);   
                }
            }

            // Check subscriptions.
            if (product.is_subscription) {

                // Check if the id of the product was not passed instead of the id of the product's plan.
                if (product.price_id == null) {
                    throw Error(`You can only charge one of the subscription's plans, not the subscription product itself "${product.id}".`);
                }

                // Only allow one plan per transaction.
                if (plan_count_per_product[product.parent_id] === undefined) {
                    plan_count_per_product[product.parent_id] = 1;
                } else if (plan_count_per_product[product.parent_id] >= 1) {
                    throw Error(`You can not charge multiple subscription plans of the same subscription product in one request.`);
                }

                // Check if the user is already subscribed to this product.
                const {exists} = this._sys_check_subscription(uid, product.id);
                if (exists) {
                    throw Error(`You are already subscribed to product "${product.id}".`);
                }
            }

            // Add to line items.
            line_items.push({
                price: product.price_id,
                quantity: i.quantity == null ? 1 : i.quantity,
            })
        })

        // Retrieve the cid from the user.
        if (cid == null) {

            // Check uid.
            if (uid == null) {
                throw Error("One of the following parameters must be defined \"uid\" or \"cid\".");
            }

            // Load the user's email.
            email = (await this.get_user(uid)).email

            // Get the customer id.
            cid = await this._stripe_get_cid(uid);

        }

        // Retrieve the email when both the cid and uid are defined.
        else if (uid != null && email == null) {
            email = (await this.get_user(uid)).email
        }

        // Check the email.
        if (email == null) {
            throw Error("Define parameter \"email\".");
        }

        // Stripe requests.
        let customer, quote, invoice, payment_intent;
        try {

            // The address of the customer must be included to calculate automatic tax https://stripe.com/docs/billing/taxes/collect-taxes.
            if (this.automatic_tax) {
                customer = await this.stripe.customers.update(
                    cid,
                    {address: address}
                );    
            }

            // Create the quote
            quote = await this.stripe.quotes.create({
                customer: cid,
                description: "Invoice summary for your recent order.",
                line_items: line_items,
                collection_method: "charge_automatically",
                automatic_tax: {enabled: this.automatic_tax},
            });

            // Finalize the quote.
            quote = await this.stripe.quotes.finalizeQuote(quote.id);

            // Accept the quote.
            quote = await this.stripe.quotes.accept(quote.id, {
                expand: ["invoice"]
            });

            // Accept the invoice.
            invoice = await this.stripe.invoices.finalizeInvoice(
                quote.invoice.id,
                {
                    auto_advance: false,
                    expand: ["payment_intent"],
                }
            );

            // Update the payment intent.
            payment_intent = await this.stripe.paymentIntents.update(
                invoice.payment_intent.id,
                {
                    setup_future_usage: "off_session", // required to save this payment method for renewals on subscriptions.
                    metadata: {
                        invoice: invoice.id,
                    },
                }
            );
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }

        // Response for frontend.
        return {
            id: quote.id,
            client_secret: payment_intent.client_secret,
        };
    }

    // Retrieve the created payment quotes of a user.
    // @todo TEST
    /*  @docs {
     *  @title: Get Payments
     *  @description:
     *      Retrieve the created payment quotes of a user.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  @parameter:
     *      @name: status
     *      @description: Filter the list by status, possible values are `[null, "draft", "open", "void", "paid", "uncollectible"]`.
     *      @type: null, string
     *  @parameter:
     *      @name: days
     *      @description: Since the amount of last days back, so `days: 30` will retrieve the payments of the last 30 days.
     *      @type: null, number
     *  @parameter:
     *      @name: ending_before
     *      @description: A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
     *      @type: null, string
     *  @parameter:
     *      @name: starting_after
     *      @description: A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
     *      @type: null, string
     *  @parameter:
     *      @name: refunded
     *      @description: Filter the payments by a refund request, `refunded: null` will both non refunded and refunded payments, `refunded: true` will retrieve all refunded payments and `refunded: false` will retrieve all non refunded payments.
     *      @type: null, boolean
     *  @parameter:
     *      @name: limit
     *      @description: A limit on the number of objects to be returned. Leave the limit `null` to disable the limit.
     *      @type: null, number
     *  @type: Promise
     *  @return:
     *      Returns a promise to a list of payments or a rejection with an error.
     *
     *      A payment product has the following attributes:
     *      ```js
     *      {
     *          timestamp: <number>,            // the unix timestamp in seconds of the purchase.
     *          product: <object>,              // the user defined product that was purchased.
     *          quantity: <number>,             // the quantity of the purchased product.
     *          amount: <number>,               // the total charged amount by this purchase.
     *          refund: {                       // the refund object when a refund request has been made. This value will be `null` when no refund request has been made for this payment.
     *              id: <string>,               // the id of the refund request.
     *              status: <string>,           // the status of the refund request, the status can be "processing", "succeeded", "failed", "requires_action", "canceled".
     *              description: <string>,      // the status description of the refund request.
     *          },
     *          pdf: <string>,                  // the url string to the pdf download link.
     *          invoice: <string>,              // the invoice's id of the purchase.
     *          invoice_item: <string>,         // the invoice item's id of the purchase.
     *          payment_intent: <string>,       // the payment intent's id of the purchase.
     *      }
     *      ```
     *  @usage:
     *      ...
     *      const payments = await server.get_payments("...");
     } */
    async get_payments({
        uid,  
        status = null,
        days = null,
        ending_before = null,
        starting_after = null,
        refunded = null,
        limit = null,
    }) {

        // Check uid.
        this._check_uid_within_range(uid);

        // Get stripe cid.
        const cid = this._stripe_get_cid(uid);

        // Create subscription.
        let payments = [];
        let first = true;
        let result;
        while (true) {
            try {

                // First request.
                if (first) {

                    // By since days.
                    if (days != null) {
                        let created = new Date();
                        created.setHours(0, 0, 0, 0)
                        created.setDate(created.getDate() - days);
                        created = Math.floor(created.getTime() / 1000);
                        result = await this.stripe.invoices.list({
                            customer: cid,
                            limit: 100,
                            status: status,
                            created: {
                                gte: created,
                            },
                        });
                    }

                    // By starting after, ending before or no filters.
                    else {
                        result = await this.stripe.invoices.list({
                            customer: cid,
                            limit: 100,
                            status: status,
                            ending_before: ending_before,
                            starting_after: starting_after,
                        });
                    }
                    first = false;
                }

                // Later requests.
                else {
                    result = await this.stripe.invoices.list({
                        customer: cid,
                        limit: 100,
                        status: status,
                        starting_after: payments.length > 0 ? payments.last().invoice : undefined,
                        created: {
                            gte: created,
                        },
                    });
                }
            }

            // Handle error.
            catch (error) {
                throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
            }

            // Parse invoices.
            await this._stripe_parse_as_list(result.data).iterate_async_await(async (item) => {
                const items = this._stripe_parse_as_list(item.lines.data);
                await items.iterate_async_await(async (line_item) => {
                    let refund = null;
                    if (item.metadata[line_item.id]) {
                        const split = item.metadata[line_item.id].split(" ");
                        refund = {
                            id: split[0],
                            status: split[1],
                            description: split.slice(2).join(" "),
                        };
                    }
                    if (
                        refunded == null ||
                        (refunded === false && refund == null) ||
                        (refunded === true && refund != null)
                    ) {
                        payments.push({
                            timestamp: item.created,
                            product: await this.get_product(line_item.price.product),
                            quantity: line_item.quantity,
                            amount: parseFloat(line_item.amount) / 100,
                            refund: refund,
                            pdf: item.invoice_pdf,
                            invoice: item.id,
                            invoice_item: line_item.id,
                            payment_intent: item.payment_intent,
                            uid: uid, // required for `_sys_add_open_refund()`.
                        });
                    }
                })
            })

            // Stop.
            if (result.has_more !== true || ending_before != null) {
                break;
            }
        }

        // Sort from newest till oldest.
        payments.sort((a, b) => b.timestamp - a.timestamp)
        if (limit != null && limit !== -1 && payments.length > limit) {
            payments.length = limit;
        }

        // Handler.
        return payments;
    }

    // Get the subscriptions of a user.
    // Use async to keep it persistent with other functions.
    // @todo TEST
    /*  @docs {
     *  @title: Get Subscriptions
     *  @description:
     *      Get the subscriptions of a user.
     *  @parameter:
     *      @name: uid
     *      @description: The id of the user you want to retrieve the subscriptions from.
     *      @type: number
     *  @type: array[string]
     *  @return: Returns a list with the product id's the user is subscribed to.
     *  @usage:
     *      ...
     *      const subscriptions = server.get_subscriptions(1);
     } */
    async get_subscriptions(uid) {
        this._check_uid_within_range(uid);
        return _sys_get_subscriptions(uid);
    }

    // Check if a user is subscribed to a specific product.
    // Use async to keep it persistent with other functions.
    // @todo TEST
    /*  @docs {
     *  @title: Is Subscribed
     *  @description:
     *      Check if a user is subscribed to a specific product.
     *  @parameter:
     *      @name: uid
     *      @description: The id of the user to check.
     *      @type: number
     *  @parameter:
     *      @name: id
     *      @description: The id of product to check.
     *      @type: string
     *  @type: boolean
     *  @return: Returns a boolean indicating if the user is subscribed to that product or not.
     *  @usage:
     *      ...
     *      const subscriptions = await server.is_subscribed(0, "sub_basic");
     } */
    async is_subscribed(uid, id) {
        this._check_uid_within_range(uid);
        const {exists} = this._sys_check_subscription(uid, id, false);
        return exists;
    }

    // Get the subscriptions of a user.
    // Use async to keep it persistent with other functions.
    // @todo TEST
    /*  @docs {
     *  @title: Get Subscription Id
     *  @description:
     *      Get the subscription id from a user's subscription by product id.
     *  @parameter:
     *      @name: uid
     *      @description: The id of the user to retrieve the subscription id from.
     *      @type: number
     *  @parameter:
     *      @name: id
     *      @description: The id of product to retrieve the subscription id from.
     *      @type: string
     *  @type: null, string
     *  @return: When the user is not subscribed to the product `null` will be returned. When the user is subscribed to the product the subscription id will be returned.
     *  @usage:
     *      ...
     *      const id = await server.get_subscription(1, "sub_basic");
     } */
    async get_subscription(uid, id) {
        this._check_uid_within_range(uid);
        const {exists, sub_id} = this._sys_check_subscription(uid, id);
        if (exists) {
            return sub_id;
        }
        return null;
    }

    // Get the subscriptions of a user.
    // @todo TEST
    /*  @docs {
     *  @title: Get Subscription Object
     *  @description:
     *      Get the stripe subscription object by a subscription id.
     *  @parameter:
     *      @name: id
     *      @description: The subscription id.
     *      @type: string
     *  @type: object
     *  @return: The stripe subscription object will be returned. more info about the object can be found at https://stripe.com/docs/api/subscriptions/object.
     *  @usage:
     *      ...
     *      const subscription = await server.get_subscription_obj("sub_xxxxxxxx");
     } */
    async get_subscription_obj(id) {
        try {
            return await this.stripe.subscriptions.retrieve(id);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Cancel a subscription
    // @todo TEST
    /*  @docs:
     *  @title: Cancel Subscription
     *  @description: Cancel an active subscription.
     *  @warning: All the subscriptions that were purchased by the charge request in which the user bought the subscription will also be cancelled.
     *  @parameter:
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *      @required: true
     *  @parameter:
     *      @name: id
     *      @description: The product's plan id of the user defined subscription product.
     *      @type: string
     *      @required: true
     *  @parameter:
     *      @name: sub_id
     *      @description: This parameter is optional, it can be passed to cancel a specific subscription by subscription id. When parameter `id` is passed, the subscription id will automatically be retrieved.
     *      @type: string
     *  @usage:
     *      ...
     *      server.cancel_subscription({uid: 0, id: "sub_basic"});
     */
    async cancel_subscription(uid, id, sub_id = null) {

        // Check params.
        if (typeof uid !== "number") {
            throw Error(`Parameter "uid" has an invalid value type "${typeof uid}", the valid value type is "number".`);
        }
        if (typeof id !== "string") {
            throw Error(`Parameter "id" has an invalid value type "${typeof id}", the valid value type is "string".`);
        }

        // Check uid.
        this._check_uid_within_range(uid);

        // Get the sub id.
        if (sub_id == null) {
            const result = this._sys_check_subscription(uid, id);
            if (result.exists === false) {
                throw Error(`User "${uid}" does not have a subscription on product "${id}".`);
            }
            sub_id = result.sub_id;
        }

        // Cancel the subscriptions.
        await this._stripe_cancel_subscription(sub_id);

        // Remove from subscriptions.
        this._sys_remove_subscription(uid, id);
    }

    // Create a refund for a payment intent.
    // @todo TEST
    /*  @docs {
     *  @title: Get Refunable Payments
     *  @description:
     *      Get a list of the user's payments that are refundable.
     *  @type: Promise
     *  @return:
     *      Returns a promise to a list of refundable payments or a rejection with an error.
     *
     *      A payment product has the following attributes:
     *      ```js
     *      {
     *          timestamp: <number>,            // the unix timestamp in seconds of the purchase.
     *          product: <object>,              // the user defined product that was purchased.
     *          quantity: <number>,             // the quantity of the purchased product.
     *          amount: <number>,               // the total charged amount by this purchase.
     *          refund: {                       // the refund object when a refund request has been made. This value will be `null` when no refund request has been made for this payment.
     *              id: <string>,               // the id of the refund request.
     *              status: <string>,           // the status of the refund request, the status can be "processing", "succeeded", "failed", "requires_action", "canceled".
     *              description: <string>,      // the status description of the refund request.
     *          },
     *          pdf: <string>,                  // the url string to the pdf download link.
     *          invoice: <string>,              // the invoice's id of the purchase.
     *          invoice_item: <string>,         // the invoice item's id of the purchase.
     *          payment_intent: <string>,       // the payment intent's id of the purchase.
     *      }
     *      ```
     *  @parameter:
     *      @name: uid
     *      @description: The id of the user.
     *      @type: number
     *  @parameter:
     *      @name: days
     *      @description: The number of days for which the payment is still refundable.
     *      @type: null, number
     *  @parameter:
     *      @name: refunded
     *      @description: Filter the payments by a refund request, `refunded: null` will both non refunded and refunded payments, `refunded: true` will retrieve all refunded payments and `refunded: false` will retrieve all non refunded payments.
     *      @type: null, boolean
     *  @parameter:
     *      @name: limit
     *      @description: A limit on the number of objects to be returned. The limit can range between 1 and 100, the default is 100.
     *      @type: number
     *  @usage:
     *      ...
     *      const payments = await server.get_refundable_payments({uid: 1, days: 14});
     } */
    async get_refundable_payments({uid, days = 14, refunded = null, limit = null}) {
        return await this.get_payments({uid: uid, days: days, refunded: null, limit: limit, status: "paid"})
    }

    // Create a refund for a payment intent.
    /*  @docs {
     *  @title: Create Refund
     *  @description:
     *      Create a refund for a payment intent.
     *
     *      When the payment intent is part of a subscription, the active subscription will automatically be cancelled.
     *  @type: object
     *  @usage: Returns the stripe refund object.
     *  @parameter:
     *      @name: payment
     *      @description: The retrieved payment object from `Server.get_payments()` or `Server.get_refundable_payments()`.
     *      @type: object
     *  @parameter:
     *      @name: auto_advance
     *      @description:
     *          When auto advance is enabled the refund will be initiated, when auto_advance is disabled the refund is added to the database and must still be confirmed with `Server.create_refund({payment: ..., auto_advance: true})`.
     *          This may be required when a user should return a product before confirming the refund.
     *          The open refund requests can be retrieved with `Server.get_open_refunds()`.
     *      @type: boolean
     *  @usage:
     *      ...
     *      const payment = ...;
     *      await server.create_refund(payment);
     } */
    async create_refund({payment = null, auto_advance = true}) {

        // Vars.
        let invoice, invoice_obj, invoice_item, invoice_item_obj, payment_intent, amount, uid;

        // Check args.
        if (typeof payment !== "object") {
            throw Error(`Parameter "payment" has an incorrect type "${typeof payment}", the valid type is "object".`);
        }
        if (typeof payment.amount !== "number") {
            throw Error(`Parameter "payment.amount" has an incorrect type "${typeof payment.amount}", the valid type is "number".`);
        }
        if (typeof payment.invoice !== "string") {
            throw Error(`Parameter "payment.invoice" has an incorrect type "${typeof payment.invoice}", the valid type is "string".`);
        }
        if (typeof payment.invoice_item !== "string") {
            throw Error(`Parameter "payment.invoice_item" has an incorrect type "${typeof payment.invoice_item}", the valid type is "string".`);
        }
        if (typeof payment.payment_intent !== "string") {
            throw Error(`Parameter "payment.payment_intent" has an incorrect type "${typeof payment.payment_intent}", the valid type is "string".`);
        }
        if (typeof payment.uid !== "number") {
            throw Error(`Parameter "payment.uid" has an incorrect type "${typeof payment.uid}", the valid type is "number".`);
        }

        // Already refunded.
        if (payment.refund_status === "succeeded") {
            throw Error(`This payment was already successfully refunded.`);   
        } else if (payment.refund_status != null && payment.refund_status !== "processing") {
            throw Error(`A refund request has already been made for this payment.`);
        }

        // Assign.
        invoice = payment.invoice;
        invoice_item = payment.invoice_item;
        payment_intent = payment.payment_intent;
        amount = payment.amount;
        uid = payment.uid;

        // Set the refund metadata on the invoice.
        // Update the line item's metadata to set the refund id.
        // This status will be updated by the webhook.
        // Therefore the `Server.get_products()` can indicate if the payment was already refunded and add the status.
        const update_invoice_metadata = async (refund) => {
            try {
                const metadata = {};
                metadata[invoice_item] = `${refund.id} ${refund.status} ${refund.status_description}`;
                await this.stripe.invoices.update(invoice, {
                    metadata: metadata,
                });
            } catch (error) {
                throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
            }
        }

        // Do not advance.
        if (auto_advance !== true) {

            // Create a refund object for the frontend.
            const refund = {
                id: invoice_item,
                status: "processing",
                status_description: "The refund request is being processed.",
            };

            // Uppdate metadata on the invoice.
            await update_invoice_metadata(refund);

            // Add to database.
            this._sys_add_open_refund(uid, invoice_item, payment);

            // On refund requrest callback.
            if (this.on_refund_request != null) {
                this.on_refund_request({
                    uid: uid,
                    cid: cid,
                    payment: payment,
                    invoice: invoice,
                    invoice_item: invoice_item,
                    refund: refund,
                });
            }
            return refund;
        }

        // By invoice.
        try {
            invoice_obj = await this.stripe.invoices.retrieve(invoice);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }

        // Get the uid of the invoice.
        if (uid == null) {
            try {
                uid = this._sys_load_uid_by_stripe_cid(invoice_obj.customer);
            } catch (err) {
                uid = null;
            }
        } else {
            this._check_uid_within_range(uid);
        }

        // Get the invoice item object.
        try {
            invoice_item_obj = await this.stripe.invoiceItems.retrieve(invoice_item);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }

        // Cancel the subscription.
        if (uid != null && invoice_item_obj.price.type === "recurring") {
            const {exists, sub_id} = this._sys_check_subscription(uid, invoice_item_obj.price.product);
            if (exists) {
                await this._stripe_cancel_subscription(sub_id);
                this._sys_remove_subscription(uid, invoice_item_obj.price.product);
                if (typeof invoice_item_obj.subscription === "string" && sub_id !== invoice_item_obj.subscription) {
                    await this._stripe_cancel_subscription(invoice_item_obj.subscription);    
                }
            } else if (typeof invoice_item_obj.subscription === "string") {
                try {
                    await this._stripe_cancel_subscription(invoice_item_obj.subscription);
                } catch (err) {}
            }
        }

        // Create refund.
        let refund;
        try {
            refund = await this.stripe.refunds.create({
                id: refund_id,
                payment_intent: payment_intent,
                amount: amount == null ? undefined : parseInt(amount * 100),
                metadata: {
                    invoice: invoice,
                    invoice_item: invoice_item,
                    payment_intent: payment_intent,
                },
            });
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }

        // Parse the failed status.
        this._stripe_parse_refund(refund);

        // Update the line item's metadata to set the refund id.
        // This status will be updated by the webhook.
        // Therefore the `Server.get_products()` can indicate if the payment was already refunded and add the status.
        await update_invoice_metadata(refund);

        // Remove the open refund from the database.
        this._sys_remove_open_refund(uid, invoice_item);

        // Return the refund info.
        return refund;
    }

    // Get all open and unconfirmed refund requests.
    /*  @docs {
     *  @title: Get Open Refunds
     *  @description:
     *      Get all requested but unconfirmed refund payments.
     *
     *      An requested but unconfirmed refund payment must still be confirmed with `Server.create_refund({payment: ..., auto_advance: true})`.
     *  @type: array[object]
     *  @usage: Returns a list of requested refund payments.
     *  @parameter:
     *      @name: uid
     *      @description: Filter the open refund requests by uid (optional).
     *      @type: number
     *  @usage:
     *      ...
     *      const refund_payments = await server.get_open_refunds();
     } */
    async get_open_refunds(uid = null) {
        if (uid != null && typeof uid !== "number") {
            throw Error(`Parameter "uid" has an incorrect type "${typeof uid}", the valid type is "number".`);
        }
        return this._sys_get_open_refunds(uid);
    }

    // Get an open and unconfirmed refund request.
    /*  @docs {
     *  @title: Get Open Refunds
     *  @description:
     *      Get a requested but unconfirmed refund payment by id.
     *
     *      An requested but unconfirmed refund payment must still be confirmed with `Server.create_refund({payment: ..., auto_advance: true})`.
     *  @type: object
     *  @usage: Returns the requested refund payment.
     *  @parameter:
     *      @name: uid
     *      @description: The uid of the user that requested the refund.
     *      @type: number
     *  @parameter:
     *      @name: id
     *      @description: The id of payment's unconfirmed refund request.
     *      @type: string
     *  @usage:
     *      ...
     *      const refund_payment = await server.get_open_refund("...");
     } */
    async get_open_refund(uid, id) {
        if (typeof uid !== "number") {
            throw Error(`Parameter "uid" has an incorrect type "${typeof uid}", the valid type is "number".`);
        }
        if (typeof id !== "string") {
            throw Error(`Parameter "id" has an incorrect type "${typeof id}", the valid type is "string".`);
        }
        return this._sys_get_open_refund(uid, id);
    }


    // Create a subscription.
    /*  DEPRECATED docs {
     *  @title: Create Subscription.
     *  @description:
     *      Create a subscription for one of the products.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: product_id
     *      @description: The id of the subscription payment product.
     *      @type: string
     *  }
     *  @type: object.
     *  @return: Returns an object with the client secret that should be passed to the frontend.
     *  @usage:
     *      ...
     *      server.create_subscription({uid: 0, product_id: "prod_sub_basic"});
     } 
    async create_subscription({uid, product_id, product = null, cid = null}) {

        // Get the products.
        if (product == null) {
            product = await this.get_product(product_id);
            if (product == null) {
                throw Error(`Unknown product id "${product_id}".`);
            }
            if (product.is_subscription === false) {
                throw Error(`Product "${product.name}" is not a subscription product.`);
            }
        }

        // Check subscription product.
        else if (product.is_subscription === false) {
            throw Error(`Product "${product.name}" is not a subscription product.`);
        }

        // Check product.
        if (product == null) {
            throw Error("Undefined product.");
        }

        // Check products price id.
        if (product.price_id == null) {
            throw Error("The product's price id must be defined to create a subscription.");
        }

        // Retrieve the cid from the user.
        if (cid == null) {

            // Check uid.
            if (uid == null) {
                throw Error("One of the following parameters must be defined \"uid\" or \"cid\".");
            }

            // Check uid.
            this._check_uid_within_range(uid);

            // Get cid.
            cid = await this._stripe_get_cid(uid)

        }

        // Fetch the user's subscriptions.
        const user_subs = await this._stripe_get_subscriptions(null, cid);

        // Check if the user is already subscribed.
        if (user_subs[product.id] !== undefined) {
            return {
                error: `You are already subscribed to product \"${product.name}\".`,
                already_subscribed: true,
            }
        }

        // Cancel the other active plans from this subscription.
        const subscription_product = await this.get_product(product.parent_id);
        if (subscription_product == null) {
            throw Error(`Unable to find payment product "${product.parent_id}".`);
        }
        subscription_product.plans.iterate_async_await((plan) => {
            if (plan.id !== product.id && user_subs[plan.id] !== undefined) {
                return this._stripe_cancel_subscription(user_subs[plan.id])
            }
        })

        // Create subscription.
        let subscription;
        try {
            subscription = await this.stripe.subscriptions.create({
                customer: cid,
                items: [
                    {price: product.price_id},
                ],
                payment_behavior: "default_incomplete",
                payment_settings: {
                    save_default_payment_method: 'on_subscription'
                },
                expand: ['latest_invoice.payment_intent'],
            });
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }

        // Update the payment intent to save the user's payment method for future usage.
        const payment_intent = await this.stripe.paymentIntents.update(
            subscription.latest_invoice.payment_intent.id,
            {
                setup_future_usage: "off_session", // required to automatically renew the subscription using the same payment method that will confirm the payment intent.
                metadata: {
                    subscription: subscription.id,
                },
            }
        );

        // Response for frontend.
        return {
            id: subscription.id,
            client_secret: payment_intent.client_secret,
        };
    }
    */
    
    // Create a payment
    /*  DEPRECATED docs {
     *  @title: Create Payment.
     *  @description:
     *      Create a subscription for one of the products.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: product_ids
     *      @description: The ids of the one-time payment products.
     *      @type: array[string]
     *  }
     *  @type: object.
     *  @return: Returns an object with the client secret that should be passed to the frontend.
     *  @usage:
     *      ...
     *      server.create_payment({uid: 0, product_ids: ["prod_basic"]});
     } 
    async create_payment({uid, product_ids, products = null, cid = null, email = null}) {

        // Vars.
        let meta_cart = [];
        let price_ids = [];

        // Check products.
        if (Array.isArray(products)) {
            products.iterate((p) => {
                if (p.is_subscription) {
                    throw Error(`Product "${p.name}" is a subscription product.`);
                }
                else if (currency == null) {
                    currency = p.currency;
                }
                else if (currency !== p.currency) {
                    throw Error(`Products with different currencies can not be charged in a single request ("${currency}" and "${p.currency}").`);
                }
                meta_cart.push({product: p.id, price: p.price});
                price_ids.push(p.price_id);
            })
        }

        // Get products.
        else {

            // Check args.
            if (Array.isArray(product_ids) === false) {
                throw Error(`Parameter "product_ids" has an invalid value type "${typeof product_ids}", the valid value type is "array".`);
            } else if (product_ids.length === 0) {
                throw Error(`No product ids were specified.`);
            }

            // Get the products.
            products = [];
            product_ids.iterate((id) => {
                const found = this.payment_products.iterate((p) => {
                    if (p.id === id) {
                        if (p.is_subscription) {
                            throw Error(`Product "${p.name}" is a subscription product.`);
                        }
                        else if (currency == null) {
                            currency = p.currency;
                        }
                        else if (currency !== p.currency) {
                            throw Error(`Products with different currencies can not be charged in a single request ("${currency}" and "${p.currency}").`);
                        }
                        products.push(p)
                        meta_cart.push({product: p.id, price: p.price});
                        price_ids.push(p.price_id);
                        return true;
                    }
                })
                if (found !== true) {
                    throw Error(`Unknown product id "${id}".`);
                }
            })
        }

        // Retrieve the cid from the user.
        if (cid == null) {

            // Check uid.
            if (uid == null) {
                throw Error("One of the following parameters must be defined \"uid\" or \"cid\".");
            }

            // Load the user's email.
            email = (await this.get_user(uid)).email

            // Get the customer id.
            cid = await this._stripe_get_cid(uid);

        }

        // Retrieve the email when both the cid and uid are defined.
        else if (uid != null && email == null) {
            email = (await this.get_user(uid)).email
        }

        // Check the email.
        if (email == null) {
            throw Error("Define parameter \"email\".");
        }

        // Create a description and statement descriptor.
        let description, statement_descriptor;
        if (products.length === 1) {
            description = products[0].description;
            statement_descriptor = products[0].statement_descriptor;
        }

        // Stripe requests.
        let invoice, payment_intent;
        try {

            // Create an invoice
            invoice = await this.stripe.invoices.create({
                customer: cid,
                description: description,
                statement_descriptor: statement_descriptor,
                collection_method: "charge_automatically",
                days_until_due: 30,
            });

            // Add items to the invoice.
            for (let i = 0; i < price_ids.length; i++) {
                await this.stripe.invoices.create({
                    customer: cid,
                    price: price_ids[i],
                    invoice: invoice.id,
                });
            }

            // Finalize the invoice.
            invoice = await this.stripe.invoices.finalizeInvoice(
                invoice.id,
                {
                    auto_advance: false,
                    expand: ["payment_intent"],
                }
            );

            // Update the payment intent.
            payment_intent = await this.stripe.paymentIntents.update(
                invoice.payment_intent.id,
                {
                    setup_future_usage: "off_session",
                    metadata: {
                        invoice: invoice.id,
                    },
                }
            );
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }

        // Response for frontend.
        return {
            id: invoice.id,
            client_secret: payment_intent.client_secret,
        };

        // V1 using a payment intent.

        // // Get products.
        // let price = 0, currency, meta_cart = [];
        // if (Array.isArray(products) === false) {

        //     // Check args.
        //     if (Array.isArray(product_ids) === false) {
        //         throw Error(`Parameter "product_ids" has an invalid value type "${typeof product_ids}", the valid value type is "array".`);
        //     } else if (product_ids.length === 0) {
        //         throw Error(`No product ids were specified.`);
        //     }

        //     // Get the products.
        //     products = [];
        //     product_ids.iterate((id) => {
        //         const found = this.payment_products.iterate((p) => {
        //             if (p.id === id) {
        //                 if (p.is_subscription) {
        //                     throw Error(`Product "${p.name}" is a subscription product.`);
        //                 }
        //                 else if (currency == null) {
        //                     currency = p.currency;
        //                 }
        //                 else if (currency !== p.currency) {
        //                     throw Error(`Products with different currencies can not be charged in a single request ("${currency}" and "${p.currency}").`);
        //                 }
        //                 meta_cart.push({product: p.id, price: p.price});
        //                 price += parseInt(p.price * 100);
        //                 products.push(p)
        //                 return true;
        //             }
        //         })
        //         if (found !== true) {
        //             throw Error(`Unknown product id "${id}".`);
        //         }
        //     })
        // }

        // // Check one-time products.
        // else {
        //     products.iterate((p) => {
        //         if (p.is_subscription) {
        //             throw Error(`Product "${p.name}" is a subscription product.`);
        //         }
        //         else if (currency == null) {
        //             currency = p.currency;
        //         }
        //         else if (currency !== p.currency) {
        //             throw Error(`Products with different currencies can not be charged in a single request ("${currency}" and "${p.currency}").`);
        //         }
        //         meta_cart.push({product: p.id, price: p.price});
        //         price += parseInt(p.price * 100);
        //     })
        // }

        // // Retrieve the cid from the user.
        // if (cid == null) {

        //     // Check uid.
        //     if (uid == null) {
        //         throw Error("One of the following parameters must be defined \"uid\" or \"cid\".");
        //     }

        //     // Load the user's email.
        //     email = (await this.get_user(uid)).email

        //     // Get the customer id.
        //     cid = await this._stripe_get_cid(uid);

        // }

        // // Retrieve the email when both the cid and uid are defined.
        // else if (uid != null && email == null) {
        //     email = (await this.get_user(uid)).email
        // }

        // // Check the email.
        // else if (email == null) {
        //     throw Error("Define parameter \"email\".");
        // }

        // // Create a description and statement descriptor.
        // let description, statement_descriptor;
        // if (products.length === 1) {
        //     description = products[0].description;
        //     statement_descriptor = products[0].statement_descriptor;
        // }

        // // Create a payment intent.
        // let result;
        // try {
        //     result = await this.stripe.paymentIntents.create({
        //         customer: cid,
        //         amount: price,
        //         currency: currency,
        //         receipt_email: email,
        //         description: description,
        //         statement_descriptor: statement_descriptor,
        //         setup_future_usage: "off_session",
        //         metadata: {
        //             cart: meta_cart,
        //             is_subscription: false,
        //         },
        //         automatic_payment_methods: {
        //             enabled: true,
        //         },
        //     });
        // } catch (error) {
        //     throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        // }

        // // Response for frontend.
        // return {
        //     id: result.id,
        //     client_secret: result.client_secret,
        // };
    }
    */

    // Make invoice.
    /*  @ docs {
     *  @title: Create Invoice
     *  @description:
     *      Create an invoice for one or multiple payment products.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: product_ids
     *      @description: The id's of the payment products.
     *      @type: array[string]
     *  }
     *  @type: object.
     *  @return: Returns an object with the client secret that should be passed to the frontend.
     *  @usage:
     *      ...
     *      server.create_payment(0, ["prod_basic"]);
     } 
    create_invoice(uid, product_ids) {

        // Get the products.
        const products = [];
        product_ids.iterate((id) => {
            const found = this.payment_products.iterate((product) => {
                if (product.id === id) {
                    if (product.recurring != null) {
                        throw Error(`Only one-time payment products can be passed to "create_payment()", product "${product.name}" is a subscription product.`);
                    }
                    products.push(product);
                    return true;
                }
            })
            if (found !== true) {
                throw Error(`Unknown product id "${id}".`);
            }
        })

        // Check the uid.
        this._check_uid_within_range(uid);

        // Get the stripe customer id.
        const cid = this._stripe_get_cid(uid);

        // Create an invoice.
        let invoice = await this.stripe.invoices.create({
            customer: cid,
            collection_method: "charge_automatically",
            days_until_due: 30,
            automatic_tax: {enabled: true},
        });

        // Add products to the invoice.
        products.iterate((product) => {
            await this.stripe.invoiceItems.create({
                customer: cid,
                price: product.price_id,
                description: product.description,
            });
        })

        // Finalize the invoice.
        invoice = await this.stripe.invoices.finalizeInvoice(invoice.id, {
            auto_advance: true,
        });

        // Retrieve the payment's intent client secret.
        const payment_intent = this.stripe.paymentIntents.retrieve(invoice.payment_intent);

        // Return the client secret to the frontend.
        return {
            client_secret: payment_intent.client_secret,
        }  
    }
    */
}

// ---------------------------------------------------------
// Exports.

module.exports = Server;
