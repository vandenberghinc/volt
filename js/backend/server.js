/*
 * Author: Daan van den Bergh
 * Copyright: © 2022 - 2023 Daan van den Bergh.
 */

// ---------------------------------------------------------
// Libraries.

const https = require("https");
const http = require("http");
const libcrypto = require("crypto");
const libnodemailer = require('nodemailer');

// ---------------------------------------------------------
// Imports.

const {vlib, vhighlight} = require("./vinc.js");
const Status = require("./status.js");
const Mutex = require("./mutex.js");
const Endpoint = require("./endpoint.js");
const Response = require("./response.js");
const Request = require("./request.js");
const FileWatcher = require("./file_watcher.js");

// ---------------------------------------------------------
// The server object.

class StripeError extends Error {
    constructor(message) {
        super(message);
    }
}

/*  @docs: {
 *  @chapter: Backend
 *  @title: Server
 *  @description: 
 *      The backend server class.
 *      When the https parameters `certificate` and `private_key` are defined, the server will run automatically on http and https.
 *  @parameter: {
 *      @name: production
 *      @description: Whether the server is in production more, or in development mode.
 *      @type: boolean
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: ip
 *      @description: The ip where the server will run on.
 *      @type: string
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: port
 *      @description: The port where the server will run on.
 *      @type: string
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: certificate
 *      @description: The path to the certificate.
 *      @type: string
 *  }
 *  @parameter: {
 *      @name: private_key
 *      @description: The path to the private key file.
 *      @type: string
 *  }
 *  @parameter: {
 *      @name: passphrase
 *      @description: The passphrase of the private key.
 *      @type: string
 *  }
 *  @parameter: {
 *      @name: domain
 *      @description: The full domain url without `http://` or `https://`.
 *      @type: string
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: statics
 *      @description: Array with path's to static directories.
 *      @type: array[string]
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: database
 *      @description: The path to the database directory.
 *      @type: string
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: default_headers
 *      @description: Used to override the default headers generated by vweb. Leave parameter `default_headers` as `null` to let vweb automatically generate the default headers.
 *      @type: object
 *  }
 *  @parameter: {
 *      @name: token_expiration
 *      @description: The token a sign in token will be valid in seconds.
 *      @type: number
 *  }
 *  @parameter: {
 *      @name: enable_2fa
 *      @description: Enable 2fa for user authentication.
 *      @type: boolean
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: enable_account_activation
 *      @description: Enable account activation by email after a user signs up.
 *      @type: boolean
 *      @required: true
 *  }
 *  @parameter: {
 *      @name: smtp_sender
 *      @description:
 *          The smtp sender address may either be a string with the email address, e.g. `your@email.com`.
 *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
 *      @type: string, array
 *  }
 *  @parameter: {
 *      @name: smtp
 *      @description:
 *          The smpt arguments object.
 *          More information about the arguments can be found at the nodemailer <link https://nodemailer.com/smtp/>documentation<link>.
 *      @type: object
 *  }
 *  @parameter: {
 *      @name: mail_body_2fa
 *      @description: The default 2fa mail body.
 *      @type: string
 *      @required: true
 *  }
 *  @parameter:
 *      @name: stripe_secret_key
 *      @type: string
 *      @description: The stripe secret key. Required to accept payments.
 *  @parameter:
 *      @name: payment_products
 *      @type: object
 *      @description: 
 *          The payment products or subscriptions.
 *
 *          When the payment products has a value defined for attribute `recurring` it will become a subscription instead of a one-time payment.
 *
 *          Warning: The stripe products that do not match any of the payment products' id's will be deactivated and all subscriptions cancelled.
 *
 *          Warning: The payment product objects are accessable by anyone through the backend rest api so they should not contain any sensitive data.
 *          
 *          A one-time payment product object looks like:
 *          ```js
 *          {
 *              id: "prod_premium",                 // an unique id across your entire stripe account. Warning: this id can never be changed. Or the old product will be deactivated from your stripe account.
 *              name: "Premium",                    // the name of the subscription.
 *              description: "...",                 // the description of the subscription.
 *              price: 9.99,                        // price in decimals.
 *              currency: "eur",                    // ISO currency code (lowercase)
 *              recurring: [1, "month"],            // (optional) the recurring interval count and format, should be defined for subscriptions.
 *              statement_descriptor: undefined,    // (optional) An arbitrary string to be displayed on your customer’s credit card or bank statement, max 22 chars long.
 *              tax_behavior: undefined,            // (optional) tax behavior.
 *              icon: undefined,                    // (optional) the absolute url to the products icon.
 *          }```
 *
 *          A subscription product looks like:
 *          ```js
 *          {
 *              plans: [{
 *                  id: "prod_premium",              // an unique id across your entire stripe account. Warning: this id can never be changed. Or the old product will be deactivated from your stripe account.
 *                  name: "Premium",                // the name of the subscription.
 *                  description: "...",             // the description of the subscription.
 *                  price: 9.99,                    // price in decimals.
 *              }],
 *              currency: "eur",                    // ISO currency code (lowercase)
 *              interval: "month",                  // the recurring interval format, the following values are supported `["day", "week", "month", "year"]`.
 *              interval_count: 1,                  // (optional) the recurring interval count, by default `1`.
 *              statement_descriptor: undefined,    // (optional) An arbitrary string to be displayed on your customer’s credit card or bank statement, max 22 chars long.
 *              tax_behavior: undefined,            // (optional) tax behavior.
 *              icon: undefined,                    // (optional) the absolute url to the products icon.
 *          }```
 *
 *          The following attributes may be defined in the subscription object and will be used for all the plan objects when the plan object's attribute is not defined.
 *          Or they may be defined for each plan to specify a unique value per plan.
 *              - name
 *              - description
 *              - currency
 *              - interval
 *              - interval_count
 *              - statement_descriptor
 *              - tax_behavior
 *              - icon
 *
 *          When the user purchases a subscription for one of the plans, the other active plans from that subscription will automatically be cancelled.
 *  @parameter:
 *      @name: payment_return_url
 *      @type: string
 *      @description: The absolute url where the user should be redirected to after a payment (e.g. https://mydomain.com/payments/redirect)
 *  @parameter: {
 *      @name: file_watcher
 *      @description: The file watcher arguments, define to enable file watching. The parameter may either be an FileWatcher object, an object with arguments or a string for the `source` argument.
 *      @type: FileWatcher, object, string.
 *  }
 } */
class Server {

    // Mimes for content type detection.
    // Must be defined before creating static endpoints.
    static content_type_mimes = [
        [".html", "text/html"],
        [".htm", "text/html"],
        [".shtml", "text/html"],
        [".css", "text/css"],
        [".xml", "application/xml"],
        [".gif", "image/gif"],
        [".jpeg", "image/jpeg"],
        [".jpg", "image/jpeg"],
        [".js", "application/javascript"],
        [".atom", "application/atom+xml"],
        [".rss", "application/rss+xml"],
        [".mml", "text/mathml"],
        [".txt", "text/plain"],
        [".jad", "text/vnd.sun.j2me.app-descriptor"],
        [".wml", "text/vnd.wap.wml"],
        [".htc", "text/x-component"],
        [".png", "image/png"],
        [".tif", "image/tiff"],
        [".tiff", "image/tiff"],
        [".wbmp", "image/vnd.wap.wbmp"],
        [".ico", "image/x-icon"],
        [".jng", "image/x-jng"],
        [".bmp", "image/x-ms-bmp"],
        [".svg", "image/svg+xml"],
        [".svgz", "image/svg+xml"],
        [".webp", "image/webp"],
        [".woff", "font/woff"],
        [".woff2", "font/woff2"],
        [".jar", "application/java-archive"],
        [".war", "application/java-archive"],
        [".ear", "application/java-archive"],
        [".json", "application/json"],
        [".hqx", "application/mac-binhex40"],
        [".doc", "application/msword"],
        [".pdf", "application/pdf"],
        [".ps", "application/postscript"],
        [".eps", "application/postscript"],
        [".ai", "application/postscript"],
        [".rtf", "application/rtf"],
        [".m3u8", "application/vnd.apple.mpegurl"],
        [".xls", "application/vnd.ms-excel"],
        [".eot", "application/vnd.ms-fontobject"],
        [".ppt", "application/vnd.ms-powerpoint"],
        [".wmlc", "application/vnd.wap.wmlc"],
        [".kml", "application/vnd.google-earth.kml+xml"],
        [".kmz", "application/vnd.google-earth.kmz"],
        [".7z", "application/x-7z-compressed"],
        [".cco", "application/x-cocoa"],
        [".jardiff", "application/x-java-archive-diff"],
        [".jnlp", "application/x-java-jnlp-file"],
        [".run", "application/x-makeself"],
        [".pl", "application/x-perl"],
        [".pm", "application/x-perl"],
        [".prc", "application/x-pilot"],
        [".pdb", "application/x-pilot"],
        [".rar", "application/x-rar-compressed"],
        [".rpm", "application/x-redhat-package-manager"],
        [".sea", "application/x-sea"],
        [".swf", "application/x-shockwave-flash"],
        [".sit", "application/x-stuffit"],
        [".tcl", "application/x-tcl"],
        [".tk", "application/x-tcl"],
        [".der", "application/x-x509-ca-cert"],
        [".pem", "application/x-x509-ca-cert"],
        [".crt", "application/x-x509-ca-cert"],
        [".xpi", "application/x-xpinstall"],
        [".xhtml", "application/xhtml+xml"],
        [".xspf", "application/xspf+xml"],
        [".zip", "application/zip"],
        [".bin", "application/octet-stream"],
        [".exe", "application/octet-stream"],
        [".dll", "application/octet-stream"],
        [".deb", "application/octet-stream"],
        [".dmg", "application/octet-stream"],
        [".iso", "application/octet-stream"],
        [".img", "application/octet-stream"],
        [".msi", "application/octet-stream"],
        [".msp", "application/octet-stream"],
        [".msm", "application/octet-stream"],
        [".docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
        [".xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
        [".pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
        [".mid", "audio/midi"],
        [".midi", "audio/midi"],
        [".kar", "audio/midi"],
        [".mp3", "audio/mpeg"],
        [".ogg", "audio/ogg"],
        [".m4a", "audio/x-m4a"],
        [".ra", "audio/x-realaudio"],
        [".3gpp", "video/3gpp"],
        [".3gp", "video/3gpp"],
        [".ts", "video/mp2t"],
        [".mp4", "video/mp4"],
        [".mpeg", "video/mpeg"],
        [".mpg", "video/mpeg"],
        [".mov", "video/quicktime"],
        [".webm", "video/webm"],
        [".flv", "video/x-flv"],
        [".m4v", "video/x-m4v"],
        [".mng", "video/x-mng"],
        [".asx", "video/x-ms-asf"],
        [".asf", "video/x-ms-asf"],
        [".wmv", "video/x-ms-wmv"],
        [".avi", "video/x-msvideo"],
    ]

    // Constructor.
    constructor({
        production = false,
        ip = "127.0.0.1",
        port = 8000,
        certificate = null,
        private_key = null,
        passphrase = null,
        domain = null,
        statics = [],
        database = null,
        default_headers = null,
        token_expiration = 86400,
        enable_2fa = false,
        enable_account_activation = true,
        smtp_sender = null,
        smtp = null,
        mail_body_2fa = "<p>Your 2FA code is: {{2FA}}.</p>",
        stripe_secret_key = null,
        payment_products = [],
        payment_return_url = null,
        file_watcher = null,
    }) {

        // Check args.
        if (typeof ip !== "string") {
            throw Error(`Parameter "ip" should be a defined value of type "string".`);
        }
        if (typeof port !== "number") {
            throw Error(`Parameter "port" should be a defined value of type "number".`);
        }
        // if (typeof certificate !== "string") {
        //     throw Error(`Parameter "certificate" should be a defined value of type "string".`);
        // }
        // if (typeof private_key !== "string") {
        //     throw Error(`Parameter "private_key" should be a defined value of type "string".`);
        // }
        if (typeof domain !== "string") {
            throw Error(`Parameter "domain" should be a defined value of type "string".`);
        }
        if (typeof database !== "string") {
            throw Error(`Parameter "database" should be a defined value of type "string".`);
        }
        // if (typeof smtp_sender !== "string" && !Array.isArray(smtp_sender)) {
        //     throw Error(`Parameter "smtp_sender" should database a defined value of type "string" or "array".`);
        // }
        // if (typeof smtp !== "object") {
        //     throw Error(`Parameter "smtp" should database a defined value of type "object".`);
        // }

        // Attributes.
        this.port = port;
        this.ip = ip;
        if (certificate != null) {
            this.certificate = new vlib.Path(certificate).load_sync('utf8');
        }
        if (private_key != null) {
            this.private_key = new vlib.Path(private_key).load_sync('utf8');
        }
        this.domain = domain;
        this.statics = statics.map((path) => new vlib.Path(path));
        this.database = new vlib.Path(database).abs();
        this.enable_2fa = enable_2fa;
        this.enable_account_activation = enable_account_activation;
        this.production = production;
        this.token_expiration = token_expiration;
        this.mail_body_2fa = mail_body_2fa;
        this.stripe_enabled = stripe_secret_key != null;
        if (stripe_secret_key != null) {
            this.stripe = require("stripe")(stripe_secret_key);
            if (payment_return_url == null) {
                throw Error("Define parameter \"payment_return_url\" to define an absolute url where the user should be redirected to after a payment.");
            }
        }
        this.payment_products = payment_products;
        this.payment_return_url = payment_return_url;

        // Default headers.
        if (default_headers === null) {
            this.default_headers = {
                "Vary": "Origin",
                "Referrer-Policy": "same-origin",
                "Access-Control-Allow-Methods": "GET, POST, PUT, PATCH, DELETE, OPTIONS",
                "X-XSS-Protection": "1; mode=block",
                "X-Content-Type-Options": "frame-ancestors 'none'; nosniff;",
                "X-Frame-Options": "DENY",
                "Strict-Transport-Security": "max-age=31536000",
                "Content-Security-Policy": 
                    "default-src 'self' js.stripe.com *.google-analytics.com https://my.spline.design; " +
                    "img-src 'self' *.google-analytics.com raw.githubusercontent.com www.w3.org; " +
                    "script-src 'self' 'unsafe-inline' js.stripe.com ajax.googleapis.com www.googletagmanager.com googletagmanager.com *.google-analytics.com raw.githubusercontent.com code.jquery.com; " +
                    "style-src 'self' 'unsafe-inline'; " +
                    "upgrade-insecure-requests; " +
                    "block-all-mixed-content;",
            }
        } else {
            this.default_headers = default_headers;
        }

        // Define your list of endpoints
        this.endpoints = [];

        // File watcher.
        if (file_watcher != null && process.env.VWEB_FILE_WATCHER != '1') {

            // Create default endpoints.
            let additional_paths = this._create_default_endpoints();

            // Create static endpoints.
            this.statics.iterate((path) => {
                additional_paths = additional_paths.concat(this._create_static_endpoints(path.base(), path));
            });

            // Add the vweb backend source files to the additional files.
            additional_paths.push(__dirname);

            // Initialize file watcher.
            if (typeof file_watcher === "string" || file_watcher instanceof vlib.Path) {
                this.file_watcher = new FileWatcher({source: file_watcher});
            }
            else if (file_watcher instanceof FileWatcher) {
                this.file_watcher = file_watcher;
            } else {
                this.file_watcher = new FileWatcher(file_watcher);
            }
            this.file_watcher.excluded.push(this.database.str());

            // Add default and static endpoints.
            this.file_watcher.additional_paths = additional_paths;
            
            // Start.
            this.file_watcher.start();
            return null;
        }

        // The smtp instance.
        this.smtp_enabled = smtp_sender !== null && typeof smtp === "object";
        if (this.smtp_enabled) {
            this.smtp_sender = smtp_sender;
            this.smtp = libnodemailer.createTransport(smtp);
        }
        
        // Create an HTTPS server
        if (this.private_key != null && this.certificate != null) {
            this.https = https.createServer({key: this.private_key, cert: this.certificate, passphrase: passphrase}, (request, response) => this._serve(request, response));
        }
        this.http = http.createServer((request, response) => this._serve(request, response));

        // Max uid.
        this.max_uid = null;
        this.edit_max_uid_mutex = new Mutex();

        // The master sha256 hash key.
        this.hash_key = null;
    }

    // ---------------------------------------------------------
    // Utils (private).

    // Iterate a subpath directory in the database.
    _iter_db_dir(subpath, callback) {
        this.database.join(subpath).paths_sync().iterate_async_await((path) => {
            if (path.name() !== ".DS_Store") {
                return callback(path);
            }
        });
    }

    // Check of the uid is within the max uid range.
    _check_uid_within_range(uid) {
        if (uid == null || uid < 0 || uid == "") {
            throw Error("Undefined user id.");
        }
        else if (uid > this.max_uid) {
            throw Error(`User id "${uid}" does not exist.`);
        }
    }

    // Get a content type from an extension.
    _sys_get_content_type(extension) {
        let content_type = Server.content_type_mimes.iterate((item) => {
            if (item[0] == extension) {
                return item[1];
            }
        })
        if (content_type == null) {
            content_type = "application/octet-stream";
        }
        return content_type;
    }

    // Generate a key.
    _sys_generate_key(path) {
        const length = 32;
        const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        let key = "";
        for (let i = 0; i < length; i++) {
            key += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        return key;
    }

    // Generate a crypto key.
    _sys_generate_crypto_key(length = 32) {
        return libcrypto.randomBytes(length).toString('hex');
    }

    // Generate a 2fa code.
    _sys_generate_2fa(path) {
        const length = 6;
        const charset = "0123456789";
        let key = "";
        for (let i = 0; i < length; i++) {
            key += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        return key;
    }

    // Load data into an object formatted line by line.
    // All data will be loaded as a string.
    // When the path does not exists the input object will be returned.
    _sys_load_data_into_obj(path, obj = {}, keys = []) {
        if (!path.exists()) {
            return obj;
        }
        const data = path.load_sync();
        let key = 0;
        const info = {line: "", line_number: 0}
        for (let i = 0; i < data.length; i++) {
            const c = data.charAt(i);
            if (c == '\n') {
                if (obj[keys[key]] == null) {
                    obj[keys[key]] = "";
                }
                ++key;
            } else {
                if (obj[keys[key]] == null) {
                    obj[keys[key]] = "";
                }
                obj[keys[key]] += c;
            }
        }
        // for (let i = key; i < keys.length; i++) {
        //     obj[keys[i]] = "";
        // }
        return obj;
    }

    // Save an object to data formatted line by line.
    _sys_save_data_into_obj(path, obj, keys) {
        let data = "";
        for (let i = 0; i < keys.length; i++) {
            if (typeof obj[keys[i]] === "string") {
                data += obj[keys[i]];
            } else {
                data += obj[keys[i]].toString();
            }
            data += "\n";
        }
        path.save_sync(data);
    }

    // Save or delete uid by username,
    _sys_save_uid_by_username(uid, username) {
        this.database.join(`.sys/usernames/${username}`, false).save_sync(uid.toString());
    }
    _sys_delete_uid_by_username(username) {
        this.database.join(`.sys/usernames/${username}`, false).del_sync();
    }

    // Save or delete uid by email,
    _sys_save_uid_by_email(uid, email) {
        this.database.join(`.sys/emails/${email}`, false).save_sync(uid.toString());
    }
    _sys_delete_uid_by_email(email) {
        this.database.join(`.sys/emails/${email}`, false).del_sync();
    }

    /*  Save, load or delete a system user object.
        An object has the following keys if the user is not deleted: 
        {
            first_name: string,
            last_name: string,
            username: string,
            email: string,
            password: string,
            api_key: string,
        }
     */
    _sys_load_user(uid) {
        return this._sys_load_data_into_obj(this.database.join(`.sys/users/${uid}`, false), {uid: uid}, [
            "first_name",
            "last_name",
            "username",
            "email",
            "password",
            "api_key",
        ]);
    }
    _sys_save_user(uid, user) {
        return this._sys_save_data_into_obj(
            this.database.join(`.sys/users/${uid}`, false), 
            user, 
            [
                "first_name",
                "last_name",
                "username",
                "email",
                "password",
                "api_key",
            ],
        );
    }

    // @todo the parameter requires the full sys user object.
    _sys_delete_user(user) {
        throw Error("@todo the parameter requires the full sys user object.");
        this.database.join(`.sys/users/${user.uid}`, false).del_sync();
        this._sys_delete_uid_by_username(user.username);
        this._sys_delete_uid_by_email(user.email);
    }

    /*  Save, load or delete a system user token object used for signin in.
        An object has the following keys if the token exists:
        {
            expiration: number,
            token: string,
        }
     */
    _sys_load_user_token(uid) {
        const obj = this._sys_load_data_into_obj(this.database.join(`.sys/tokens/${uid}`, false), {expiration: 0}, [
            "expiration",
            "token",
        ]);
        if (typeof obj.expiration === "string") {
            obj.expiration = parseInt(obj.expiration);
        }
        return obj;
    }
    _sys_save_user_token(uid, token) {
        return this._sys_save_data_into_obj(
            this.database.join(`.sys/tokens/${uid}`, false), 
            token,
            [
               "expiration",
                "token",
            ],
        );
    }
    _sys_delete_user_token(uid) {
        this.database.join(`.sys/tokens/${uid}`, false).del_sync();
    }

    /*  Save, load or delete a system user 2fa object used for two factor authentication.
        An object has the following keys if the token exists:
        {
            expiration: number,
            code: string,
        }
     */
    _sys_load_user_2fa(uid) {
        const obj = this._sys_load_data_into_obj(this.database.join(`.sys/2fa/${uid}`, false), {expiration: 0}, [
            "expiration",
            "code",
        ]);
        if (typeof obj.expiration === "string") {
            obj.expiration = parseInt(obj.expiration);
        }
        return obj;
    }
    _sys_save_user_2fa(uid, token) {
        return this._sys_save_data_into_obj(
            this.database.join(`.sys/2fa/${uid}`, false), 
            token,
            [
                "expiration",
                "code",
            ]
        );
    }
    _sys_delete_user_2fa(uid) {
        this.database.join(`.sys/2fa/${uid}`, false).del_sync();
    }

    // Create a sha hmac with the master key.
    _hmac(data) {
        const hmac = libcrypto.createHmac("sha256", this.hash_key);
        hmac.update(data);
        return hmac.digest("hex");
    }

    // ---------------------------------------------------------
    // Authentication (private).

    // Generate a token by uid.
    _generate_token(uid) {
        this._check_uid_within_range(uid);
        const token = `1${uid}:${this._sys_generate_key()}`;
        this._sys_save_user_token(uid, {
            expiration: Date.now() + this.token_expiration * 1000,
            token: this._hmac(token),
        });
        return token;
    }

    // Perform authentication on a request.
    // When the authentication has failed an args object for response.send will be returned.
    // On a successfull authentication `null` will be returned.
    _authenticate(request) {

        // // Get api key key from bearer.
        const authorization = request.headers["Authorization"];
        if (authorization !== undefined) {
            if (typeof authorization !== "string") {
                return {
                    status: 400, 
                    data: "Bad Request: Invalid authorization header.",
                };
            }
            if (!authorization.eq_first("Bearer ")) {
                return {
                    status: 400, 
                    data: "Bad Request: Invalid authorization scheme, the authorization scheme must be \"Bearer\".",
                };
            }
            let api_key = "";
            for (let i = 7; i < authorization.length; i++) {
                const c = authorization[i];
                if (c == " ") {
                    continue;
                }
                api_key += c;
            }
            const uid = this.get_uid_by_api_key(api_key);
            if (!this.verify_api_key_by_uid(uid, api_key)) {
                return {
                    status: 401, 
                    data: "Unauthorized.",
                };

            }
            request.uid = uid;
            return true;
        }

        // Get token from cookies.
        else {
            if (request.cookies.T == null || request.cookies.T.value == null) {
                return {
                    status: 302, 
                    headers: {"Location": `/signin?next=${request.url}`},
                    data: "Permission denied.",
                };
            }
            const token = request.cookies.T.value;
            const uid = this.get_uid_by_api_key(token);
            if (!this.verify_token_by_uid(uid, token)) {
                return {
                    status: 302, 
                    headers: {"Location": `/signin?next=${request.url}`},
                    data: "Permission denied.",
                };

            }
            request.uid = uid;
            return null;
        }

        // Authentication failed.
        return {
            status: 302, 
            headers: {"Location": `/signin?next=${request.url}`},
            data: "Permission denied.",
        };
    }

    // Sign a user in and return a response.
    _sign_in_response(response, uid) {

        // Generate token.
        const token = this._generate_token(uid);
        
        // Create headers.
        this._create_token_cookie(response, token);
        this._create_user_cookie(response, uid);
        this._create_detailed_user_cookie(response, uid);
            
        // Response.
        response.send({
            status: 200,
            data: {message: "Successfully signed in."}
        });
    }

    // ---------------------------------------------------------
    // Headers (private).

    // Add header defaults.
    _set_header_defaults(response) {
        response.set_headers(this.default_headers);
        // if (this.domain != null) {
        //     response.set_header("Origin", this.domain);
        //     response.set_header("Access-Control-Allow-Origin", this.domain);
        // }
    }
    
    // Create token headers.
    //  - Should be called when generating a token.
    _create_token_cookie(response, token) {
        response.set_header("Cache-Control", "max-age=0, no-cache, no-store, must-revalidate, proxy-revalidate");
        response.set_header("Access-Control-Allow-Credentials", "true");
        let expires = new Date(new Date().getTime() + this.token_expiration * 1000);
        if (typeof token === "object") {
            token = token.token;
        }
        response.set_cookie(`T=${token}; Max-Age=86400; Path=/; Expires=${expires.toUTCString()}; SameSite=Strict; Secure; HttpOnly;`);
    }
    
    // Create user headers.
    //  - Should be called when a user is authenticated.
    _create_user_cookie(response, uid) {
        if (uid != null && uid >= 0 && uid <= this.max_uid) {
            response.set_cookie(`UserID=${uid}; Path=/; SameSite=Strict; Secure;`);
            const is_activated = this.enable_account_activation ? this.is_activated(uid) : true;
            response.set_cookie(`UserActivated=${is_activated}; Path=/; SameSite=Strict; Secure;`);
        } else {
            response.set_cookie(`UserID=-1; Path=/; SameSite=Strict; Secure;`);
            const is_activated = this.enable_account_activation ? false : true;
            response.set_cookie(`UserActivated=${is_activated}; Path=/; SameSite=Strict; Secure;`);
        }
    }
    
    // Create user headers.
    //  - Should be called when a user has just signed in, signed up or changed their account.
    _create_detailed_user_cookie(response, uid) {
        const user = this.get_user(uid);
        response.set_cookie(`UserName=${user.username}; Path=/; SameSite=Strict; Secure;`);
        response.set_cookie(`UserFirstName=${user.first_name} Path=/; SameSite=Strict; Secure;`);
        response.set_cookie(`UserLastName=${user.last_name}; Path=/; SameSite=Strict; Secure;`);
        response.set_cookie(`UserEmail=${user.email}; Path=/; SameSite=Strict; Secure;`);
    }
    
    // Reset all default cookies.
    // - Should be called when a user signs out.
    _reset_cookies(response) {
        response.set_cookie("T=; Path=/; SameSite=Strict; Secure; HttpOnly;");
        response.set_cookie("UserID=-1; Path=/; SameSite=Strict; Secure;");
        response.set_cookie("UserActivated=false; Path=/; SameSite=Strict; Secure;");
        // response.set_cookie("2FAUserID=-1; Path=/; SameSite=Strict; Secure;");
        response.set_cookie("UserName=; Path=/; SameSite=Strict; Secure;");
        response.set_cookie("UserFirstName=; Path=/; SameSite=Strict; Secure;");
        response.set_cookie("UserLastName=; Path=/; SameSite=Strict; Secure;");
        response.set_cookie("UserEmail=; Path=/; SameSite=Strict; Secure;");
    }

    // ---------------------------------------------------------
    // Endpoints (private).

    // Find endpoint.
    _find_endpoint(endpoint, method = null) {
        return this.endpoints.iterate((end) => {
            if (end.endpoint == endpoint && (method == null || method == end.method)) {
                return endpoint;
            }
        })
    }

    // Create static endpoints.
    _create_static_endpoints(base, dir) {
        const exclude = [".DS_Store"]
        let paths = [];
        dir.paths_sync().iterate((path) => {

            // Excluded.
            if (exclude.includes(path.name())) {
                return null;
            }

            // Add to paths.
            paths.push(path.str());

            // Read dir recursively.
            if (path.is_dir()) {
                paths = paths.concat(this._create_static_endpoints(base, path));
            }

            // Add file.
            else {
                let subpath = path.str().substr(base.length)
                if (subpath.charAt(0) != "/") {
                    subpath = "/" + subpath;
                }
                let data;
                if (path.extension() === ".js") {
                    data = path.load_sync();
                    const compiler = new vhighlight.JSCompiler({
                        line_breaks: true,
                        double_line_breaks: false,
                        comments: false,
                        white_space: false,
                    })
                    data = compiler.compile_code(data, path.str());
                } else {
                    data = path.load_sync({type: null});
                }
                this.endpoint(new Endpoint({
                    method: "GET",
                    endpoint: subpath,
                    data: data,
                    content_type: this._sys_get_content_type(path.extension())
                }))
            }
        })
        return paths;
    }

    // Create default endpoints.
    _create_default_endpoints() {

        // Default static endpoints.
        const defaults = [
            {
                method: "GET",
                endpoint: "/vweb/vweb.css",
                content_type: "text/css",
                path: new vlib.Path(`${__dirname}/../frontend/css/vweb.css`),
            },
            {
                method: "GET",
                endpoint: "/vweb/vweb.js",
                content_type: "application/javascript",
                path: new vlib.Path(`${__dirname}/../frontend/vweb.js`),
            },
            {
                method: "GET",
                endpoint: "/vhighlight/vhighlight.css",
                content_type: "text/css",
                path: new vlib.Path(vhighlight.web_exports.css),
            },
            {
                method: "GET",
                endpoint: "/vhighlight/vhighlight.js",
                content_type: "application/javascript",
                path: new vlib.Path(vhighlight.web_exports.js),
            },
        ]
        const additional_file_watcher_paths = [];
        defaults.iterate((item) => {
            this.endpoint(new Endpoint({
                method: item.method,
                endpoint: item.endpoint,
                data: item.path.load_sync(),
                content_type: item.content_type,
                compress: item.compress,
            }))
            additional_file_watcher_paths.push(item.path.str());
        })


        // ---------------------------------------------------------
        // Default auth endpoints.
        
        this.endpoint(
            
            // Send 2fa.
            {
                method: "GET",
                endpoint: "/vweb/backend/auth/2fa",
                content_type: "application/json",
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    
                    // Get params.
                    let email;
                    try {
                        email = request.param("email")
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Get uid.
                    let uid;
                    if ((uid = this.get_uid_by_email(email)) == null) {
                        return response.success({
                            data: {message: "A 2FA code was sent if the specified email exists."},
                        });
                    }
                    
                    // Send.
                    this.send_2fa({uid:uid, request:request});
                    return response.success({
                        data: {message: "A 2FA code was sent if the specified email exists."},
                    });
                    
                }
            },
        
            // Sign in.
            {
                method: "POST",
                endpoint: "/vweb/backend/auth/signin",
                content_type: "application/json",
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {

                    // Get params.
                    let email, email_err, username, username_err, password, uid, code;
                    try {
                        email = request.param("email")
                    } catch (err) {
                        email_err = err;
                    }
                    try {
                        username = request.param("username")
                    } catch (err) {
                        username_err = err;
                    }
                    if (email_err && username_err) {
                        return response.error({status: Status.bad_request, data: {error: email_err.message}});
                    }
                    try {
                        password = request.param("password")
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Get uid.
                    if (email) {
                        if ((uid = this.get_uid_by_email(email)) == null) {
                            return response.error({
                                status: Status.unauthorized,
                                data: {error: "Unauthorized."}
                            });
                        }
                    } else {
                        if ((uid = this.get_uid(username)) == null) {
                            return response.error({
                                status: Status.unauthorized,
                                data: {error: "Unauthorized."}
                            });
                        }
                    }
                    
                    // Verify password.
                    if (this.verify_password(uid, password)) {
                        
                        // Verify 2fa.
                        if (this.enable_2fa) {

                            // Get 2FA.
                            try {
                                code = request.param("2fa")
                            } catch (err) {
                                this.send_2fa({uid:uid, request:request});
                                return response.send({
                                    status: Status.two_factor_auth_required,
                                    data: {error: "2FA required."}
                                });
                            }

                            // Verify 2FA.
                            if (!this.verify_2fa(uid, code)) {
                                return response.send({
                                    status: Status.unauthorized,
                                    data: {error: "Invalid 2FA code."}
                                });
                            }
                        }
                        
                        // Sign in.
                        return this._sign_in_response(response, uid);
                    }

                    // Unauthorized.
                    return response.send({
                        status: Status.unauthorized,
                        data: {error: "Unauthorized."}
                    });
                }
            },
        
            // Sign out.
            {
                method: "POST",
                endpoint: "/vweb/backend/auth/signout",
                content_type: "application/json",
                authenticated: true,
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    
                    // Delete token.
                    this._sys_delete_user_token(request.uid);
                    
                    // Create headers.
                    this._reset_cookies(response);
                    
                    // Response.
                    return response.success({
                        data: {message: "Successfully signed out."},
                    })
                }
            },
        
            // Sign up.
            {
                method: "POST",
                endpoint: "/vweb/backend/auth/signup",
                content_type: "application/json",
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: async (request, response) => {
                    
                    // Get params.
                    let first_name, last_name, username, email, pass, verify_pass;
                    try {
                        username = request.param("username");
                        first_name = request.param("first_name");
                        last_name = request.param("last_name");
                        email = request.param("email");
                        pass = request.param("password");
                        verify_pass = request.param("verify_password");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Verify password.
                    if (pass != verify_pass) {
                        return response.error({
                            status: Status.bad_request,
                            data: {error: "Passwords do not match."}
                        });
                    }
                    
                    // Create.
                    let uid;
                    try {
                        uid = await this.create_user({
                            first_name: first_name,
                            last_name: last_name,
                            username: username,
                            email: email,
                            password: pass
                        });
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Send 2fa code for activation.
                    if (this.enable_account_activation) {
                        this.send_2fa({uid:uid, request:request});
                    }
                    
                    // Sign in.
                    return this._sign_in_response(response, uid);
                    
                }
            },
        
            // Activate account.
            {
                method: "POST",
                endpoint: "/vweb/backend/auth/activate",
                content_type: "application/json",
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    
                    // Vars.
                    let uid = request.uid;
                    
                    // Get uid by cookie.
                    if (uid == null) {
                        const value = request.cookies["UserID"].value;
                        if (value != null && value != "-1") {
                            uid = parseInt(value);
                            if (isNaN(uid)) {
                                uid = null;
                            }
                        }
                    }
                    
                    // Check uid.
                    if (uid == null) {
                        return response.error({status: Status.forbidden, data: {error: "Permission denied."}});
                    }
                    
                    // Get param.
                    let code;
                    try {
                        code = request.param("2fa");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }

                    // Verify.
                    if (this.verify_2fa(uid, code)) {
                        
                        // Set activated.
                        this.set_activated(uid, true);
                        
                        // Response.
                        this._create_user_cookie(response, uid);
                        return response.success({data: {message: "Successfully verified the 2FA code."}});
                    }
                    
                    // Invalid code.
                    else {
                        return response.error({status: Status.forbidden, data: {error: "Permission denied."}});
                    }
                }
            },
        
            // Forgot password.
            {
                method: "POST",
                endpoint: "/vweb/backend/auth/forgot_password",
                content_type: "application/json",
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    
                    // Get params.
                    let email, code, pass, verify_pass;
                    try {
                        email = request.param("email");
                        code = request.param("2fa");
                        pass = request.param("password");
                        verify_pass = request.param("verify_password");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Verify password.
                    if (pass != verify_pass) {
                        return response.error({status: Status.bad_request, data: {error: "Passwords do not match."}});
                    }
                    
                    // Get uid.
                    let uid;
                    if ((uid = this.get_uid_by_email(email)) == null) {
                        return response.error({status: Status.forbidden, data: {error: "Permission denied."},});
                    }
                    
                    // Verify 2fa.
                    if (!this.verify_2fa(uid, code)) {
                        return response.error({status: Status.forbidden, data: {error: "Invalid 2FA code."},});
                    }
                    
                    // Set password.
                    this.set_password(uid, pass);
                    
                    // Sign in.
                    return this._sign_in_response(response, uid);
                }
            },
        )
        
        // ---------------------------------------------------------
        // Default user endpoints.

        this.endpoint(
        
            // Get user.
            {
                method: "GET",
                endpoint: "/vweb/backend/user",
                content_type: "application/json",
                authenticated: true,
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    return response.success({data: this.get_user(request.uid)});
                }
            },

            // Set user.
            {
                method: "POST",
                endpoint: "/vweb/backend/user",
                authenticated: true,
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    this.set_user(request.uid, request.params);
                    this._create_detailed_user_cookie(response, request.uid);
                    return response.success({data: {message: "Successfully updated your account."}});
                }
            },
        
            // Change password.
            {
                method: "POST",
                endpoint: "/vweb/backend/user/change_password",
                authenticated: true,
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    
                    // Get params.
                    let current_pass, pass, verify_pass;
                    try {
                        current_pass = request.param("current_password");
                        pass = request.param("password");
                        verify_pass = request.param("verify_password");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    
                    // Verify old password.
                    if (!this.verify_password(request.uid, current_pass)) {
                        return response.error({
                            status: Status.unauthorized,
                            data: {error: "Incorrect password."},
                        });
                    }
                    
                    // Verify new password.
                    if (pass != verify_pass) {
                        return response.error({
                            status: Status.bad_request,
                            data: {error: "Passwords do not match."},
                        });
                    }
                    
                    // Set password.
                    this.set_password(request.uid, pass);
                    
                    // Success.
                    return response.success({
                        status: Status.success,
                        data: {message: "Successfully updated your password."},
                    });
                }
            },
        
            // Generate api key.
            {
                method: "POST",
                endpoint: "/vweb/backend/user/api_key",
                authenticated: true,
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    return response.success({
                        data: {
                            "message": "Successfully generated an API key.",
                            "api_key": this.generate_api_key(request.uid),
                        }
                    });
                }
            },
        
            // Revoke api key.
            {
                method: "DELETE",
                endpoint: "/vweb/backend/user/api_key",
                authenticated: true,
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    this.revoke_api_key(request.uid);
                    return response.send({
                        status: Status.success,
                        data: {message: "Successfully revoked your API key."},
                    });
                }
            },
            
            // Load data.
            {
                method: "GET",
                endpoint: "/vweb/backend/user/data",
                authenticated: true,
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    let path, def;
                    try {
                        path = request.param("path");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    try {
                        def = request.param("default");
                    } catch (err) {
                        def = null;
                    }
                    try {
                        return response.send({
                            status: Status.success,
                            data: this.load_user_data(request.uid, path, def)
                        });
                    } catch (err) {
                        return response.error({status: Status.internal_server_error, data: {error: err.message}});
                    }
                }
            },
        
            // Save data.
            {
                method: "POST",
                endpoint: "/vweb/backend/user/data",
                authenticated: true,
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    let path, data;
                    try {
                        path = request.param("path");
                        data = request.param("data");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    try {
                        this.save_user_data(request.uid, path, data);
                    } catch (err) {
                        return response.error({status: Status.internal_server_error, data: {error: err.message}});
                    }
                    return response.send({
                        status: Status.success,
                        data: {message: "Successfully saved."},
                    });
                }
            },

            // Load proteced data.
            {
                method: "GET",
                endpoint: "/vweb/backend/user/data/protected",
                authenticated: true,
                rate_limit: 10,
                rate_limit_duration: 60,
                callback: (request, response) => {
                    let path, def;
                    try {
                        path = request.param("path");
                    } catch (err) {
                        return response.error({status: Status.bad_request, data: {error: err.message}});
                    }
                    try {
                        def = request.param("default");
                    } catch (err) {
                        def = null;
                    }
                    try {
                        return response.send({
                            status: Status.success,
                            data: this.load_protected_user_data(request.uid, path, def)
                        });
                    } catch (err) {
                        return response.error({status: Status.internal_server_error, data: {error: err.message}});
                    }
                }
            },
        )

        // ---------------------------------------------------------
        // Payments endpoints.
        if (this.stripe_enabled) {
            this.endpoint(
            
                // Get products.
                {
                    method: "GET",
                    endpoint: "/vweb/backend/payments/products",
                    content_type: "application/json",
                    rate_limit: 10,
                    rate_limit_duration: 60,
                    callback: (request, response) => {
                        return response.success({data: this.payment_products});
                    }
                },

                // Charge a shopping cart.
                {
                    method: "POST",
                    endpoint: "/vweb/backend/payments/charge",
                    content_type: "application/json",
                    rate_limit: 10,
                    rate_limit_duration: 60,
                    callback: async (request, response) => {

                        // Get shopping cart.
                        let cart;
                        try {
                            cart = request.param("cart", "array");
                        } catch (err) {
                            return response.error({status: Status.bad_request, data: {error: err.message}});
                        }

                        // Create a customer or retrieve the customer id from the signed in user.
                        let cid, email, first_name, last_name;
                        if (request.uid != null) {
                            this._check_uid_within_range(request.uid);
                            cid = await this._get_stripe_cid(request.uid)
                        } else {
                            try {
                                email = request.param("email");
                                first_name = request.param("first_name");
                                last_name = request.param("last_name");
                            } catch (err) {
                                return response.error({status: Status.bad_request, data: {error: err.message}});
                            }
                            cid = await this._create_stripe_customer(email, `${first_name} ${last_name}`).id;
                        }

                        // Check the shopping cart.
                        let is_subscription = null;
                        const products = [];
                        cart.iterate((item) => {
                            if (is_subscription === null) {
                                is_subscription = item.product.is_subscription;
                            }
                            else if (is_subscription != item.product.is_subscription) {
                                return response.error({
                                    status: Status.bad_request,
                                    error: "Subscription and one-time payment products can not be charged in one request.",
                                })
                            }
                            for (let i = 0; i < item.quantity; i++) {
                                products.push(item.product);
                            }
                        })

                        // Charge the shopping cart.
                        let result;
                        if (is_subscription) {
                            if (products.length > 1) {
                                throw Error("Only one subscription can be charged at the time.");
                            }
                            result = await this.create_subscription({
                                uid: request.uid,
                                cid: cid,
                                product: cart[0].product,
                            })
                        } else {
                            result = await this.create_payment({
                                uid: request.uid,
                                cid: cid,
                                products: products,
                                email: email,
                            })
                        }

                        // Handle the result.
                        if (result.error) {
                            return response.error({
                                status: Status.bad_request,
                                data: result,
                            })
                        } else {
                            return response.success({
                                data: {
                                    return_url: this.payment_return_url,
                                    ...result,
                                }
                            })
                        }
                    }
                },

                // Get the status of a payment intent.
                // {
                //     method: "GET",
                //     endpoint: "/vweb/backend/payments/charge/status",
                //     content_type: "application/json",
                //     rate_limit: 10,
                //     rate_limit_duration: 60,
                //     callback: async (request, response) => {

                //         // Get shopping cart.
                //         let payment_intent_id;
                //         try {
                //             payment_intent_id = request.param("payment_intent");
                //         } catch (err) {
                //             return response.error({status: Status.bad_request, data: {error: err.message}});
                //         }

                //         // Get payment intent.
                //         let payment_intent;
                //         try {
                //             payment_intent = await this.stripe.paymentIntents.retrieve(payment_intent_id);
                //         } catch (error) {
                //             throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
                //         }

                //         // Send result.
                //         return response.success({
                //             data: {
                //                 status: payment_intent.status,
                //                 payment_intent: payment_intent,
                //             }
                //         })
                //     }
                // },
            );
        }

        // Handler.
        return additional_file_watcher_paths;
    }

    // Create the sitemap endpoint.
    _create_sitemap() {
        let sitemap = "";
        sitemap += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        sitemap += "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n";
        this.endpoints.iterate((endpoint) => {
            if (
                endpoint.data == null &&
                endpoint.callback == null &&
                endpoint.endpoint != "robots.txt" &&
                !endpoint.authenticated
            ) {
                sitemap += `<url>\n   <loc>${endpoint.endpoint}</loc>\n</url>\n`;
            }
        })
        sitemap += "</urlset>\n";
        this.endpoint(new Endpoint({
            method: "GET",
            endpoint: "/sitemap.xml",
            data: sitemap,
            content_type: "application/xml",
            compress: false,
        }))
    }

    // Create the robots.txt endpoint.
    _create_robots_txt() {
        this.endpoint(new Endpoint({
            method: "GET",
            endpoint: "/robots.txt",
            content_type: "text/plain",
            data: `User-agent: *\nDisallow: \n\nSitemap: /sitemap.xml`,
            compress: false,
        }))
    }

    // ---------------------------------------------------------
    // Stripe (private).
    /* 
        Sources: 
            * https://stripe.com/docs/api/prices?lang=node
            * https://stripe.com/docs/api/subscriptions/create?lang=node
            * https://stripe.com/docs/payments/accept-a-payment?platform=web&ui=elements&client=html
            * https://stripe.com/docs/billing/subscriptions/build-subscriptions?ui=elements
     */

    // Check if a uid has a stripe customer id.
    _sys_has_stripe_cid(uid) {
        return this.database.join(`.sys/stripe_cids/${uid}`, false).exists();
    }

    // Load, save or delete stripe customer id by uid.
    _sys_load_stripe_cid(uid, customer_id) {
        return this.database.join(`.sys/stripe_cids/${uid}`, false).load_sync();
    }
    _sys_save_stripe_cid(uid, customer_id) {
        this.database.join(`.sys/stripe_cids/${uid}`, false).save_sync(customer_id);
    }
    _sys_delete_stripe_cid(customer_id) {
        this.database.join(`.sys/stripe_cids/${uid}`, false).del_sync();
    }

    // Get the stripe customer id of a uid, or a create a stripe customer when the uid does not yet have a stripe customer id.
    async _get_stripe_cid(uid) {
        if (this._sys_has_stripe_cid(uid)) {
            return this._sys_load_stripe_cid(uid);
        }
        const user = this.get_user(uid);
        const customer = await this._create_stripe_customer(user.email, `${user.first_name} ${user.last_name}`);
        this._sys_save_stripe_cid(uid, customer.id);
        return customer.id;
    }

    // Create a stripe customer without any user attached.
    async _create_stripe_customer(email, full_name) {
        try {
            return await this.stripe.customers.create({
                email: email,
                name: full_name,
            });
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Get a product by id.
    // Throws an error when the product was not found.
    _get_payment_product_by_id(id) {
        return this.payment_products.iterate((p) => {
            if (p.is_subscription) {
                if (p.id === id) {
                    return p;
                }
                return p.plans.iterate((plan) => {
                    if (plan.id === id) {
                        return plan;
                    }
                })
            }
            else if (p.id === id) {
                return p;
            }
        })
    }

    // Delete a stripe customer.
    async _delete_stripe_customer(uid) {
        if (this._sys_has_stripe_cid(uid)) {
            let result;
            try {
                result = await this.stripe.customers.del(this._sys_load_stripe_cid(uid));
            } catch (error) {
                throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
            }
            if (result.deleted !== true) {
                throw Error(`Failed to delete the stripe customer object for user "${uid}".`);
            }
            this._sys_delete_stripe_cid(uid);
        }
    }

    // Update the name and email address of a stripe customer.
    async _update_stripe_customer(uid, user) {
        if (this._sys_has_stripe_cid(uid)) {
            const cid = this._sys_load_stripe_cid(uid);
            try {
                await this.stripe.customers.update(
                    cid, 
                    {
                        email: user.email,
                        name: `${user.first_name} ${user.last_name}`,
                    }
                );
            } catch (error) {
                throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
            }
        }
    }

    // Update a price.
    async _get_price(price_id) {
        try {
            return await this.stripe.prices.retrieve(price_id);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Deactivate a price.
    // Prices cant be correctly updated with recurring or prices so when a product price has been edited a new price object should be created.
    // @note: When a price is deactivated all subscriptions linked to this price will automatically be cancelled.
    async _deactivate_price(price_id) {
        await this._cancel_all_subscriptions(price_id)
        try {
            return await this.stripe.prices.update(price_id, {
                active: false,
            });
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Create a price for a product.
    async _create_price(product) {
        try {
            const result = await this.stripe.prices.create({
                currency: product.currency,
                unit_amount_decimal: Math.round(product.price * 100),
                tax_behavior: product.tax_behavior,
                recurring: product.is_subscription ? {
                    interval: product.interval,
                    interval_count: product.interval_count,
                } : undefined,
                product: product.id,
            });
            product.price_id = result.id;
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Get a product by stripe subscription id.
    async _get_product(product_id) {
        try {
            return await this.stripe.products.retrieve(product_id);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Get all products.
    async _get_products() {
        try {
            const result = await this.stripe.products.list();
            if (Array.isArray(result.data)) {
                return result.data;
            }
            return [];
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Create a product.
    async _create_product(product) {
        try {
            const result = await this.stripe.products.create({
                id: product.id,
                name: product.name,
                description: product.description,
                statement_descriptor: product.statement_descriptor,
                default_price_data: {
                    currency: product.currency,
                    unit_amount_decimal: Math.round(product.price * 100),
                    tax_behavior: product.tax_behavior,
                    recurring: product.is_subscription ? {
                        interval: product.interval,
                        interval_count: product.interval_count,
                    } : undefined,
                },
            });
            product.price_id = result.default_price;
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Update a product.
    // @warning: When the second argument "stripe_product" is undefined, then this function will assume the stripe product does not exist and a new product will be created.
    async _update_product(product, stripe_product) {

        // When the stripe product does not yet exist.
        if (stripe_product === undefined) {
            await this._create_product(product);
        }

        // When the stripe product already exists.
        else {

            // Vars.
            let stripe_price;
            const has_no_price = stripe_product.default_price == null;
            let update_price = false;

            // Check if the price object should be updated.
            if (has_no_price === false) {
                update_price = await (async () => {

                    // Fetch the price object.
                    stripe_price = await this._get_price(stripe_product.default_price);

                    // Not active.
                    if (stripe_price.active !== true)  {
                        return true;
                    }

                    // Changed price.
                    if (parseFloat(stripe_price.unit_amount_decimal) / 100 !== product.price) {
                        return true;
                    }

                    // Changed currency.
                    if (stripe_price.currency !== product.currency) {
                        return true;
                    }

                    // Changed recurring status.
                    if (
                        (stripe_price.type === "recurring" && !product.is_subscription) ||
                        (stripe_price.type !== "recurring" && product.is_subscription)
                    ) {
                        return true;
                    }

                    // Changed recurring interval.
                    if (product.is_subscription && (product.interval_count !== stripe_price.recurring.interval_count || product.interval !== stripe_price.recurring.interval)) {
                        return true;
                    }

                    // Should not be updated.
                    return false;

                })();

            }

            // Create a price object.
            if (has_no_price) {
                await this._create_price(product); // automatically assigns the price id.
            }

            // Update the price object.
            else if (update_price) {
                try {
                    await this.stripe.products.update(product.id, {
                        default_price: null,
                    });
                } catch (error) {
                    throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
                }
                await this._deactivate_price(stripe_price.id);
                await this._create_price(product); // automatically assigns the price id.
            }

            // Set price id.
            else {
                product.price_id = stripe_price.id;
            }

            // Check if the name or description has changed.
            if (
                has_no_price ||
                update_price ||
                (stripe_product.name !== product.name) ||
                (stripe_product.description !== product.description) ||
                (product.statement_descriptor != null && stripe_product.statement_descriptor !== product.statement_descriptor) ||
                (product.icon != null && (stripe_product.images.length === 0 || stripe_product.images[0] !== product.icon))
            ) {
                try {
                    await this.stripe.products.update(product.id, {
                        // id: product.id,
                        name: product.name,
                        description: product.description,
                        statement_descriptor: product.statement_descriptor,
                        default_price: product.price_id,
                        images: [product.icon],
                    });
                } catch (error) {
                    throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
                }
            }

        }
    }

    // Deactivate a product.
    // When the product is a subscription all active subscriptions will be cancelled.
    async _deactivate_product(stripe_product) {

        // Deactivate the price object.
        // Also cancels all the active subscriptions.
        if (stripe_product.default_price != null) {
            try {
                await this.stripe.products.update(stripe_product.id, {
                    default_price: null,
                });
            } catch (error) {
                throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
            }
            await this._deactivate_price(stripe_product.default_price);
        }

        // Delete the product.
        try {
            await this.stripe.products.update(stripe_product.id, {
                active: false,
            });
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Get a subscription by stripe subscription id.
    async _get_subscription(sub_id) {
        try {
            return await this.stripe.products.retrieve(sub_id);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Cancel all subscriptions for a price id.
    async _cancel_subscription(sub_id) {
        try {
            await this.stripe.subscriptions.cancel(sub_id);
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
    }

    // Cancel all subscriptions for a price id.
    async _cancel_all_subscriptions(price_id) {
        const price = await this._get_price(price_id);
        // console.error("Cancel subscriptions:", price_id, price);
        if (price.type === "recurring") {
            let result;
            try {
                result = await this.stripe.subscriptions.list({
                    price: price_id,
                })
            } catch (error) {
                throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
            }
            if (Array.isArray(result.data)) {
                result.data.iterate_async_await((subscription) => {
                    const items = subscription.items;
                    if (subscription.status === "active" || subscription.status === "trialing") {
                        return this.stripe.subscriptions.cancel(subscription.id);
                    }
                })
            }
        }
    }

    // Get the object of the user defined product ids where a user has an active subscription to.
    // Returns an object with `{<product-id>: <subscription-id>}`.
    async _get_subscriptions(uid, cid = null) {
        if (cid == null) {
            cid = await this._get_stripe_cid(uid);
        }
        let result;
        try {
            result = await this.stripe.subscriptions.list({
                customer: cid,
            })
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }
        const products = {};
        if (Array.isArray(result.data)) {
            result.data.iterate((subscription) => {
                const items = subscription.items;
                if ((subscription.status === "active" || subscription.status === "trialing") && Array.isArray(items.data) && items.data.length > 0) {
                    products[items.data[0].price.product] = items.data[0].subscription;
                }
            })
        }
        return products;
    }

    // Check if a user is subscribed to a specific product.
    async _is_subscribed(uid, product) {
        return await this._get_subscriptions(uid)[product.id] !== undefined;
    }

    // Add or remove a subscription to the user's active subscriptions.
    _add_active_subscription(uid, prod_id, sub_id) {
        const dir = this.database.join(`.sys/stripe_subs/${uid}`, false);
        if (dir.exists() === false) {
            dir.mkdir_sync();
        }
        const path = dir.join(prod_id, false);
        path.save_sync(sub_id);
    }
    _remove_active_subscription(uid, prod_id) {
        const dir = this.database.join(`.sys/stripe_subs/${uid}`, false);
        if (dir.exists() === false) {
            return null;
        }
        const path = dir.join(prod_id, false);
        if (path.exists() === false) {
            return null;
        }
        path.del_sync();
    }

    // Check the user's subscription statuses, check for any unpaid or cancelled subscriptions and remove them from the active subscriptions.
    _verify_subscriptions() {

        // Iterate all users.
        this._iter_db_dir(".sys/users", async (path) => {
            const uid = path.name();
            const cid_path = this.database.join(`.sys/stripe_cids/${uid}`, false);
            if (cid_path.exists()) {

                // Vars.
                const cid = cid_path.load_sync();
                const subs = await this._get_subscriptions(null, cid);
                const active_sub_dir = this.database.join(`.sys/stripe_subs/${uid}`, false);
                if (active_sub_dir.exists() === false) {
                    active_sub_dir.mkdir_sync();
                }

                // Check if all the saved active subscriptions are still valid subscriptions.
                active_sub_dir.paths_sync().iterate((path) => {
                    const prod_id = path.name();
                    if (subs[prod_id] == null) {
                        path.del_sync();
                    }
                });

                // Check if all the stripe subscriptions are added as an active subscription.
                Object.keys(subs).iterate((prod_id) => this._add_active_subscription(uid, prod_id, subs[prod_id]));
            }
        });
    }

    // Initialize the payment products.
    async _initialize_products() {
        
        // Fetch all current stripe products.
        const stripe_products = await this._get_products();

        // Check a payment product / plan product.
        const product_ids = [];
        let product_index = 0;
        const check_product = (product) => {
            ++product_index;

            // Check if the product has an id.
            if (product.id == null || product.id === "") {
                throw Error(`Product ${product_index} does not have an assigned "id" attribute (string).`);
            }
            else if (product_ids.includes(product.id)) {
                throw Error(`Product ${product_index} has a non unique id "${product.id}".`);
            }
            product_ids.push(product.id);

            // Check attributes.
            if (typeof product.name !== "string" || product.name === "") {
                throw Error(`Product "${product.id}" does not have an assigned "name" attribute (string).`);
            }
            if (typeof product.description !== "string" || product.description === "") {
                throw Error(`Product "${product.id}" does not have an assigned "description" attribute (string).`);
            }
            if (typeof product.currency !== "string" || product.currency === "") {
                throw Error(`Product "${product.id}" does not have an assigned "currency" attribute (string).`);
            }
            if (typeof product.price !== "number") {
                throw Error(`Product "${product.id}" does not have an assigned "price" attribute (number).`);
            }
            if (product.is_subscription && product.interval == null) {
                throw Error(`Product "${product.id}" does not have an assigned "interval" attribute (string).`);   
            }
            if (product.is_subscription && product.interval_count == null) {
                product.interval_count = 1;
            }
            if (product.interval_count != null && typeof product.interval_count !== "number") {
                throw Error(`Product "${product.id}" has an incorrect value type for attribute "interval_count", the valid type is "number".`);
            }
            if (product.interval != null && product.interval !== "day" && product.interval !== "week" && product.interval !== "month" && product.interval !== "year") {
                throw Error(`Product "${product.id}" has an incorrect "interval" attribute, the interval string should be "day", "week", "month" or "year" not "${product.interval}".`);
            }
            if (product.statement_descriptor != null && typeof product.statement_descriptor !== "string") {
                throw Error(`Product "${product.id}" has an incorrect value type for attribute "statement_descriptor", the valid type is "string" (max 22 characters).`);
            }
            if (product.statement_descriptor != null && product.statement_descriptor.length > 22) {
                throw Error(`Product "${product.id}" has a too long string value for attribute "statement_descriptor" (max 22 characters).`);
            }
        }

        // Expand the payment products.
        let sub_products = 0;
        this.payment_products.iterate((product) => {
            if (product.plans != null) {
                if (product.plans != null && Array.isArray(product.plans) === false) {
                    throw Error(`Product "${product_index}" has an incorrect value type for attribute "plans", the valid type is "array".`);
                }
                product.id = `sub_${sub_products}`
                if (product_ids.includes(product.id)) {
                    throw Error(`Another product has a reserved id "${product.id}".`);
                }
                product_ids.push(product.id);
                ++sub_products;
                product.is_subscription = true;
                product.plans.iterate((plan) => {
                    plan.is_subscription = true;
                    plan.sub_id = product.id;
                    if (plan.name == null ) { plan.name = product.name; }
                    if (plan.description == null ) { plan.description = product.description; }
                    if (plan.currency == null ) { plan.currency = product.currency; }
                    if (plan.interval == null ) { plan.interval = product.interval; }
                    if (plan.interval_count == null ) { plan.interval_count = product.interval_count; }
                    if (plan.statement_descriptor == null ) { plan.statement_descriptor = product.statement_descriptor; }
                    if (plan.tax_behavior == null ) { plan.tax_behavior = product.tax_behavior; }
                    if (plan.icon == null ) { plan.icon = product.icon; }
                    check_product(plan);
                })
            } else {
                product.is_subscription = false;
                check_product(product);
            }
        })

        // Delete all stripe products that are not part of the payment products.
        stripe_products.iterate_async_await((stripe_product) => {
            const found = this.payment_products.iterate((product) => {
                if (product.is_subscription) {
                    return product.plans.iterate((plan) => {
                        if (plan.id === stripe_product.id) {
                            return true;  
                        }
                    })
                } else if (product.id === stripe_product.id) {
                    return true;
                }
            })
            if (found !== true) {
                return this._deactivate_product(stripe_product);
            }
        })

        // Iterate the payment products.
        await this.payment_products.iterate_async_await(async (product) => {
            const check_product = async (product) => {

                // Check if the stripe product exists.
                let stripe_product;
                stripe_products.iterate((x) => {
                    if (x.id === product.id) {
                        stripe_product = x;
                        return false;
                    }
                })

                // Update the stripe product when required.
                return this._update_product(product, stripe_product);
            }

            // Check plans or one-time product.
            if (product.is_subscription) {
                await product.plans.iterate_async_await(check_product);
            } else {
                return check_product(product);
            }
        })
    }

    // ---------------------------------------------------------
    // Server (private).

    // Initialize.
    async _initialize() {

        // Check & create database.
        if (this.database.exists()) {
            this.database.mkdir_sync();
        }
        [
            ".sys",
            ".sys/users",
            ".sys/tokens",
            ".sys/usernames",
            ".sys/emails",
            ".sys/keys",
            ".sys/unactivated",
            ".sys/2fa",
            ".sys/stripe_cids",
            ".sys/stripe_subs",
            "users",
        ].iterate((subpath) => {
            this.database.join(subpath).mkdir_sync();
        })
        
        // Load keys.
        const path = this.database.join(".sys/keys/keys");
        if (!path.exists()) {
            this.hash_key = this._sys_generate_crypto_key(32);
            path.save_sync(JSON.stringify({
                sha256: this.hash_key,
            }));
        } else {
            const data = JSON.parse(path.load_sync());
            this.hash_key = data["sha256"];
            if (this.hash_key === undefined) {
                this.hash_key = this._sys_generate_crypto_key(32);
                data["sha256"] = this.hash_key;
                path.save_sync(JSON.stringify(data));
            }
        }
        
        // Get max user id.
        this.max_uid = 0;
        this._iter_db_dir(".sys/users", (path) => {
            const uid = parseInt(path.name());
            if (uid > this.max_uid) {
                this.max_uid = uid;
            }
        });

        // Create default endpoints.
        this._create_default_endpoints();

        // Create static endpoints.
        this.statics.iterate((path) => {
            this._create_static_endpoints(path.base(), path);
        });
        
        // Create sitemap when it does not exist.
        if (this._find_endpoint("sitemap.xml") == null) {
            this._create_sitemap();
        }
        
        // Create robots.txt when it does not exist.
        if (this._find_endpoint("robots.txt") == null) {
            this._create_robots_txt();
        }

        // Set the caching of all endpoints.
        this.endpoints.iterate((endpoint) => {
            if (endpoint.callback === null) {
                if (this.production && endpoint.cache == null) {
                    endpoint.cache = 3600 * 24;
                } else if (!this.production) {
                    endpoint.cache = null;
                }
            }
        })
        
        // Stripe.
        if (this.stripe_enabled) {
            // await this._initialize_products()
            // this._verify_subscriptions();
        }
    }

    // Serve a client.
    // @todo implement rate limiting.
    async _serve(request, response) {
        return new Promise(async (resolve) => {

            // Log endpoint result.
            const log_endpoint_result = (message = null, status = null) => {
                console.log(`${Date.now()} ${method} ${endpoint_url}: ${message === null ? response.status_message : message} [${status === null ? response.status_code : status}].`);
            }

            // Initialize the request and wait till all the data has come in.
            request = new Request(request);
            await request.promise;

            // Parse the request parameters.
            try {
                request._parse_params();
            } catch (err) {
                response.send({
                    status: 400, 
                    headers: {"Content-Type": "text/plain"},
                    data: `Bad Request - ${err}`,
                });
                log_endpoint_result();
                return resolve();
            }

            // Initialize the response.
            response = new Response(response);

            // Set default headers.
            this._set_header_defaults(response);

            // Check if the request matches any of the defined endpoints
            const method = request.method;
            const endpoint_url = request.endpoint;
            const endpoint = this.endpoints.find((endpoint) => {
                return endpoint.method === method && endpoint.endpoint === endpoint_url;
            });

            // No endpoint found.
            if (!endpoint) {
                response.send({
                    status: 404, 
                    headers: {"Content-Type": "text/plain"},
                    data: "Not Found",
                });
                log_endpoint_result();
                return resolve();
            }

            // Check rate limiting.
            // @todo.

            // Always perform authentication so the request.uid will also be assigned even when the endpoint is not authenticated.
            const auth_result = this._authenticate(request);

            // Reset cookies when authentication has failed, so the UserID cookies etc will be reset.
            if (auth_result !== null) {
                this._reset_cookies(response);
            }

            // When the endpoint is authenticated and the authentication has failed then send the error response.
            if (auth_result !== null && endpoint.authenticated) {
                response.send(auth_result);
                log_endpoint_result();
                return resolve();
            }

            // Serve endpoint.
            try {
                await endpoint._serve(request, response);
            } catch (err) {
                console.error(err);
                response.send({
                    status: 500, 
                    headers: {"Content-Type": "text/plain"},
                    data: "Internal Server Error",
                });
                log_endpoint_result();
                return resolve();
            }

            // Check if the response has been sent.
            if (!response.finished) {
                console.error(`${Date.now()} ${method} ${endpoint_url}: Unfinished response.`);
                response.send({
                    status: 500, 
                    headers: {"Content-Type": "text/plain"},
                    data: "Internal Server Error",
                });
                log_endpoint_result();
                return resolve();
            }

            // Log.
            log_endpoint_result();
            return resolve();
        })
    }

    // ---------------------------------------------------------
    // Server.

    // Start the server.
	/*  @docs {
     *  @title: Start
     *  @description:
     *      Start the server.
     *  @usage:
     *      ...
     *      server.start();
     } */
    async start() {

        // Inside file watcher process.
        if (this.https === undefined && this.http === undefined) {
            return null;
        }

        // Initialize.
        await this._initialize();

        // Callbacks.
        let is_running = false;
        const on_running = () => {
            if (!is_running) {
                is_running = true;
                console.log(`Running on ${this.ip}:${this.port}.`); // @warning if you change this running on text you should update vide::BuildSystem since that depends on this log line.
            }
        }
        const on_error = (error) => {
            if (error.syscall !== 'listen') {
                throw error; // This is a system error, not related to server listening
            }
            switch (error.code) {
                case 'EACCES':
                    console.error(`Error: Address ${this.ip}:${this.port} requires elevated privileges.`);
                    process.exit(1);
                    break;
                case 'EADDRINUSE':
                    console.error(`Error: Address ${this.ip}:${this.port} is already in use.`);
                    process.exit(1);
                    break;
                default:
                    throw error;
            }
        }

        // Listen.
        if (this.https !== undefined) {
            this.https.listen(this.port, this.ip, on_running);
            this.https.on("error", on_error);
        }
        this.http.listen(this.port, this.ip, on_running);
        this.http.on("error", on_error);

        // Set signals.
        process.on('SIGTERM', () => process.exit(0)); // the "this.https.close()" handler does not always get executed when run from vide build system, so use "process.exit()" instead.
        process.on('SIGINT', () => process.exit(0));
    }

    // Stop the server and exit the program.
	/*  @docs {
     *  @title: Stop
     *  @description:
     *      Stop the server and exit the program by default.
     *  @parameter: {
     *      @name: exit
     *      @description: A boolean indicating whether the program should exit after stopping the server.
     *      @type: boolean
     *  }
     *  @usage:
     *      ...
     *      server.stop();
     } */
    stop(exit = true) {
        if (this.https === undefined && this.http === undefined) {
            return null; // inside file watcher process.
        }
        if (this.https !== undefined) {
            this.https.close((code) => { 
				if (exit) {
                	process.exit(0);
				}
            });
        }
        this.http.close((code) => { 
			if (exit) {
            	process.exit(0);
			}
        });
    }

    // ---------------------------------------------------------
    // Users.
    
    // Check if a username exists.
    /*  @docs {
     *  @title: Username Exists
     *  @description: Check if a username exists.
	 *  @type: boolean
     *  @return: Returns a boolean indicating whether the username exists or not.
     *  @parameter: {
     *      @name: username
     *      @description: The username to check.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const exists = server.username_exists("someusername");
     } */
    username_exists(username) {
        return this.database.join(`.sys/usernames/${username}`, false).exists();
    }
    
    // Check if an email exists.
    /*  @docs {
     *  @title: Email Exists
     *  @description: Check if a email exists.
	 *  @type: boolean
     *  @return: Returns a boolean indicating whether the email exists or not.
     *  @parameter: {
     *      @name: email
     *      @description: The email to check.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const exists = server.email_exists("some\@email.com");
     } */
    email_exists(email) {
        return this.database.join(`.sys/emails/${email}`, false).exists();
    }
    
    // Check if a user account is activated.
    /*  @docs {
     *  @title: Is Activated
     *  @description: Check if a user account is activated.
     *  @return: Returns a boolean indicating whether the account is activated or not.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to check.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      const activated = server.is_activated(0);
     } */
    is_activated(uid) {
        return !this.database.join(`.sys/unactivated/${uid}`, false).exists();
    }
    
    // Set the activated status of a user account is activated.
    /*  @docs {
     *  @title: Set Activated
     *  @description: Set the activated status of a user account is activated.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: activated
     *      @description: The boolean with the new activated status.
     *      @type: boolean
     *  }
     *  @usage:
     *      ...
     *      server.set_activated(0, true);
     } */
    set_activated(uid, activated) {
        const path = this.database.join(`.sys/unactivated/${uid}`, false);
        if (activated == true) {
            path.del_sync();
        } else {
            path.save_sync("");
        }
    }
    
    // Create user.
    /*  @docs {
     *  @title: Create User
     *  @description: Create a user account.
     *  @return: Returns the uid of the newly created user.
     *  @parameter: {
     *      @name: first_name
     *      @description: The user's first name.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: last_name
     *      @description: The user's last name.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: username
     *      @description: The username of the new account.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: email
     *      @description: The email of the new account.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: password
     *      @description: The password of the new account.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const uid = server.create_user({
     *          first_name: "John", 
     *          last_name: "Doe", 
     *          username: "johndoe", 
     *          email: "johndoe\@email.com",
     *          password: "HelloWorld!"
     *      });
     } */
    async create_user({
        first_name,
        last_name,
        username,
        email,
        password
    }) {
        
        // Check if username & email already exist.
        if (this.username_exists(username)) {
            throw Error(`Username "${username}" already exists.`);
        }
        if (this.email_exists(email)) {
            throw Error(`Email "${email}" already exists.`);
        }
        
        // Get new uid.
        // @todo check for deleted uids.
        await this.edit_max_uid_mutex.lock();
        ++this.max_uid;
        const uid = this.max_uid;
        this.edit_max_uid_mutex.unlock();
        
        // Save sys data.
        this._sys_save_user(uid, {
            first_name: first_name,
            last_name: last_name,
            username: username,
            email: email,
            password: this._hmac(password),
            api_key: "",
        });
        this._sys_save_uid_by_username(uid, username);
        this._sys_save_uid_by_email(uid, email);
        if (this.enable_account_activation) {
            this.set_activated(uid, false);
        }
        
        // Create user dir.
        this.database.join(`/users/${uid}/`).mkdir_sync();
        this.database.join(`/users/${uid}/private`).mkdir_sync();
        this.database.join(`/users/${uid}/protected`).mkdir_sync();
        this.database.join(`/users/${uid}/public`).mkdir_sync();
        
        // Return uid.
        return uid;
    }
    
    // Delete user.
    // The file paths should never be deleted.
    /*  @docs {
     *  @title: Delete User
     *  @description: Delete a user account.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id of the account to delete.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      server.delete_user(0);
     } */
    async delete_user(uid) {
        this._check_uid_within_range(uid);
        this._sys_delete_user(uid);
        await this._delete_stripe_customer();
        this.database.join(`users/${uid}`, false).del_sync();
    }
    
    // Set a user's first name.
    /*  @docs {
     *  @title: Set First Name
     *  @description:
     *      Set a user's first name
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: first_name
     *      @description: The new first name.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      server.set_first_name(0, "Name");
     } */
    async set_first_name(uid, first_name) {
        const user = this.get_user(uid);
        user.first_name = first_name;
        this._sys_save_user(uid, user);
        await this._update_stripe_customer(uid, user);
    }
    
    // Set a user's last name.
    /*  @docs {
     *  @title: Set Last Name
     *  @description:
     *      Set a user's last name
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: last_name
     *      @description: The new last name.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      server.set_first_name(0, "Name");
     } */
    async set_last_name(uid, last_name) {
        const user = this.get_user(uid);
        user.last_name = last_name;
        this._sys_save_user(uid, user);
        await this._update_stripe_customer(uid, user);
    }
    
    // Set a user's username.
    /*  @docs {
     *  @title: Set Username
     *  @description:
     *      Set a user's username
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: username
     *      @description: The new username.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      server.set_username(0, "newusername");
     } */
    async set_username(uid, username) {
        if (this.username_exists(username)) {
            throw Error(`Username "${username}" already exists.`);
        }
        const user = this.get_user(uid);
        user.username = username;
        this._sys_save_user(uid, user);
        this._sys_save_uid_by_username(uid, username);
    }
    
    // Set a user's email.
    /*  @docs {
     *  @title: Set Email
     *  @description:
     *      Set a user's email
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: email
     *      @description: The new email.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      server.set_email(0, "new\@email.com");
     } */
    async set_email(uid, email) {
        if (this.email_exists(email)) {
            throw Error(`Email "${email}" already exists.`);
        }
        const user = this.get_user(uid);
        user.email = email;
        this._sys_save_user(uid, user);
        this._sys_save_uid_by_email(uid, email);
        await this._update_stripe_customer(uid, user);
    }
    
    // Set a user's password.
    /*  @docs {
     *  @title: Set Password
     *  @description:
     *      Set a user's password
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: password
     *      @description: The new password.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      server.set_password(0, "XXXXXX");
     } */
    async set_password(uid, password) {
        const user = this.get_user(uid);
        user.password = this._hmac(password);
        this._sys_save_user(uid, user);
    }
    
    // Set a user's data.
    /*  @docs {
     *  @title: Set user
     *  @description:
     *      Set a user's data
     *
     *      When a key does not exist in the new user object it will not be set.
     *
     *      Does not update the user's id, key and password data.
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: user
     *      @description: The new user object.
     *      @type: object
     *  }
     *  @usage:
     *      ...
     *      server.set_user(0, {first_name: "John", last_name: "Doe"});
     } */
    async set_user(uid, user) {
        const current_user = this.get_user(uid);
        let old_username = null, old_email = null;
        let stripe_update_required = false;
        
        // First name.
        if (user.first_name != null && user.first_name != current_user.first_name) {
            current_user.first_name = user.first_name;
            stripe_update_required = true;
        }
        
        // Last name.
        if (user.last_name != null && user.last_name != current_user.last_name) {
            current_user.last_name = user.last_name;
            stripe_update_required = true;
        }
        
        // Username.
        if (user.username != null && user.username != current_user.username) {
            if (this.username_exists(user.username)) {
                throw Error(`Username "${user.username}" already exists.`);
            }
            old_username = current_user.username;
            current_user.username = user.username;
        }
        
        // Email.
        if (user.email != null && user.email != current_user.email) {
            if (this.email_exists(user.email)) {
                throw Error(`Email "${user.email}" already exists.`);
            }
            old_email = current_user.email;
            current_user.email = user.email;
            stripe_update_required = true;
        }
        
        // Save.
        this._sys_save_user(uid, current_user);
        if (old_username !== null) {
            this._sys_save_uid_by_username(uid, current_user.username);
            this._sys_delete_uid_by_username(uid, old_username);
        }
        if (old_email !== null) {
            this._sys_save_uid_by_email(uid, current_user.email);
            this._sys_delete_uid_by_email(uid, old_email);
        }

        // Update stripe customer.
        if (stripe_update_required) {
            await this._update_stripe_customer(uid, user);
        }
        
    }
    
    // Get uid by username.
    /*  @docs {
     *  @title: Get UID
     *  @description: Get a uid by username.
     *  @return:
     *      Returns the uid of the username.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: username
     *      @description: The username of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = server.get_uid("myusername")) !== null) { ... }
     } */
    get_uid(username) {
        if (username == null || username === "") {
            return null;
        }
        const path = this.database.join(`.sys/usernames/${username}`, false);
        if (path.exists()) {
            const uid = parseInt(path.load_sync());
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by email.
    /*  @docs {
     *  @title: Get UID By Email
     *  @description: Get a uid by email.
     *  @return:
     *      Returns the uid of the email.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: email
     *      @description: The email of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = server.get_uid_by_email("my\@email.com")) !== null) { ... }
     } */
    get_uid_by_email(email) {
        if (email == null || email === "") {
            return null;
        }
        const path = this.database.join(`.sys/emails/${email}`, false);
        if (path.exists()) {
            const uid = parseInt(path.load_sync());
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by api key.
    /*  @docs {
     *  @title: Get UID By API Key
     *  @description: Get a uid by API key.
     *  @return:
     *      Returns the uid of the api key.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: api_key
     *      @description: The API key of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = server.get_uid_by_api_key("XXXXXXXXXX")) !== null) { ... }
     } */
    get_uid_by_api_key(api_key) {
        let pos;
        if ((pos = api_key.indexOf(':')) != -1) {
            const uid = parseInt(api_key.substr(1, pos - 1));
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by token.
    /*  @docs {
     *  @title: Get UID By Token
     *  @description: Get a uid by token.
     *  @return:
     *      Returns the uid of the token.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: token
     *      @description: The token of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = server.get_uid_by_token("XXXXXXXXXX")) !== null) { ... }
     } */
    get_uid_by_token(token) {
        return this.get_uid_by_api_key(token);
    }
    
    // Get user info by uid.
    /*  @docs {
     *  @title: Get User
     *  @description:
     *      Get a user by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user to fetch.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      const user = server.get_user(0);
     } */
    get_user(uid) {
        this._check_uid_within_range(uid);
        return this._sys_load_user(uid);
    }
    
    // Get user info by username.
    /*  @docs {
     *  @title: Get User By Username
     *  @description:
     *      Get a user by username.
     *
     *      If the username does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: username
     *      @description: The username of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = server.get_user_by_username("myusername");
     } */
    get_user_by_username(username) {
        const uid = this.get_uid(username);
        if (uid === null) {
            throw Error(`No user with username "${username}" exists.`);
        }
        return this.get_user(uid);
    }
    
    // Get user info by email.
    /*  @docs {
     *  @title: Get User By Email
     *  @description:
     *      Get a user by email.
     *
     *      If the email does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: email
     *      @description: The email of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = server.get_user_by_email("my\@email.com");
     } */
    get_user_by_email(email) {
        const uid = this.get_uid_by_email(email);
        if (uid === null) {
            throw Error(`No user with email "${email}" exists.`);
        }
        return this.get_user(uid);
    }
    
    // Get user info by api key.
    /*  @docs {
     *  @title: Get User By API Key
     *  @description:
     *      Get a user by API key.
     *
     *      If the API key does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: api_key
     *      @description: The API key of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = server.get_user_by_api_key("XXXXXX");
     } */
    get_user_by_api_key(api_key) {
        const uid = this.get_uid_by_api_key(api_key);
        if (uid === null) {
            throw Error(`No user with api key "${api_key}" exists.`);
        }
        return this.get_user(uid);
    }
    
    // Get user info by token.
    /*  @docs {
     *  @title: Get User By Token
     *  @description:
     *      Get a user by token.
     *
     *      If the token does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: token
     *      @description: The token of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = server.get_user_by_token("XXXXXX");
     } */
    get_user_by_token(token) {
        const uid = this.get_uid_by_token(token);
        if (uid === null) {
            throw Error(`No user with token "${token}" exists.`);
        }
        return this.get_user(uid);
    }

    // Load user data helper.
    _load_user_data(uid, subpath, def, privacy) {
        // Check uid.
        this._check_uid_within_range(uid);

        // Check path.
        if (subpath.indexOf("..") !== -1) {
            throw Error(`Permission denied (path-injection).`);
        }
        const path = this.database.join(`users/${uid}/${privacy}/${subpath}`, false).abs();
        if (path.str().eq_first(`${this.database}/users/${uid}/${privacy}/`) === false) {
            throw Error(`Permission denied (path-injection).`);
        }

        // Does not exist.
        if (!path.exists()) {
            if (def !== null) {
                return def;
            }
        }

        // Load data.
        const data = path.load_sync();

        // Cast data.
        if (def == null || typeof def === "string") {
            return data;
        } else if (typeof def === "boolean") {
            return data === "true" || data === "1" || data === "True" || data === "TRUE";
        } else if (typeof def === "number") {
            return parseFloat(data);
        } else if (Array.isArray(def)) {
            return JSON.parse(data);
        } else if (typeof def === "object") {
            data = JSON.parse(data);
            Object.keys(def).iterate((key) => {
                if (data[key] === undefined) {
                    data[key] = def[key];
                }
            })
            return data;
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["string", "array", "object"].`);
        }
    }

    // Save user data helper.
    _save_user_data(uid, subpath, privacy) {

        // Check uid.
        this._check_uid_within_range(uid);

        // Check path.
        if (subpath.indexOf("..") !== -1) {
            throw Error(`Permission denied (path-injection).`);
        }
        const path = this.database.join(`users/${uid}/${privacy}/${subpath}`, false).abs();
        if (path.str().eq_first(`${this.database}/users/${uid}/${privacy}/`) === false) {
            throw Error(`Permission denied (path-injection).`);
        }
        return path;
    }
    
    // Load user data.
    /*  @docs {
     *  @title: Load Public User Data
     *  @description:
     *      Load public user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read and write access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns an empty type object when the data does not exist.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: def
     *      @description: The default data to be returned when the data does not exist. When the data does exist the data will parsed into the type of the `def` parameter.
     *      @type: boolean, number, string, array, object.
     *  }
     *  @usage:
     *      ...
     *      const data = server.load_user_data(0, "mydata", "object");
     } */
    load_user_data(uid, subpath, def = null) {
        return this._load_user_data(uid, subpath, def, "public");
    }
    
    // Save user data.
    /*  @docs {
     *  @title: Load Public User Data
     *  @description:
     *      Save user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read and write access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  }
     *  @usage:
     *      ...
     *      server.save_user_data(0, "mydata", {"Hello": "World!"});
     *      server.save_user_data(0, "mystring", "Hello World!");
     } */
    save_user_data(uid, subpath, data) {

        // Initialize path.
        const path = this._save_user_data(uid, subpath, "public");

        // Save casted data.
        if (data == null || typeof data === "string") {
            path.save_sync(data);
        } else if (typeof data === "boolean" || typeof data === "number") {
            path.save_sync(data.toString());
        } else if (Array.isArray(data) || typeof data === "object") {
            path.save_sync(JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["boolean", "number", "string", "array", "object"].`);
        }
    }

    // Load user data.
    /*  @docs {
     *  @title: Load Protected User
     *  @description:
     *      Load protected user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns an empty type object when the data does not exist.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: def
     *      @description: The default data to be returned when the data does not exist. When the data does exist the data will parsed into the type of the `def` parameter.
     *      @type: boolean, number, string, array, object.
     *  }
     *  @usage:
     *      ...
     *      const data = server.load_protected_user_data(0, "mydata", "object");
     } */
    load_protected_user_data(uid, subpath, def = null) {
        return this._load_user_data(uid, subpath, def, "protected");
    }
    
    // Save user data.
    /*  @docs {
     *  @title: Save Proteced User Data
     *  @description:
     *      Save protected user data by subpath.
     *
     *      The subpath resides in the user's protected data directory.
     *  @warning: The authenticated user always has read access to all data inside the user's protected directory through the backend rest api. Any other users or unauthenticated users do not have access to this data.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  }
     *  @usage:
     *      ...
     *      server.save_protected_user_data(0, "mydata", {"Hello": "World!"});
     *      server.save_protected_user_data(0, "mystring", "Hello World!");
     } */
    save_protected_user_data(uid, subpath, data) {

        // Initialize path.
        const path = this._save_user_data(uid, subpath, "protected");

        // Save casted data.
        if (data == null || typeof data === "string") {
            path.save_sync(data);
        } else if (typeof data === "boolean" || typeof data === "number") {
            path.save_sync(data.toString());
        } else if (Array.isArray(data) || typeof data === "object") {
            path.save_sync(JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["boolean", "number", "string", "array", "object"].`);
        }
    }

    // Load user data.
    /*  @docs {
     *  @title: Load Private User Data
     *  @description:
     *      Load private user data by subpath.
     *
     *      The subpath resides in the user's private data directory.
     *
     *      The user has no read or write access to the private directory.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns an empty type object when the data does not exist.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: def
     *      @description: The default data to be returned when the data does not exist. When the data does exist the data will parsed into the type of the `def` parameter.
     *      @type: boolean, number, string, array, object.
     *  }
     *  @usage:
     *      ...
     *      const data = server.load_private_user_data(0, "mydata", "object");
     } */
    load_private_user_data(uid, subpath, def = null) {
        return this._load_user_data(uid, subpath, def, "private");
    }
    
    // Save user data.
    /*  @docs {
     *  @title: Save Private User Data
     *  @description:
     *      Save private user data by subpath.
     *
     *      The subpath resides in the user's private data directory.
     *
     *      The user has no read or write access to the private directory.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  }
     *  @usage:
     *      ...
     *      server.save_private_user_data(0, "mydata", {"Hello": "World!"});
     *      server.save_private_user_data(0, "mystring", "Hello World!");
     } */
    save_private_user_data(uid, subpath, data) {

        // Initialize path.
        const path = this._save_user_data(uid, subpath, "private");

        // Save casted data.
        if (data == null || typeof data === "string") {
            path.save_sync(data);
        } else if (typeof data === "boolean" || typeof data === "number") {
            path.save_sync(data.toString());
        } else if (Array.isArray(data) || typeof data === "object") {
            path.save_sync(JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["boolean", "number", "string", "array", "object"].`);
        }
    }
    
    // Generate an api key by uid.
    /*  @docs {
     *  @title: Generate API Key
     *  @description:
     *      Generate an API key for a user.
     *
     *      Generating an API key overwrites all existing API keys.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns the API key string.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to generate an API key for.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      const api_key = server.generate_api_key(0);
     } */
    generate_api_key(uid) {
        this._check_uid_within_range(uid);
        const api_key = `0${uid}:${this._sys_generate_key()}`;
        const user = this._sys_load_user(uid);
        user.api_key = this._hmac(api_key);
        this._sys_save_user(uid, user);
        return api_key;
    }
    
    // Revoke the API key of a user.
    /*  @docs {
     *  @title: Revoke API Key
     *  @description:
     *      Revoke the API key of a user.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to revoke the API key for.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      server.revoke_api_key(0);
     } */
    revoke_api_key(uid) {
        this._check_uid_within_range(uid);
        const user = this._sys_load_user(uid);
        user.api_key = "";
        this._sys_save_user(uid, user);
    }
    
    // Verify a plaintext password.
    /*  @docs {
     *  @title: Verify Password
     *  @description:
     *      Verify a plaintext password.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to verify.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: password
     *      @description: The plaintext password.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = server.verify_password(0, "XXXXXX");
     } */
    verify_password(uid, password) {
        if (uid === null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const user = this._sys_load_user(uid);
        return user.uid !== null && user.password === this._hmac(password);
    }
    
    // Verify a plaintext api key.
    /*  @docs {
     *  @title: Verify API Key
     *  @description:
     *      Verify an plaintext API key.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: api_key
     *      @description: The api key to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = server.verify_api_key("XXXXXX");
     } */
    verify_api_key(api_key) {
        return this.verify_api_key_by_uid(this.get_uid_by_api_key(api_key), api_key);
    }
    /*  @docs {
     *  @title: Verify API Key By UID
     *  @description:
     *      Verify an plaintext API key by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the api key to verify.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: api_key
     *      @description: The api key to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = server.verify_api_key_by_uid(0, "XXXXXX");
     } */
    verify_api_key_by_uid(uid, api_key) {
        if (uid == null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const user = this._sys_load_user(uid);
        return user.uid !== null && user.api_key.length > 0 && user.api_key == this._hmac(api_key);
    }
    
    // Verify a token.
    /*  @docs {
     *  @title: Verify Token
     *  @description:
     *      Verify an plaintext token.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: api_key
     *      @description: The token to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = server.verify_token("XXXXXX");
     } */
    verify_token(token) {
        return this.verify_token_by_uid(this.get_uid_by_api_key(token), token);
    }
    /*  @docs {
     *  @title: Verify Token By UID.
     *  @description:
     *      Verify an plaintext token by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the token to verify.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: api_key
     *      @description: The token to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = server.verify_token_by_uid(0, "XXXXXX");
     } */
    verify_token_by_uid(uid, token) {
        if (uid == null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const correct_token = this._sys_load_user_token(uid);
        return correct_token.token != null && Date.now() < correct_token.expiration && correct_token.token == this._hmac(token);
    }
    
    // Send a mail.
    /*  @docs {
     *  @title: Send Mail
     *  @description:
     *      Send one or multiple mails.
     *
     *      Make sure the domain's DNS records SPF and DKIM are properly configured when sending attachments.
     *
     *      See `vlib::smtp::Client` and `vlib::smtp::Mail` for more info.
     *  @return:
     *      Returns a promise that will be resolved or rejected when the mail has been sent.
     *  @parameter: {
     *      @name: sender
     *      @description:
     *          The sender address.
     *          A sender address may either be a string with the email address, e.g. `your@email.com`.
     *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
     *      @type: string, array
     *  }
     *  @parameter: {
     *      @name: recipients
     *      @description:
     *          The recipient addresses.
     *          A reciepient address may either be a string with the email address, e.g. `your@email.com`.
     *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
     *      @type: array[string, array]
     *  }
     *  @parameter: {
     *      @name: subject
     *      @description: The subject text.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: body
     *      @description: The body text.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: attachments
     *      @description: An array with absolute file paths for attachments.
     *      @type: array[string]
     *  }
     *  @usage:
     *      ...
     *      server.send_mail({
     *          sender: ["Sender Name", "sender\@email.com"],
     *          recipients: [
     *              ["Recipient Name", "recipient1\@email.com"],
     *              "recipient2\@email.com",
     *          },
     *          subject: "Example Mail",
     *          body: "Hello World!",
     *          attachments: ["/path/to/image.png"]
     *      });
     } */
    async send_mail({
        sender = null,
        recipients = [],
        subject = null,
        body = "",
        attachments = [],
    }) {
        return new Promise((resolve, reject) => {

            // Not enabled.
            if (this.smtp_enabled === false) {
                return reject("SMTP is not enabled, define the required server argument on initialization to enable smtp.");
            }

            // Check args.
            if (sender === null) {
                sender = this.smtp_sender;
                // return reject(`Parameter "sender" should be a defined value of type "string" or "array".`);
            }
            if (recipients.length === 0) {
                return reject(`The mail has no recipients.`);
            }
            if (sender === null) {
                return reject(`Parameter "sender" should be a defined value of type "string" or "array".`);
            }

            // Format address wrapper.
            const format_address = (address) => {
                if (Array.isArray(address)) {
                    return `${address[0]} <${address[1]}>`;
                }
                return address;
            }

            // Create to array.
            const to = [];
            recipients.iterate((address) => to.push(format_address(address)));

            // Create attachments array.
            const attached_files = [];
            attachments.iterate((path) => {
                attached_files.push({
                    filename: new vlib.Path(path).name(),
                    path: path,
                })
            })

            // Send mail.
            this.smtp.sendMail(
                {
                    from: format_address(sender),
                    to: to,
                    subject: subject,
                    html: body,
                    attachments: attachments,
                },
                (error, info) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(info);
                    }
                }
            )

        })
    }
    
    // Send a 2fa code.
    /*  @docs {
     *  @title: Send 2FA Code
     *  @description:
     *      Send a 2FA code to a user by user id.
     *
     *      By default the 2FA code will be valid for 5 minutes.
     *  @return:
     *      Returns a promise that will be resolved or rejected when the 2fa mail has been sent.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: request
     *      @description: The request object from the client request.
     *      @type: object
     *  }
     *  @parameter: {
     *      @name: mail_body
     *      @description: 
     *          The mail body in HTML. 
     *          When this parameter is undefined, the server attribute `mail_body_2fa` will be used as the body.
     *          It should contain the string "{{2FA}}", which will be replaced with the generated 2FA code.
     *          Other optional replaced keys are: 
     *              - `{{USERNAME}}`
     *              - `{{DATE}}`
     *              - `{{IP}}`
     *              - `{{DEVICE}}`
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: expiration
     *      @description: The amount of seconds in which the code will expire.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      server.send_2fa({uid: 0, request: request});
     } */
    async send_2fa({
        uid, 
        request,
        mail_body = null,
        expiration = 300,
        _device = null,
    }) {
        this._check_uid_within_range(uid);
        
        // Generate 2fa.
        const auth = {
            expiration: Date.now() + expiration * 1000,
            code: this._sys_generate_2fa(),
        };
        this._sys_save_user_2fa(uid, auth);
        
        // Get user email.
        const user = this.get_user(uid);
        
        // Get device.
        let device;
        if (_device === null) {
            device = request.headers["user-agent"];
        }
        
        // Replace body.
        let body;
        if (mail_body == null) {
            body = this.mail_body_2fa
                .replaceAll("{{2FA}}", auth.code)
                .replaceAll("{{USERNAME}}", user.username)
                .replaceAll("{{DATE}}", (new Date()).toUTCString())
                .replaceAll("{{IP}}", request.ip)
                .replaceAll("{{DEVICE}}", device ? device : "Unknown");    
        } else {
            body = mail_body
                .replaceAll("{{2FA}}", auth.code)
                .replaceAll("{{USERNAME}}", user.username)
                .replaceAll("{{DATE}}", (new Date()).toUTCString())
                .replaceAll("{{IP}}", request.ip)
                .replaceAll("{{DEVICE}}", device ? device : "Unknown");
        }
        
        // Send mail.
        return this.send_mail({
            sender: this.smtp_sender,
            recipients: [user.email],
            subject: "Two Factor Authentication Code",
            body: body,
        });
        
    }
    
    // Verify a 2fa code.
    /*  @docs {
     *  @title: Verify 2FA Code
     *  @description:
     *      Verify a 2FA code by user id.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: code
     *      @description: The 2FA code.
     *      @type: string
     *  }
     *  @return: Returns a boolean indicating whether the verification was successful or not.
     *  @usage:
     *      ...
     *      server.verify_2fa(0, "123456");
     } */
    verify_2fa(uid, code) {
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const auth = this._sys_load_user_2fa(uid);
        const now = Date.now();
        const status = auth.code != null && now < auth.expiration && auth.code == code;
        if (status || now > auth.expiration) {
            this._sys_delete_user_2fa(uid);
        }
        return status;
    }

    // Create a subscription
    /*  @docs {
     *  @title: Create Subscription.
     *  @description:
     *      Create a subscription for one of the products.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: product_id
     *      @description: The id of the subscription payment product.
     *      @type: string
     *  }
     *  @type: object.
     *  @return: Returns an object with the client secret that should be passed to the frontend.
     *  @usage:
     *      ...
     *      server.create_subscription({uid: 0, product_id: "prod_sub_basic"});
     } */
    async create_subscription({uid, product_id, product = null, cid = null}) {

        // Get the products.
        if (product == null) {
            product = this._get_payment_product_by_id(product_id);
            if (product == null) {
                throw Error(`Unknown product id "${product_id}".`);
            }
            if (product.is_subscription === false) {
                throw Error(`Product "${product.name}" is not a subscription product.`);
            }
        }

        // Check subscription product.
        else if (product.is_subscription === false) {
            throw Error(`Product "${product.name}" is not a subscription product.`);
        }

        // Check product.
        if (product == null) {
            throw Error("Undefined product.");
        }

        // Check products price id.
        if (product.price_id == null) {
            throw Error("The product's price id must be defined to create a subscription.");
        }

        // Retrieve the cid from the user.
        if (cid == null) {

            // Check uid.
            if (uid == null) {
                throw Error("One of the following parameters must be defined \"uid\" or \"cid\".");
            }

            // Check uid.
            this._check_uid_within_range(uid);

            // Get cid.
            cid = await this._get_stripe_cid(uid)

        }

        // Fetch the user's subscriptions.
        const user_subs = await this._get_subscriptions(null, cid);

        // Check if the user is already subscribed.
        if (user_subs[product.id] !== undefined) {
            return {
                error: `You are already subscribed to product \"${product.name}\".`,
                already_subscribed: true,
            }
        }

        // Cancel the other active plans from this subscription.
        const subscription_product = this._get_payment_product_by_id(product.sub_id);
        if (subscription_product == null) {
            throw Error(`Unable to find payment product "${product.sub_id}".`);
        }
        subscription_product.plans.iterate_async_await((plan) => {
            if (plan.id !== product.id && user_subs[plan.id] !== undefined) {
                return this._cancel_subscription(user_subs[plan.id])
            }
        })

        // Create subscription.
        let result;
        try {
            result = await this.stripe.subscriptions.create({
                customer: cid,
                items: [
                    {price: product.price_id},
                ],
                payment_behavior: "default_incomplete",
                payment_settings: { save_default_payment_method: 'on_subscription' },
                expand: ['latest_invoice.payment_intent'],
            });
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }

        // Response for frontend.
        return {
            id: result.id,
            client_secret: result.latest_invoice.payment_intent.client_secret,
        };
    }

    // Create a payment
    /*  @docs {
     *  @title: Create Payment.
     *  @description:
     *      Create a subscription for one of the products.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: product_ids
     *      @description: The id of the one-time payment product.
     *      @type: string
     *  }
     *  @type: object.
     *  @return: Returns an object with the client secret that should be passed to the frontend.
     *  @usage:
     *      ...
     *      server.create_payment({uid: 0, product_ids: ["prod_basic"]});
     } */
    async create_payment({uid, product_ids, products = null, cid = null, email = null}) {

        // Get products.
        let price = 0, currency;
        if (Array.isArray(products) === false) {

            // Check args.
            if (Array.isArray(product_ids) === false) {
                throw Error(`Parameter "product_ids" has an invalid value type "${typeof product_ids}", the valid value type is "array".`);
            } else if (product_ids.length === 0) {
                throw Error(`No product ids were specified.`);
            }

            // Get the products.
            const products = [];
            product_ids.iterate((id) => {
                const found = this.payment_products.iterate((p) => {
                    if (p.id === id) {
                        if (p.is_subscription) {
                            throw Error(`Product "${p.name}" is a subscription product.`);
                        }
                        else if (currency == null) {
                            currency = p.currency;
                        }
                        else if (currency !== p.currency) {
                            throw Error(`Products with different currencies can not be charged in a single request ("${currency}" and "${p.currency}").`);
                        }
                        price += Math.round(p.price * 100);
                        products.push(p)
                        return true;
                    }
                })
                if (found !== true) {
                    throw Error(`Unknown product id "${id}".`);
                }
            })
        }

        // Check one-time products.
        else {
            products.iterate((p) => {
                if (p.is_subscription) {
                    throw Error(`Product "${p.name}" is a subscription product.`);
                }
                else if (currency == null) {
                    currency = p.currency;
                }
                else if (currency !== p.currency) {
                    throw Error(`Products with different currencies can not be charged in a single request ("${currency}" and "${p.currency}").`);
                }
                price += Math.round(p.price * 100);
            })
        }

        // Retrieve the cid from the user.
        if (cid == null) {

            // Check uid.
            if (uid == null) {
                throw Error("One of the following parameters must be defined \"uid\" or \"cid\".");
            }

            // Load the user's email.
            email = this.get_user(uid).email

            // Get the customer id.
            cid = await this._get_stripe_cid(uid);

        }

        // Retrieve the email when both the cid and uid are defined.
        else if (uid != null && email == null) {
            email = this.get_user(uid).email
        }

        // Check the email.
        else if (email == null) {
            throw Error("Define parameter \"email\".");
        }

        // Create a description and statement descriptor.
        let description, statement_descriptor;
        if (products.length === 1) {
            description = products[0].description;
            statement_descriptor = products[0].statement_descriptor;
        }

        // Create a payment intent.
        let result;
        try {
            result = await this.stripe.paymentIntents.create({
                customer: cid,
                amount: price,
                currency: currency,
                receipt_email: email,
                description: description,
                statement_descriptor: statement_descriptor,
                automatic_payment_methods: {
                    enabled: true,
                },
            });
        } catch (error) {
            throw new StripeError(error.message); // since the default stripe errors do not have a stacktrace.
        }

        // Response for frontend.
        return {
            id: result.id,
            client_secret: result.client_secret,
        };
    }
    

    // Make invoice.
    /*  @ docs {
     *  @title: Create Invoice
     *  @description:
     *      Create an invoice for one or multiple payment products.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: product_ids
     *      @description: The id's of the payment products.
     *      @type: array[string]
     *  }
     *  @type: object.
     *  @return: Returns an object with the client secret that should be passed to the frontend.
     *  @usage:
     *      ...
     *      server.create_payment(0, ["prod_basic"]);
     } 
    create_invoice(uid, product_ids) {

        // Get the products.
        const products = [];
        product_ids.iterate((id) => {
            const found = this.payment_products.iterate((product) => {
                if (product.id === id) {
                    if (product.recurring != null) {
                        throw Error(`Only one-time payment products can be passed to "create_payment()", product "${product.name}" is a subscription product.`);
                    }
                    products.push(product);
                    return true;
                }
            })
            if (found !== true) {
                throw Error(`Unknown product id "${id}".`);
            }
        })

        // Check the uid.
        this._check_uid_within_range(uid);

        // Get the stripe customer id.
        const cid = this._get_stripe_cid(uid);

        // Create an invoice.
        let invoice = await this.stripe.invoices.create({
            customer: cid,
            collection_method: "charge_automatically",
            days_until_due: 30,
            automatic_tax: {enabled: true},
        });

        // Add products to the invoice.
        products.iterate((product) => {
            await this.stripe.invoiceItems.create({
                customer: cid,
                price: product.price_id,
                description: product.description,
            });
        })

        // Finalize the invoice.
        invoice = await this.stripe.invoices.finalizeInvoice(invoice.id, {
            auto_advance: true,
        });

        // Retrieve the payment's intent client secret.
        const payment_intent = this.stripe.paymentIntents.retrieve(invoice.payment_intent);

        // Return the client secret to the frontend.
        return {
            client_secret: payment_intent.client_secret,
        }
        
    }
    */

    // ---------------------------------------------------------
    // Endpoints.

    // Add one or multiple endpoints.
    /*  @docs: {
        @title: Add endpoint(s)
        @description: Add one or multiple endpoints.
        @parameter: {
            @name: ...endpoints
            @description:
                The endpoint parameters.

                An endpoint parameter can either be a `Endpoint` class or an `object` with the `Endpoint` arguments.
            @type: Endpoint, object
        }
        } */
    endpoint(...endpoints) {
        for (let i = 0; i < endpoints.length; i++) {
            const endpoint = endpoints[i];
            if (endpoint instanceof Endpoint) {
                this.endpoints.push(endpoint);
            } else {
                this.endpoints.push(new Endpoint(endpoint));
            }
        }
        return this;
    }
}

// ---------------------------------------------------------
// Exports.

module.exports = Server;
