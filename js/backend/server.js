/*
 * Author: Daan van den Bergh
 * Copyright: Â© 2022 - 2023 Daan van den Bergh.
 */

// ---------------------------------------------------------
// Libraries.

const https = require("https");
const libfs = require("fs");
const libpath = require("path")
const libcrypto = require('crypto');
const libnodemailer = require('nodemailer');

// ---------------------------------------------------------
// Imports.

const Mutex = require(`${__dirname}/mutex.js`);
const Endpoint = require(`${__dirname}/endpoint.js`);
const Response = require(`${__dirname}/response.js`);
const FileWatcher = require(`${__dirname}/file_watcher.js`);

// ---------------------------------------------------------
// The server object.

/*  @docs: {
 *  @title: Meta
 *  @description: The js view meta information class.
 *  @parameter: {
 *      @name: ip
 *      @description: The ip where the server will run on.
 *      @type: string
 *      @required
 *  }
 *  @parameter: {
 *      @name: port
 *      @description: The port where the server will run on.
 *      @type: string
 *      @required
 *  }
 *  @parameter: {
 *      @name: certificate
 *      @description: The path to the certificate file.
 *      @type: string
 *      @required
 *  }
 *  @parameter: {
 *      @name: private_key
 *      @description: The path to the private key file.
 *      @type: string
 *      @required
 *  }
 *  @parameter: {
 *      @name: passphrase
 *      @description: The passphrase of the private key.
 *      @type: string
 *  }
 *  @parameter: {
 *      @name: domain
 *      @description: The full domain url without `http://` or `https://`.
 *      @type: string
 *      @required
 *  }
 *  @parameter: {
 *      @name: statics
 *      @description: Array with path's to static directories.
 *      @type: array[string]
 *      @required
 *  }
 *  @parameter: {
 *      @name: database
 *      @description: The path to the database directory.
 *      @type: string
 *      @required
 *  }
 *  @parameter: {
 *      @name: default_headers
 *      @description: Used to override the default headers generated by vweb. Leave parameter `default_headers` as `null` to let vweb automatically generate the default headers.
 *      @type: object
 *  }
 *  @parameter: {
 *      @name: token_expiration
 *      @description: The token a sign in token will be valid in seconds.
 *      @type: number
 *  }
 *  @parameter: {
 *      @name: enable_2fa
 *      @description: Enable 2fa for user authentication.
 *      @type: boolean
 *      @required
 *  }
 *  @parameter: {
 *      @name: smtp_sender
 *      @description:
 *          The smtp sender address may either be a string with the email address, e.g. `your@email.com`.
 *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
 *      @type: string, array
 *      @required
 *  }
 *  @parameter: {
 *      @name: smtp
 *      @description:
 *          The smpt arguments object.
 *          More information about the arguments can be found at the nodemailer <link https://nodemailer.com/smtp/>documentation<link>.
 *      @type: object
 *      @required
 *  }
 *  @parameter: {
 *      @name: production
 *      @description: Whether the server is in production more, or in development mode.
 *      @type: boolean
 *      @required
 *  }
 *  @parameter: {
 *      @name: file_watcher
 *      @description: The file watcher arguments, define to enable file watching. The parameter may either be an FileWatcher object, an object with arguments or a string for the `source` argument.
 *      @type: FileWatcher, object, string.
 *  }
 } */
class Server {
    constructor({
        ip = "127.0.0.1",
        port = 8000,
        certificate = '../dev/tls/certificate.pem',
        private_key = '../dev/tls/private-key.pem',
        passphrase = null,
        domain = null,
        statics = [],
        database = null,
        default_headers = null,
        token_expiration = 86400,
        enable_2fa = false,
        smtp_sender = null,
        smtp = null,
        production = false,
        file_watcher = null,
    }) {

        // Check args.
        if (typeof ip !== "string") {
            throw Error(`Parameter "ip" should be a defined value of type "string".`);
        }
        if (typeof port !== "string") {
            throw Error(`Parameter "port" should be a defined value of type "string".`);
        }
        if (typeof certificate !== "string") {
            throw Error(`Parameter "ip" should be certificate defined value of type "string".`);
        }
        if (typeof private_key !== "string") {
            throw Error(`Parameter "ip" should be private_key defined value of type "string".`);
        }
        if (typeof domain !== "string") {
            throw Error(`Parameter "domain" should be a defined value of type "string".`);
        }
        if (typeof database !== "string") {
            throw Error(`Parameter "database" should be a defined value of type "string".`);
        }
        if (typeof smtp_sender !== "string" && !Array.isArray(smtp_sender)) {
            throw Error(`Parameter "smtp_sender" should database a defined value of type "string" or "array".`);
        }
        if (typeof smtp !== "object") {
            throw Error(`Parameter "smtp" should database a defined value of type "object".`);
        }

        // Attributes.
        this.port = port;
        this.ip = ip;
        this.certificate = libfs.readFileSync(certificate, 'utf8');
        this.private_key = libfs.readFileSync(private_key, 'utf8');
        this.domain = domain;
        this.statics = statics;
        this.database = database;
        this.enable_2fa = enable_2fa;
        this.production = production;
        this.token_expiration = token_expiration;

        // Default headers.
        if (default_headers === null) {
            this.default_headers = {
                "Vary": "Origin",
                "Referrer-Policy": "same-origin",
                "Access-Control-Allow-Methods": "GET, POST, PUT, PATCH, DELETE, OPTIONS",
                "X-XSS-Protection": "1; mode=block",
                "X-Content-Type-Options": "frame-ancestors 'none'; nosniff;",
                "X-Frame-Options": "DENY",
                "Strict-Transport-Security": "max-age=31536000",
                "Content-Security-Policy": 
                    "default-src 'self' *.google-analytics.com https://my.spline.design; " +
                    "img-src 'self' *.google-analytics.com raw.githubusercontent.com www.w3.org; " +
                    "script-src 'self' ajax.googleapis.com www.googletagmanager.com googletagmanager.com *.google-analytics.com raw.githubusercontent.com code.jquery.com; " +
                    "style-src 'self' 'unsafe-inline'; " +
                    "upgrade-insecure-requests; " +
                    "block-all-mixed-content;",
            }
        } else {
            this.default_headers = default_headers;
        }

        // 2fa mail.
        this.mail_body_2fa = "<p>Your 2FA code is: {{2FA}}.</p>"

        // Define your list of endpoints
        this.endpoints = [];

        // File watcher.
        if (file_watcher != null && process.env.VWEB_FILE_WATCHER != '1') {
            if (typeof file_watcher === "string") {
                this.file_watcher = new FileWatcher({source: file_watcher});
            }
            else if (!(file_watcher instanceof FileWatcher)) {
                this.file_watcher = new FileWatcher(file_watcher);
            }
            this.file_watcher.start();
            return null;
        }

        // The smtp instance.
        this.smtp_sender = smtp_sender;
        this.smtp = libnodemailer.createTransport({smtp});
        
        // Create an HTTPS server
        this.https = https.createServer({key: this.private_key, cert: this.certificate, passphrase: passphrase}, (request, response) => this._serve(request, response));

        // Max uid.
        this.max_uid = null;
        this.edit_max_uid_mutex = new Mutex();

        // The master sha256 hash key.
        this.hash_key = null;

        // Mimes for content type detection.
        // Must be defined before creating static endpoints.
        this.content_type_mimes = [
            ["html", "text/html"],
            ["htm", "text/html"],
            ["shtml", "text/html"],
            ["css", "text/css"],
            ["xml", "application/xml"],
            ["gif", "image/gif"],
            ["jpeg", "image/jpeg"],
            ["jpg", "image/jpeg"],
            ["js", "application/javascript"],
            ["atom", "application/atom+xml"],
            ["rss", "application/rss+xml"],
            ["mml", "text/mathml"],
            ["txt", "text/plain"],
            ["jad", "text/vnd.sun.j2me.app-descriptor"],
            ["wml", "text/vnd.wap.wml"],
            ["htc", "text/x-component"],
            ["png", "image/png"],
            ["tif", "image/tiff"],
            ["tiff", "image/tiff"],
            ["wbmp", "image/vnd.wap.wbmp"],
            ["ico", "image/x-icon"],
            ["jng", "image/x-jng"],
            ["bmp", "image/x-ms-bmp"],
            ["svg", "image/svg+xml"],
            ["svgz", "image/svg+xml"],
            ["webp", "image/webp"],
            ["woff", "font/woff"],
            ["woff2", "font/woff2"],
            ["jar", "application/java-archive"],
            ["war", "application/java-archive"],
            ["ear", "application/java-archive"],
            ["json", "application/json"],
            ["hqx", "application/mac-binhex40"],
            ["doc", "application/msword"],
            ["pdf", "application/pdf"],
            ["ps", "application/postscript"],
            ["eps", "application/postscript"],
            ["ai", "application/postscript"],
            ["rtf", "application/rtf"],
            ["m3u8", "application/vnd.apple.mpegurl"],
            ["xls", "application/vnd.ms-excel"],
            ["eot", "application/vnd.ms-fontobject"],
            ["ppt", "application/vnd.ms-powerpoint"],
            ["wmlc", "application/vnd.wap.wmlc"],
            ["kml", "application/vnd.google-earth.kml+xml"],
            ["kmz", "application/vnd.google-earth.kmz"],
            ["7z", "application/x-7z-compressed"],
            ["cco", "application/x-cocoa"],
            ["jardiff", "application/x-java-archive-diff"],
            ["jnlp", "application/x-java-jnlp-file"],
            ["run", "application/x-makeself"],
            ["pl", "application/x-perl"],
            ["pm", "application/x-perl"],
            ["prc", "application/x-pilot"],
            ["pdb", "application/x-pilot"],
            ["rar", "application/x-rar-compressed"],
            ["rpm", "application/x-redhat-package-manager"],
            ["sea", "application/x-sea"],
            ["swf", "application/x-shockwave-flash"],
            ["sit", "application/x-stuffit"],
            ["tcl", "application/x-tcl"],
            ["tk", "application/x-tcl"],
            ["der", "application/x-x509-ca-cert"],
            ["pem", "application/x-x509-ca-cert"],
            ["crt", "application/x-x509-ca-cert"],
            ["xpi", "application/x-xpinstall"],
            ["xhtml", "application/xhtml+xml"],
            ["xspf", "application/xspf+xml"],
            ["zip", "application/zip"],
            ["bin", "application/octet-stream"],
            ["exe", "application/octet-stream"],
            ["dll", "application/octet-stream"],
            ["deb", "application/octet-stream"],
            ["dmg", "application/octet-stream"],
            ["iso", "application/octet-stream"],
            ["img", "application/octet-stream"],
            ["msi", "application/octet-stream"],
            ["msp", "application/octet-stream"],
            ["msm", "application/octet-stream"],
            ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
            ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
            ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
            ["mid", "audio/midi"],
            ["midi", "audio/midi"],
            ["kar", "audio/midi"],
            ["mp3", "audio/mpeg"],
            ["ogg", "audio/ogg"],
            ["m4a", "audio/x-m4a"],
            ["ra", "audio/x-realaudio"],
            ["3gpp", "video/3gpp"],
            ["3gp", "video/3gpp"],
            ["ts", "video/mp2t"],
            ["mp4", "video/mp4"],
            ["mpeg", "video/mpeg"],
            ["mpg", "video/mpeg"],
            ["mov", "video/quicktime"],
            ["webm", "video/webm"],
            ["flv", "video/x-flv"],
            ["m4v", "video/x-m4v"],
            ["mng", "video/x-mng"],
            ["asx", "video/x-ms-asf"],
            ["asf", "video/x-ms-asf"],
            ["wmv", "video/x-ms-wmv"],
            ["avi", "video/x-msvideo"],
        ];

        // @todo load keys from database or create and save them.
    }

    // ---------------------------------------------------------
    // Utils (private).

    // Iterate a subpath directory in the database.
    _iter_db_dir(subpath, callback) {
        libfs.readdirSync(libpath.join(this.database, dir)).iterate(callback);
    }

    // Check of the uid is within the max uid range.
    _check_uid_within_range(uid) {
        if (uid == null || uid < 0) {
            throw Error("Undefined user id.");
        }
        else if (uid > this.max_uid) {
            throw Error(`User id "${uid}" does not exist.`);
        }
    }

    // Get a content type from an extension.
    _sys_get_content_type(extension) {
        let content_type = this.content_type_mimes.iterate((item) => {
            if (item[0] == extension) {
                return item[1];
            }
        })
        if (content_type == null) {
            content_type = "application/octet-stream";
        }
        return content_type;
    }

    // Generate a key.
    _sys_generate_key(path) {
        const length = 32;
        const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        let key = "";
        for (let i = 0; i < length; i++) {
            key += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        return key;
    }

    // Generate a crypto key.
    _sys_generate_crypto_key(length = 32) {
        return libcrypto.randomBytes(length).toString('hex');
    }

    // Generate a 2fa code.
    _sys_generate_2fa(path) {
        const length = 6;
        const charset = "0123456789";
        let key = "";
        for (let i = 0; i < length; i++) {
            key += charset.charAt(Math.floor(Math.random() * charset.length));
        }
        return key;
    }

    // Load data.
    // _sys_load_data(path) {
    //     return libfs.readFileSync(path);
    // }

    // Load data into an object formatted line by line.
    // All data will be loaded as a string.
    // When the path does not exists the input object will be returned.
    _sys_load_data_into_obj(path, obj = {}, keys = []) {
        if (!libfs.existsSync(path)) {
            return obj;
        }
        const data = libfs.readFileSync(path);
        const key = 0;
        const info = {line: "", line_number: 0}
        for (let i = 0; i < data.length; i++) {
            const c = data.charAt(i);
            if (c == '\n') {
                ++key;
            } else {
                if (obj[keys[key]] === null) {
                    obj[keys[key]] = "";
                }
                obj[keys[key]] += c;
            }
        }
        return obj;
    }

    // Save an object to data formatted line by line.
    _sys_save_data_into_obj(path, obj, keys) {
        let data = "";
        for (let i = 0; i < keys.length; i++) {
            if (typeof obj[keys[i]] === "string") {
                data += obj[keys[i]];
            } else {
                data += obj[keys[i]].toString();
            }
        }
        libfs.writeFileSync(path, data);
    }

    // Delete a path if it does exist.
    _sys_delete_path(path) {
        if (libfs.existsSync(path)) {
            libfs.unlinkSync(path);
        }
    }

    // Delete a directory if it does exist.
    _sys_delete_dir(path) {
        if (libfs.existsSync(path)) {
            libfs.rmdirSync(path, {recursive: true});
        }
    }

    // Create a directory if it does not yet exist.
    _sys_mkdir(path) {
        if (!libfs.existsSync(path)) {
            libfs.mkdirSync(path);
        }
    }

    // Save or delete uid by username,
    _sys_save_uid_by_username(uid, username) {
        libfs.writeFileSync(`${this.database}/.sys/usernames/${username}`, uid);
    }
    _sys_delete_uid_by_username(username) {
        this._sys_delete_path(`${this.database}/.sys/usernames/${username}`);
    }

    // Save or delete uid by email,
    _sys_save_uid_by_email(uid, email) {
        libfs.writeFileSync(`${this.database}/.sys/emails/${email}`, uid);
    }
    _sys_delete_uid_by_email(email) {
        this._sys_delete_path(`${this.database}/.sys/emails/${email}`);
    }

    /*  Save, load or delete a system user object.
        An object has the following keys if the user is not deleted: 
        {
            first_name: string,
            last_name: string,
            username: string,
            email: string,
            password: string,
            api_key: string,
        }
     */
    _sys_load_user(uid) {
        return this._sys_save_data_into_obj(`${this.database}/.sys/users/${uid}`, {uid: uid}, [
            "first_name",
            "last_name",
            "username",
            "email",
            "password",
            "api_key",
        ]);
    }
    _sys_save_user(uid, user) {
        return this._sys_save_data_into_obj(
            `${this.database}/.sys/users/${uid}`, 
            user, 
            [
                "first_name",
                "last_name",
                "username",
                "email",
                "password",
                "api_key",
            ],
        );
    }
    // @todo the parameter requires the full sys user object.
    _sys_delete_user(user) {
        throw Error("@todo the parameter requires the full sys user object.");
        this._sys_delete_path(`${this.database}/.sys/users/${user.uid}`);
        this._sys_delete_uid_by_username(user.username);
        this._sys_delete_uid_by_email(user.email);
    }

    /*  Save, load or delete a system user token object used for signin in.
        An object has the following keys if the token exists:
        {
            expiration: number,
            token: string,
        }
     */
    _sys_load_user_token(uid) {
        const obj = this._sys_save_data_into_obj(`${this.database}/.sys/tokens/${uid}`, {expiration: 0}, [
            "expiration",
            "token",
        ]);
        if (typeof obj.expiration === "string") {
            obj.expiration = parseInt(obj.expiration);
        }
        return obj;
    }
    _sys_save_user_token(uid, token) {
        return this._sys_save_data_into_obj(
            `${this.database}/.sys/tokens/${uid}`, 
            token,
            [
               "expiration",
                "token",
            ],
        );
    }
    _sys_delete_user_token(uid) {
        this._sys_delete_path(`${this.database}/.sys/tokens/${uid}`);
    }

    /*  Save, load or delete a system user 2fa object used for two factor authentication.
        An object has the following keys if the token exists:
        {
            expiration: number,
            code: string,
        }
     */
    _sys_load_user_2fa(uid) {
        const obj = this._sys_save_data_into_obj(`${this.database}/.sys/2fa/${uid}`, {expiration: 0}, [
            "expiration",
            "code",
        ]);
        if (typeof obj.expiration === "string") {
            obj.expiration = parseInt(obj.expiration);
        }
        return obj;
    }
    _sys_save_user_2fa(uid, token) {
        return this._sys_save_data_into_obj(
            `${this.database}/.sys/2fa/${uid}`, 
            token,
            [
                "expiration",
                "code",
            ]
        );
    }
    _sys_delete_user_2fa(uid) {
        this._sys_delete_path(`${this.database}/.sys/2fa/${uid}`);
    }

    // Create a sha hmac with the master key.
    _hmac(data) {
        const hmac = libcrypto.createHmac("sha256", this.hash_key);
        hmac.update(data);
        return hmac.digest("hex");
    }

    // ---------------------------------------------------------
    // Authentication (private).

    // Generate a token by uid.
    _generate_token(uid) {
        this._check_uid_within_range(uid);
        const token = `1${uid}:${this._sys_generate_key()}`;
        this._sys_save_user_token(uid, {
            expiration: Date.now() + this.token_expiration * 1000,
            token: this._hmac(token),
        });
        return token;
    }

    // Perform authentication on a request.
    // Returns false when the authentication failed and true when it succeeded.
    _authenticate(request, response) {

        // Vars.
        let key;
        let is_token = true;

        // Get token from cookies.
        console.log("COOKIE:", request.headers.cookie);
        if (false) {
            if (false) {
                response.send({
                    status: 401, 
                    data: "Unauthorized.",
                });
                return false;

            }
            return true;
        }


        // Get api key key from bearer.
        else if (false) {
            if (false) {
                response.send({
                    status: 302, 
                    headers: {"Location": `/signin?next=${request.url}`},
                    data: "Permission denied.",
                });
                return false;

            }
            return true;
        }

        // Failed.
        return false;
    }

    // Sign a user in and return a response.
    _sign_in_response(response, uid) {

        // Generate token.
        const token = this._generate_token(uid);
        
        // Create headers.
        this._create_token_cookie(response, token);
        this._create_user_cookie(response, uid);
        this._create_detailed_user_cookie(response, uid);
            
        // Response.
        response.send({
            status: 200,
            data: {"message": "Successfully signed in."}
        });
    }

    // ---------------------------------------------------------
    // Headers (private).

    // Add header defaults.
    _set_header_defaults(response) {
        response.set_headers(this.default_headers);
        if (this.domain != null) {
            response.set_header("Origin", this.domain);
            response.set_header("Access-Control-Allow-Origin", this.domain);
        }
    }
    
    // Create token headers.
    //  - Should be called when generating a token.
    _create_token_cookie(response, token) {
        response.set_header("Cache-Control", "max-age=0, no-cache, no-store, must-revalidate, proxy-revalidate");
        response.set_header("Access-Control-Allow-Credentials", "true");
        const expires = new Date(Date.now().getTime() + this.token_expiration * 1000);
        if (typeof token === "object") {
            token = token.token;
        }
        response.set_cookie(`T=${token}; Max-Age=86400; Path=/; Expires=${expires.toUTCString()}; SameSite=None; Secure; HttpOnly;`);
    }
    
    // Create user headers.
    //  - Should be called when a user is authenticated.
    _create_user_cookie(response, uid) {
        if (uid != null && uid <= this.max_uid) {
            response.set_cookie(`UserID=${uid}; Path=/; SameSite=None; Secure;`);
            const is_activated = this.enable_2fa ? this.is_activated(uid) : true;
            response.set_cookie(`UserActivated=${is_activated}; Path=/; SameSite=None; Secure;`);
        } else {
            response.set_cookie(`UserID=-1; Path=/; SameSite=None; Secure;`);
            const is_activated = this.enable_2fa ? false : true;
            response.set_cookie(`UserActivated=${is_activated}; Path=/; SameSite=None; Secure;`);
        }
    }
    
    // Create user headers.
    //  - Should be called when a user has just signed in, signed up or changed their account.
    _create_detailed_user_cookie(response, uid) {
        const user = this.get_user(uid);
        response.set_cookie(`UserName=${user.username}; Path=/; SameSite=None; Secure;`);
        response.set_cookie(`UserFirstName=${user.first_name} Path=/; SameSite=None; Secure;`);
        response.set_cookie(`UserLastName=${user.last_name}; Path=/; SameSite=None; Secure;`);
        response.set_cookie(`UserEmail=${user.email}; Path=/; SameSite=None; Secure;`);
    }
    
    // Reset all default cookies.
    // - Should be called when a user signs out.
    _reset_cookies(response) {
        response.set_cookie("Set-Cookie", "T=; Path=/; SameSite=None; Secure; HttpOnly;");
        response.set_cookie("Set-Cookie", "UserID=-1; Path=/; SameSite=None; Secure;");
        response.set_cookie("Set-Cookie", "UserActivated=false; Path=/; SameSite=None; Secure;");
        response.set_cookie("Set-Cookie", "2FAUserID=-1; Path=/; SameSite=None; Secure;");
        response.set_cookie("Set-Cookie", "UserName=; Path=/; SameSite=None; Secure;");
        response.set_cookie("Set-Cookie", "UserFirstName=; Path=/; SameSite=None; Secure;");
        response.set_cookie("Set-Cookie", "UserLastName=; Path=/; SameSite=None; Secure;");
        response.set_cookie("Set-Cookie", "UserEmail=; Path=/; SameSite=None; Secure;");
    }

    // ---------------------------------------------------------
    // Endpoints (private).

    // Find endpoint.
    _find_endpoint(endpoint, method = null) {
        return this.endpoints.iterate((end) => {
            if (end.endpoint == endpoint && (method == null || method == end.method)) {
                return endpoint;
            }
        })
    }

    // Create static endpoints.
    _create_static_endpoints(base, dir) {
        const files = libfs.readdirSync(dir);
        files.iterate((name) => {

            // Join path.
            const path = libpath.join(dir, name);

            // Read dir recursively.
            if (libfs.statSync(path).isDirectory()) {
                this.create_static_endpoints(base, path);
            }

            // Add file.
            else {
                const subpath = path.substr(base.length)
                if (subpath.charAt(0) != "/") {
                    subpath = "/" + subpath;
                }
                this.endpoint(new Endpoint({
                    method: "GET",
                    endpoint: subpath,
                    data: libfs.readFileSync(path/*, 'utf8'*/),
                    content_type: this._sys_get_content_type(libpath.extname(path))
                }))
            }
        })
    }

    // Create default endpoints.
    _create_default_endpoints() {
        const defaults = [
            {
                method: "GET",
                endpoint: "/vweb/vweb.css",
                content_type: "text/css",
                path: `${__dirname}/../../include/vweb/ui/css/vweb.css`,
            },
            {
                method: "GET",
                endpoint: "/vweb/vhighlight.css",
                content_type: "text/css",
                path: `${__dirname}/../../include/vweb/ui/css/vhighlight.css`,
            },
            {
                method: "GET",
                endpoint: "/vweb/vweb.js",
                content_type: "application/javascript",
                path: `${__dirname}/../../include/vweb/ui/js/vweb.js`,
            },
        ]
        defaults.iterate((item) => {
            this.endpoint(new Endpoint({
                method: item.method,
                endpoint: item.endpoint,
                data: libfs.readFileSync(item.path/*, 'utf8'*/),
                content_type: item.content_type,
                compress: item.compress,
            }))
        })
    }

    // Create the sitemap endpoint.
    _create_sitemap() {
        let sitemap = "";
        sitemap += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        sitemap += "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n";
        this.endpoints.iterate((endpoint) => {
            if (
                endpoint.data == null &&
                endpoint.endpoint != "robots.txt" &&
                !endpoint.authenticated
            ) {
                sitemap += `<url>\n   <loc>${endpoint.endpoint}</loc>\n</url>\n`;
            }
        })
        sitemap += "</urlset>\n";
        this.endpoint(new Endpoint({
            method: "GET",
            endpoint: "/sitemap.xml",
            data: sitemap,
            content_type: "application/xml",
            compress: false,
        }))
    }

    // Create the robots.txt endpoint.
    _create_robots_txt() {
        this.endpoint(new Endpoint({
            method: "GET",
            endpoint: "/robots.txt",
            content_type: "text/plain",
            data: `User-agent: *\nDisallow: \n\nSitemap: /sitemap.xml`,
            compress: false,
        }))
    }

    // ---------------------------------------------------------
    // Server (private).

    // Initialize.
    _initialize() {

        // Check & create database.
        if (!libfs.existsSync(this.database)) {
            throw Error(`Database "${this.database}" does not exist.`);
        }
        [
            ".sys",
            ".sys/users",
            ".sys/tokens",
            ".sys/usernames",
            ".sys/emails",
            ".sys/keys",
            ".sys/unactivated",
            ".sys/2fa",
            "users",
        ].iterate((subpath) => {
            this._sys_mkdir(libpath.join(this.database, subpath));
        })
        
        // Load keys.
        const path = libpath.join(this.database, ".sys/keys/keys");
        if (!libfs.existsSync(path)) {
            this.hash_key = this._sys_generate_crypto_key(32);
            libfs.writeFileSync(path, JSON.stringify({
                sha256: this.has_key,
            }));
        } else {
            const data = JSON.parse(libfs.readFileSync(path));
            this.hash_key = data["sha256"];
        }
        
        // Get max user id.
        this.max_uid = 0;
        this._iter_db_dir(".sys/users", (name) => {
            const uid = parseInt(name);
            if (uid > this.max_uid) {
                this.max_uid = uid;
            }
        });

        // Create default endpoints.
        this._create_default_endpoints();

        // Create static endpoints.
        this.statics.iterate((path) => {
            this._create_static_endpoints(libpath.dirname(path), path);
        });
        
        // Create sitemap when it does not exist.
        if (this._find_endpoint("sitemap.xml") == null) {
            this._create_sitemap();
        }
        
        // Create robots.txt when it does not exist.
        if (this._find_endpoint("robots.txt") == null) {
            this._create_robots_txt();
        }
        
        // Stripe.
        // if (stripe.is_defined()) {
        //     stripe.products() = config.stripe_products;
        //     stripe.check_products();
        // }

    }

    // Serve a client.
    // @todo implement rate limiting.
    _serve(request, response) {
        response = new Response(response);

        // Parse the request method and URL
        const { method, url } = request;
        console.log(`${Date.now()}: ${method} ${url}.`);

        // Set default headers.
        this._set_header_defaults(response);

        // Check if the request matches any of the defined endpoints
        const endpoint = this.endpoints.find((endpoint) => {
            return endpoint.method === method && endpoint.endpoint === url;
        });

        // No endpoint found.
        if (!endpoint) {
            response.send({
                status: 404, 
                headers: {"Content-Type": "text/plain"},
                data: "Not Found",
            });
            return null;
        }

        // Check rate limiting.
        // @todo.

        // Perform authentication.
        if (endpoint.authenticated && !this._authenticate(request, response)) {
            return null;
        }

        // Serve endpoint.
        try {
            endpoint._serve(request, response);
        } catch (err) {
            console.error(`${method} ${url}: Internal Server Error.`);
            console.error(err);
            return response.send({
                status: 500, 
                headers: {"Content-Type": "text/plain"},
                data: "Internal Server Error",
            });
        }

        // Check if the response has been sent.
        if (!response.finished) {
            console.error(`${method} ${url}: Unfinished response.`);
            response.send({
                status: 500, 
                headers: {"Content-Type": "text/plain"},
                data: "Internal Server Error",
            });
        }
    }

    // ---------------------------------------------------------
    // Server.

    // Start the server.
    start() {

        // Inside file watcher process.
        if (this.https === undefined) {
            return null;
        }

        // Initialize.
        this._initialize();

        // Listen.
        this.https.listen(this.port, this.ip, () => {
            console.log(`Running on ${this.ip}:${this.port}.`);
        });
        this.https.on("error", (err) => {
            console.error("Server error:", err);
        });

        // Set signals.
        process.on('SIGTERM', () => this.stop());
        process.on('SIGINT', () => this.stop());
    }

    // Stop the server.
    stop() {
        if (this.https === undefined) {
            return null; // inside file watcher process.
        }
        this.https.close(() => {
            process.exit(0);
        });
    }

    // ---------------------------------------------------------
    // Users.
    
    // Check if a username exists.
    /*  @docs {
     *  @title: Username Exists
     *  @description: Check if a username exists.
     *  @return: Returns a boolean indicating whether the username exists or not.
     *  @parameter: {
     *      @name: username
     *      @description: The username to check.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const exists = server.username_exists("someusername");
     } */
    username_exists(username) {
        return libfs.existsSync(`${this.database}/.sys/usernames/${username}`);
    }
    
    // Check if an email exists.
    /*  @docs {
     *  @title: Email Exists
     *  @description: Check if a email exists.
     *  @return: Returns a boolean indicating whether the email exists or not.
     *  @parameter: {
     *      @name: email
     *      @description: The email to check.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      Bool exists = server.email_exists("some\@email.com");
     } */
    email_exists(email) {
        return libfs.existsSync(`${this.database}/.sys/emails/${email}`);
    }
    
    // Check if a user account is activated.
    /*  @docs {
     *  @title: Is Activated
     *  @description: Check if a user account is activated.
     *  @return: Returns a boolean indicating whether the account is activated or not.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to check.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      Bool activated = server.is_activated(0);
     } */
    is_activated(uid) {
        return !libfs.existsSync(`${this.database}/.sys/unactivated/${uid}`);
    }
    
    // Set the activated status of a user account is activated.
    /*  @docs {
     *  @title: Set Activated
     *  @description: Set the activated status of a user account is activated.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: activated
     *      @description: The boolean with the new activated status.
     *      @type: boolean
     *  }
     *  @usage:
     *      ...
     *      server.set_activated(0, true);
     } */
    set_activated(uid, activated) {
        if (activated == true) {
            this._sys_delete_path(`${this.database}/.sys/unactivated/${uid}`);
        } else {
            libfd.writeFileSync(`${this.database}/.sys/unactivated/${uid}`, "");
        }
    }
    
    // Create user.
    /*  @docs {
     *  @title: Create User
     *  @description: Create a user account.
     *  @return: Returns the uid of the newly created user.
     *  @parameter: {
     *      @name: first_name
     *      @description: The user's first name.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: last_name
     *      @description: The user's last name.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: username
     *      @description: The username of the new account.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: email
     *      @description: The email of the new account.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: password
     *      @description: The password of the new account.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const uid = server.create_user({
     *          first_name: "John", 
     *          last_name: "Doe", 
     *          username: "johndoe", 
     *          email: "johndoe\@email.com",
     *          password: "HelloWorld!"
     *      });
     } */
    create_user({
        first_name,
        last_name,
        username,
        email,
        password
    }) {
        
        // Check if username & email already exist.
        if (this.username_exists(username)) {
            throw Error(`Username "${username}" already exists.`);
        }
        if (this.email_exists(email)) {
            throw Error(`Email "${email}" already exists.`);
        }
        
        // Get new uid.
        // @todo check for deleted uids.
        this.edit_max_uid_mutex.lock();
        ++this.max_uid;
        const uid = this.max_uid;
        this.edit_max_uid_mutex.unlock();
        
        // Save sys data.
        this._sys_save_user(uid, {
            first_name: first_name,
            last_name: last_name,
            username: username,
            email: email,
            password: this._hmac(password),
            api_key: "",
        });
        this._sys_save_uid_by_username(uid, username);
        this._sys_save_uid_by_email(uid, email);
        this.set_activated(uid, false);
        
        // Create user dir.
        this._sys_mkdir(`${this.database}/users/${uid}/`);
        
        // Return uid.
        return uid;
    }
    
    // Delete user.
    // The file paths should never be deleted.
    /*  @docs {
     *  @title: Delete User
     *  @description: Delete a user account.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id of the account to delete.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      server.delete_user(0);
     } */
    delete_user(uid) {
        this._check_uid_within_range(uid);
        this._sys_delete_user(uid);
        this._sys_delete_dir(`${this.database}/users/${uid}`);
    }
    
    // Set a user's first name.
    /*  @docs {
     *  @title: Set First Name
     *  @description:
     *      Set a user's first name
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: first_name
     *      @description: The new first name.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      server.set_first_name(0, "Name");
     } */
    set_first_name(uid, first_name) {
        const user = this.get_user(uid);
        user.first_name = first_name;
        this._sys_save_user(uid, user);
    }
    
    // Set a user's last name.
    /*  @docs {
     *  @title: Set Last Name
     *  @description:
     *      Set a user's last name
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: last_name
     *      @description: The new last name.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      server.set_first_name(0, "Name");
     } */
    set_last_name(uid, last_name) {
        const user = this.get_user(uid);
        user.last_name = last_name;
        this._sys_save_user(uid, user);
    }
    
    // Set a user's username.
    /*  @docs {
     *  @title: Set Username
     *  @description:
     *      Set a user's username
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: username
     *      @description: The new username.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      server.set_username(0, "newusername");
     } */
    set_username(uid, username) {
        if (this.username_exists(username)) {
            throw Error(`Username "${username}" already exists.`);
        }
        const user = this.get_user(uid);
        user.username = username;
        this._sys_save_user(uid, user);
        this._sys_save_uid_by_username(uid, username);
    }
    
    // Set a user's email.
    /*  @docs {
     *  @title: Set Email
     *  @description:
     *      Set a user's email
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: email
     *      @description: The new email.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      server.set_email(0, "new\@email.com");
     } */
    set_email(uid, email) {
        if (this.email_exists(email)) {
            throw Error(`Email "${email}" already exists.`);
        }
        const user = this.get_user(uid);
        user.email = email;
        this._sys_save_user(uid, user);
        this._sys_save_uid_by_email(uid, email);
    }
    
    // Set a user's password.
    /*  @docs {
     *  @title: Set Password
     *  @description:
     *      Set a user's password
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: password
     *      @description: The new password.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      server.set_password(0, "XXXXXX");
     } */
    set_password(uid, password) {
        const user = this.get_user(uid);
        user.password = this._hmac(password);
        this._sys_save_user(uid, user);
    }
    
    // Set a user's data.
    /*  @docs {
     *  @title: Set user
     *  @description:
     *      Set a user's data
     *
     *      When a key does not exist in the new user object it will not be set.
     *
     *      Does not update the user's id, key and password data.
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: user
     *      @description: The new user object.
     *      @type: object
     *  }
     *  @usage:
     *      ...
     *      server.set_user(0, {first_name: "John", last_name: "Doe"});
     } */
    set_user(uid, user) {
        const current_user = this.get_user(uid);
        let old_username = null, old_email = null;
        
        // First name.
        if (user.first_name != null && user.first_name != current_user.first_name) {
            current_user.first_name = user.first_name;
        }
        
        // Last name.
        if (user.last_name != null && user.last_name != current_user.last_name) {
            current_user.last_name = user.last_name;
        }
        
        // Username.
        if (user.username != null && user.username != current_user.username) {
            if (this.username_exists(user.username)) {
                throw Error(`Username "${user.username}" already exists.`);
            }
            old_username = current_user.username;
            current_user.username = user.username;
        }
        
        // Email.
        if (user.email != null && user.email != current_user.email) {
            if (this.email_exists(user.email)) {
                throw Error(`Email "${user.email}" already exists.`);
            }
            old_email = current_user.email;
            current_user.email = user.email;
        }
        
        // Save.
        this._sys_save_user(uid, current_user);
        if (old_username !== null) {
            this._sys_save_uid_by_username(suid, current_user.username);
            this._sys_delete_uid_by_username(suid, old_username);
        }
        if (old_email !== null) {
            this._sys_save_uid_by_email(suid, current_user.email);
            this._sys_delete_uid_by_email(suid, old_email);
        }
        
    }
    
    // Get uid by username.
    /*  @docs {
     *  @title: Get UID
     *  @description: Get a uid by username.
     *  @return:
     *      Returns the uid of the username.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: username
     *      @description: The username of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = server.get_uid("myusername")) !== null) { ... }
     } */
    get_uid(username) {
        if (username == null) {
            return null;
        }
        const path = `${this.database}/.sys/usernames/${username}`;
        if (libfs.existsSync(path)) {
            const uid = parseInt(libfs.readFileSync(path));
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by email.
    /*  @docs {
     *  @title: Get UID By Email
     *  @description: Get a uid by email.
     *  @return:
     *      Returns the uid of the email.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: email
     *      @description: The email of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = server.get_uid_by_email("my\@email.com")) !== null) { ... }
     } */
    get_uid_by_email(email) {
        if (email == null) {
            return null;
        }
        const path = `${this.database}/.sys/emails/${email}`;
        if (libfs.existsSync(path)) {
            const uid = parseInt(libfs.readFileSync(path));
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by api key.
    /*  @docs {
     *  @title: Get UID By API Key
     *  @description: Get a uid by API key.
     *  @return:
     *      Returns the uid of the api key.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: api_key
     *      @description: The API key of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = server.get_uid_by_api_key("XXXXXXXXXX")) !== null) { ... }
     } */
    get_uid_by_api_key(api_key) {
        let pos;
        if ((pos = api_key.indexOf(':')) != -1) {
            const uid = parseInt(api_key.substr(1, pos - 1));
            if (isNaN(uid)) {
                return null;
            }
            return uid;
        }
        return null;
    }
    
    // Get uid by token.
    /*  @docs {
     *  @title: Get UID By Token
     *  @description: Get a uid by token.
     *  @return:
     *      Returns the uid of the token.
     *
     *      If the user does not exist `null` is returned.
     *  @parameter: {
     *      @name: token
     *      @description: The token of the uid to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      let uid;
     *      if ((uid = server.get_uid_by_token("XXXXXXXXXX")) !== null) { ... }
     } */
    get_uid_by_token(token) {
        return this.get_uid_by_api_key(token);
    }
    
    // Get user info by uid.
    /*  @docs {
     *  @title: Get User
     *  @description:
     *      Get a user by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user to fetch.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      const user = server.get_user(0);
     } */
    get_user(uid) {
        this._check_uid_within_range(uid);
        return this._sys_load_user(uid);
    }
    
    // Get user info by username.
    /*  @docs {
     *  @title: Get User By Username
     *  @description:
     *      Get a user by username.
     *
     *      If the username does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: username
     *      @description: The username of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = server.get_user_by_username("myusername");
     } */
    get_user_by_username(username) {
        const uid = this.get_uid(username);
        if (uid === null) {
            throw Error(`No user with username "${username}" exists.`);
        }
        return this.get_user(uid);
    }
    
    // Get user info by email.
    /*  @docs {
     *  @title: Get User By Email
     *  @description:
     *      Get a user by email.
     *
     *      If the email does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: email
     *      @description: The email of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = server.get_user_by_email("my\@email.com");
     } */
    get_user_by_email(email) {
        const uid = this.get_uid_by_email(email);
        if (uid === null) {
            throw Error(`No user with email "${email}" exists.`);
        }
        return this.get_user(uid);
    }
    
    // Get user info by api key.
    /*  @docs {
     *  @title: Get User By API Key
     *  @description:
     *      Get a user by API key.
     *
     *      If the API key does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: api_key
     *      @description: The API key of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = server.get_user_by_api_key("XXXXXX");
     } */
    get_user_by_api_key(api_key) {
        const uid = this.get_uid_by_api_key(api_key);
        if (uid === null) {
            throw Error(`No user with api key "${api_key}" exists.`);
        }
        return this.get_user(uid);
    }
    
    // Get user info by token.
    /*  @docs {
     *  @title: Get User By Token
     *  @description:
     *      Get a user by token.
     *
     *      If the token does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a User object.
     *  @parameter: {
     *      @name: token
     *      @description: The token of the user to fetch.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const user = server.get_user_by_token("XXXXXX");
     } */
    get_user_by_token(token) {
        const uid = this.get_uid_by_token(token);
        if (uid === null) {
            throw Error(`No user with token "${token}" exists.`);
        }
        return this.get_user(uid);
    }
    
    // Load user data.
    /*  @docs {
     *  @title: Load user data
     *  @description:
     *      Load user data by subpath.
     *
     *      The subpath resides in the user's data directory.
     *  @return:
     *      Returns the loaded data.
     *
     *      Returns an empty type object when the data does not exist.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: type
     *      @description: The data types to load, valid types are [`string`, `array`, `object`].
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const data = server.load_user_data(0, "mydata", "object");
     } */
    load_user_data(uid, subpath, type) {
        this._check_uid_within_range(uid);
        const path = `${this.database}/users/${uid}/${subpath}`;
        if (!libfs.existsSync(path)) {
            if (type === "string") {
                return "";
            } else if (type === "array") {
                return [];
            } else if (type === "object") {
                return {};
            } else {
                throw Error(`Invalid data type "${type}", the valid options are ["string", "array", "object"].`);
            }
        }
        const data = libfs.readFileSync(path);
        if (type === "string") {
            return data;
        } else if (type === "array" || type === "object") {
            return JSON.parse(data);
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["string", "array", "object"].`);
        }
    }
    
    // Save user data.
    /*  @docs {
     *  @title: Save user data
     *  @description:
     *      Save user data by subpath.
     *
     *      The subpath resides in the user's data directory.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the user.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: subpath
     *      @description: The subpath to the file.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: data
     *      @description: The data to save.
     *      @type: string, array, object
     *  }
     *  @usage:
     *      ...
     *      server.save_user_data(0, "mydata", {"Hello": "World!"});
     *      server.save_user_data(0, "mystring", "Hello World!");
     } */
    save_user_data(uid, subpath, data) {
        this._check_uid_within_range(uid);
        const path = `${this.database}/users/${uid}/${subpath}`;
        if (type === "string") {
            libfs.writeFileSync(path, data);
        } else if (type === "array" || type === "object") {
            libfs.writeFileSync(path, JSON.stringify(data));
        } else {
            throw Error(`Invalid data type "${type}", the valid options are ["string", "array", "object"].`);
        }
    }
    
    // Generate an api key by uid.
    /*  @docs {
     *  @title: Generate API Key
     *  @description:
     *      Generate an API key for a user.
     *
     *      Generating an API key overwrites all existing API keys.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns the API key string.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to generate an API key for.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      const api_key = server.generate_api_key(0);
     } */
    generate_api_key(uid) {
        this._check_uid_within_range(uid);
        const api_key = `0${uid}:${this._sys_generate_key()}`;
        const user = this._sys_load_user(uid);
        user.api_key = this._hmac(api_key);
        this._sys_save_user(uid, user);
        return api_key;
    }
    
    // Revoke the API key of a user.
    /*  @docs {
     *  @title: Revoke API Key
     *  @description:
     *      Revoke the API key of a user.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to revoke the API key for.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      server.revoke_api_key(0);
     } */
    revoke_api_key(uid) {
        this._check_uid_within_range(uid);
        const user = this._sys_load_user(uid);
        user.api_key = "";
        this._sys_save_user(uid, user);
    }
    
    // Verify a plaintext password.
    /*  @docs {
     *  @title: Verify Password
     *  @description:
     *      Verify a plaintext password.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the account to verify.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: password
     *      @description: The plaintext password.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = server.verify_password(0, "XXXXXX");
     } */
    verify_password(uid, password) {
        if (uid === null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const user = this._sys_load_user(uid);
        return user.uid !== null && user.password === this._hmac(password);
    }
    
    // Verify a plaintext api key.
    /*  @docs {
     *  @title: Verify API Key
     *  @description:
     *      Verify an plaintext API key.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: api_key
     *      @description: The api key to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = server.verify_api_key("XXXXXX");
     } */
    verify_api_key(api_key) {
        let pos;
        if ((pos = api_key.indexOf(':')) != -1) {
            const uid = parseInt(api_key.substr(1, pos - 1));
            if (isNaN(uid)) {
                return false;
            }
            return this.verify_api_key_by_uid(uid, api_key);
        }
        return false;
    }
    /*  @docs {
     *  @title: Verify API Key By UID
     *  @description:
     *      Verify an plaintext API key by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the api key to verify.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: api_key
     *      @description: The api key to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = server.verify_api_key_by_uid(0, "XXXXXX");
     } */
    verify_api_key_by_uid(uid, api_key) {
        if (uid == null) {
            return false;
        }
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const user = this._sys_load_user(uid);
        return user.uid !== null && user.api_key.length > 0 && user.api_key == this._hmac(api_key);
    }
    
    // Verify a token.
    /*  @docs {
     *  @title: Verify Token
     *  @description:
     *      Verify an plaintext token.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: api_key
     *      @description: The token to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = server.verify_token("XXXXXX");
     } */
    verify_token(token) {
        let pos;
        if ((pos = token.indexOf(':')) != -1) {
            const uid = parseInt(token.substr(1, pos - 1));
            if (isNaN(uid)) {
                return false;
            }
            return this.verify_token_by_uid(uid, token);
        }
        return false;
    }
    /*  @docs {
     *  @title: Verify Token By UID.
     *  @description:
     *      Verify an plaintext token by uid.
     *
     *      If the uid does not exist an `Error` will be thrown.
     *  @return:
     *      Returns a boolean indicating whether the verification was successful.
     *  @parameter: {
     *      @name: uid
     *      @description: The uid of the token to verify.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: api_key
     *      @description: The token to verify.
     *      @type: string
     *  }
     *  @usage:
     *      ...
     *      const success = server.verify_token_by_uid(0, "XXXXXX");
     } */
    verify_token_by_uid(uid, token) {
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const correct_token = this._sys_load_user_token(uid);
        return Date.now() < correct_token.expiration && correct_token.token == this._hmac(token);
    }
    
    // Send a mail.
    /*  @docs {
     *  @title: Send Mail
     *  @description:
     *      Send one or multiple mails.
     *
     *      Make sure the domain's DNS records SPF and DKIM are properly configured when sending attachments.
     *
     *      See `vlib::smtp::Client` and `vlib::smtp::Mail` for more info.
     *  @return:
     *      Returns a promise that will be resolved or rejected when the mail has been sent.
     *  @parameter: {
     *      @name: sender
     *      @description:
     *          The sender address.
     *          A sender address may either be a string with the email address, e.g. `your@email.com`.
     *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
     *      @type: string, array
     *  }
     *  @parameter: {
     *      @name: recipients
     *      @description:
     *          The recipient addresses.
     *          A reciepient address may either be a string with the email address, e.g. `your@email.com`.
     *          Or an array with the sender name and email address, e.g. `["Sender", "your@email.com"]`.
     *      @type: array[string, array]
     *  }
     *  @parameter: {
     *      @name: subject
     *      @description: The subject text.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: body
     *      @description: The body text.
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: attachments
     *      @description: An array with absolute file paths for attachments.
     *      @type: array[string]
     *  }
     *  @usage:
     *      ...
     *      server.send_mail({
     *          sender: ["Sender Name", "sender\@email.com"],
     *          recipients: [
     *              ["Recipient Name", "recipient1\@email.com"],
     *              "recipient2\@email.com",
     *          },
     *          subject: "Example Mail",
     *          body: "Hello World!",
     *          attachments: ["/path/to/image.png"]
     *      });
     } */
    async send_mail({
        sender = null,
        recipients = [],
        subject = null,
        body = "",
        attachments = [],
    }) {
        return new Promise((resolve, reject) => {

            // Check args.
            if (sender === null) {
                return reject(`Parameter "sender" should be a defined value of type "string" or "array".`);
            }
            if (recipients.length === 0) {
                return reject(`The mail has no recipients.`);
            }
            if (sender === null) {
                return reject(`Parameter "sender" should be a defined value of type "string" or "array".`);
            }

            // Format address wrapper.
            const format_address = (address) => {
                if (Array.isArray(address)) {
                    return `${address[0]} <${address[1]}>`;
                }
                return address;
            }

            // Create to array.
            const to = [];
            recipients.iterate((address) => to.push(format_address(address)));

            // Create attachments array.
            const attached_files = [];
            attachments.iterate((path) => {
                attached_files.push({
                    filename: libpath.basename(path),
                    path: path,
                })
            })

            // Send mail.
            this.smtp.sendMail(
                {
                    from: format_address(sender),
                    to: to,
                    subject: subject,
                    html: body,
                    attachments: attachments,
                },
                (error, info) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(info);
                    }
                }
            )

        })
    }
    
    // Send a 2fa code.
    /*  @docs {
     *  @title: Send 2FA Code
     *  @description:
     *      Send a 2FA code to a user by user id.
     *
     *      By default the 2FA code will be valid for 5 minutes.
     *  @return:
     *      Returns a promise that will be resolved or rejected when the 2fa mail has been sent.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: request
     *      @description: The request object from the client request.
     *      @type: object
     *  }
     *  @parameter: {
     *      @name: response
     *      @description: The response object from the client request.
     *      @type: Response
     *  }
     *  @parameter: {
     *      @name: mail_body
     *      @description: 
     *          The mail body in HTML. 
     *          When this parameter is undefined, the server attribute `mail_body_2fa` will be used as the body.
     *          It should contain the string "{{2FA}}", which will be replaced with the generated 2FA code.
     *          Other optional replaced keys are: 
     *              - `{{USERNAME}}`
     *              - `{{DATE}}`
     *              - `{{IP}}`
     *              - `{{DEVICE}}`
     *      @type: string
     *  }
     *  @parameter: {
     *      @name: expiration
     *      @description: The amount of seconds in which the code will expire.
     *      @type: number
     *  }
     *  @usage:
     *      ...
     *      server.send_2fa({uid: 0, request: request, response: response});
     } */
    async send_2fa({
        uid, 
        request,
        response, 
        mail_body = null,
        expiration = 300,
    }) {
        this._check_uid_within_range(uid);
        
        // Generate 2fa.
        const auth = {
            expiration: Date.now() + expiration * 1000,
            code: this._sys_generate_2fa(),
        };
        this._sys_save_user_2fa(uid, auth);
        
        // Get user email.
        const user = this.get_user(uid);
        
        // Get device.
        const device = response.get_header("User-Agent");
        
        // Replace body.
        let body;
        if (mail_body == null) {
            body = this.mail_body_2fa
                .replaceAll("{{2FA}}", auth.code)
                .replaceAll("{{USERNAME}}", user.username)
                .replaceAll("{{DATE}}", (new Date()).toUTCString())
                .replaceAll("{{IP}}", request.connection.remoteAddress)
                .replaceAll("{{DEVICE}}", device ? device : "Unknown");    
        } else {
            body = mail_body
                .replaceAll("{{2FA}}", auth.code)
                .replaceAll("{{USERNAME}}", user.username)
                .replaceAll("{{DATE}}", (new Date()).toUTCString())
                .replaceAll("{{IP}}", request.connection.remoteAddress)
                .replaceAll("{{DEVICE}}", device ? device : "Unknown");
        }
        
        // Send mail.
        return this.send_mail({
            sender: config.domain_name.is_defined() ? vlib::smtp::Address{config.domain_name, m_smtp.email} : vlib::smtp::Address{m_smtp.email},
            recipients: {user.email},
            subject: "Two Factor Authentication Code",
            body: body,
        });
        
    }
    
    // Verify a 2fa code.
    /*  @docs {
     *  @title: Verify 2FA Code
     *  @description:
     *      Verify a 2FA code by user id.
     *  @parameter: {
     *      @name: uid
     *      @description: The user id.
     *      @type: number
     *  }
     *  @parameter: {
     *      @name: code
     *      @description: The 2FA code.
     *      @type: string
     *  }
     *  @return: Returns a boolean indicating whether the verification was successful or not.
     *  @usage:
     *      ...
     *      server.verify_2fa(0, "123456");
     } */
    verify_2fa(uid, code) {
        try {
            this._check_uid_within_range(uid);
        } catch (err) {
            return false;
        }
        const auth = this._sys_load_user_2fa(uid);
        const now = Date.now();
        const status = auth.code != null && now < auth.expiration && auth.code == code;
        if (status || now > auth.expiration) {
            this._sys_delete_user_2fa(suid);
        }
        return status;
    }

    // ---------------------------------------------------------
    // Endpoints.

    // Add one or multiple endpoints.
    /*  @docs: {
        @title: Add endpoint(s)
        @description: Add one or multiple endpoints.
        @parameter: {
            @name: ...endpoints
            @description:
                The endpoint parameters.

                An endpoint parameter can either be a `Endpoint` class or an `object` with the `Endpoint` arguments.
            @type: Endpoint, object
        }
    } */
    endpoint(...endpoints) {
        for (let i = 0; i < endpoints.length; i++) {
            const endpoint = endpoints[i];
            if (endpoint instanceof Endpoint) {
                this.endpoints.push(endpoint);
            } else {
                this.endpoints.push(new Endpoint(endpoint));
            }
        }
        return this;
    }
};

// ---------------------------------------------------------
// Exports.

module.exports = Server;
